"""Kat compiler expression unit tests."""
import numpy as np
import pytest
from hypothesis import given, settings, note, assume, HealthCheck
from finesse.script import parse
from testutils.text import dedent_multiline
from testutils.data import (
    EAGER_EXPRESSIONS,
    EAGER_EXPRESSIONS_COMPLEX as _EAGER_EXPRESSIONS_COMPLEX,
    LAZY_EXPRESSIONS,
)
from testutils.fuzzing import DEADLINE, recursive_expressions


# Some expressions generated by Hypothesis produce errors that are hard to detect before
# evaluating, so we instead define a failure allow list that, if matched, should not
# fail the test but just ignore it.
ALLOWED_EXPRESSION_ERRORS = [
    # Invalid complex exponentiation.
    "complex exponentiation",
    # Invalid complex arithmetic, e.g. `1 // (1+2j)`, < Python 3.10.
    "can't take floor of complex number.",
    # Invalid complex arithmetic, e.g. `1 // (1+2j)`, Python 3.10+ (bpo-41974).
    "unsupported operand type(s) for //: 'int' and 'complex'",
    "unsupported operand type(s) for //: 'complex' and 'int'",
    "unsupported operand type(s) for //: 'float' and 'complex'",
    "unsupported operand type(s) for //: 'complex' and 'float'",
    "unsupported operand type(s) for //: 'complex' and 'complex'",
]


# Only use positive complex numbers for parser tests because the parameter used in the tests (a q
# parameter) doesn't allow negative numbers.
EAGER_EXPRESSIONS_COMPLEX = (
    (script, expected)
    for script, expected in _EAGER_EXPRESSIONS_COMPLEX
    if expected.imag > 0 and expected.imag != float("inf")
)


@pytest.mark.parametrize("expression,expected", EAGER_EXPRESSIONS)
def test_expressions_eager(expression, expected):
    """Expressions that should be eagerly evaluated."""
    model = parse(f"var myvar {expression}")
    assert np.allclose(model.myvar.value, expected)


@pytest.mark.parametrize("expression,expected", EAGER_EXPRESSIONS_COMPLEX)
def test_expressions_eager_complex(expression, expected):
    """Complex expressions that should be eagerly evaluated."""
    model = parse(
        f"""
        laser l1
        gauss mygauss l1.p1.o q={expression}
        """
    )
    assert np.allclose(model.mygauss.qx.q, expected) or model.mygauss.qx.q == expected


@pytest.mark.parametrize("expression,expected", LAZY_EXPRESSIONS)
def test_expressions_lazy(expression, expected):
    """Expressions that should be lazily evaluated."""
    model = parse(f"var myvar {expression}")
    assert model.myvar.value == expected


@pytest.mark.parametrize(
    "script,attr,expected",
    (
        (
            dedent_multiline(
                """
                var order 2
                modulator mod1 10M 0.1 1+order
                """
            ),
            "mod1.order",
            3,
        ),
    ),
)
def test_expressions_with_info_parameter_arguments(script, attr, expected):
    """Test that info parameter arguments can be referenced in expressions.

    See #130 and !57.
    """
    model = parse(script)
    assert model.get(attr).eval() == expected


@given(value=recursive_expressions())
@settings(
    deadline=DEADLINE,
    suppress_health_check=[HealthCheck.filter_too_much, HealthCheck.too_slow],
)
@pytest.mark.xfail(
    reason="I don't see why the Zero division exception is not being ignored in the symbolics"
)
def test_expression_fuzzing(fuzz_argument, value):
    note(f"Expression: {value}")

    try:
        # The str() method of Function should be Python syntax compatible.
        expected = eval(str(value))
        value = fuzz_argument(value)
    except ZeroDivisionError:
        # There are infinitely many zero division errors so we catch them before the
        # general catch-all exception below.
        assume(False)
    except OverflowError:
        # Nothing we can do about this.
        assume(False)
    except Exception as e:
        if str(e) in ALLOWED_EXPRESSION_ERRORS:
            assume(False)
        else:
            raise

    assert value == expected
