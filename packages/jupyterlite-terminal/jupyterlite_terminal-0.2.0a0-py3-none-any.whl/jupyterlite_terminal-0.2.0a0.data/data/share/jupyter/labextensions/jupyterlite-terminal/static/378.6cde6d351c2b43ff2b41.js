"use strict";(self.webpackChunk_jupyterlite_terminal=self.webpackChunk_jupyterlite_terminal||[]).push([[378],{7378:(e,t,n)=>{n.r(t),n.d(t,{default:()=>h});var s=n(5713),i=n(6173),o=n(4602),r=n(1346);class a extends r.BaseShell{constructor(e){super(e)}initWorker(e){return console.log("Terminal create webworker"),new Worker(new URL(n.p+n.u(671),n.b),{type:void 0})}}class c{constructor(e){this._isDisposed=!1,this._disposed=new o.Signal(this),this._connectionStatus="connecting",this._connectionStatusChanged=new o.Signal(this),this._messageReceived=new o.Signal(this),this._name=e.model.name,this._serverSettings=e.serverSettings;const{baseUrl:t}=this._serverSettings,{browsingContextId:n}=e;this._shell=new a({mountpoint:"/drive",driveFsBaseUrl:t,wasmBaseUrl:t+"extensions/@jupyterlite/terminal/static/wasm/",outputCallback:this._outputCallback.bind(this),browsingContextId:n}),this._shell.disposed.connect((()=>this.dispose())),this._shell.start().then((()=>this._updateConnectionStatus("connected")))}get connectionStatus(){return this._connectionStatus}get connectionStatusChanged(){return this._connectionStatusChanged}dispose(){this._isDisposed||(this._isDisposed=!0,this._shell.dispose(),this._disposed.emit(),this._updateConnectionStatus("disconnected"),o.Signal.clearData(this))}get disposed(){return this._disposed}get isDisposed(){return this._isDisposed}get messageReceived(){return this._messageReceived}get model(){return{name:this._name}}get name(){return this._name}async reconnect(){console.log("==> LiteTerminalConnection.reconnect not implemented")}send(e){const{content:t}=e;if(void 0!==t)switch(e.type){case"stdin":this._shell.input(t[0]);break;case"set_size":{const e=t[0],n=t[1];this._shell.setSize(e,n);break}}}get serverSettings(){return this._serverSettings}async shutdown(){this.dispose()}_outputCallback(e){this._messageReceived.emit({type:"stdout",content:[e]})}_updateConnectionStatus(e){this._connectionStatus!==e&&(this._connectionStatus=e,this._connectionStatusChanged.emit(e))}}class l extends s.BaseManager{constructor(e={}){super(e),this._connectionFailure=new o.Signal(this),this._isReady=!1,this._runningChanged=new o.Signal(this),this._terminalConnections=new Map,this._ready=(async()=>{this._isReady=!0})()}set browsingContextId(e){console.log("==> LiteTerminalManager browsingContextId",e),this._browsingContextId=e}get connectionFailure(){return this._connectionFailure}connectTo(e){const{model:t}=e,{name:n}=t;console.log("==> LiteTerminalManager.connectTo",n);const{serverSettings:s}=this,i=new c({browsingContextId:this._browsingContextId,model:t,serverSettings:s});return i.disposed.connect((()=>this.shutdown(n))),i}isAvailable(){return!0}get isReady(){return this._isReady}get ready(){return this._ready}async refreshRunning(){this._runningChanged.emit(this._models)}running(){return this._models[Symbol.iterator]()}get runningChanged(){return this._runningChanged}async shutdown(e){const t=this._terminalConnections.get(e);void 0!==t&&(this._terminalConnections.delete(e),t.dispose(),this.refreshRunning())}async shutdownAll(){await Promise.all(this._models.map((e=>this.shutdown(e.name)))),this.refreshRunning()}async startNew(e){var t;const n=null!==(t=e.name)&&void 0!==t?t:this._nextAvailableName(),s={name:n},{serverSettings:i}=this,o=new c({browsingContextId:this._browsingContextId,model:s,serverSettings:i});return o.disposed.connect((()=>this.shutdown(n))),this._terminalConnections.set(n,o),await this.refreshRunning(),o}get _models(){return Array.from(this._terminalConnections,(([e,t])=>({name:e})))}_nextAvailableName(){for(let e=1;;++e){const t=`${e}`;if(!this._terminalConnections.has(t))return t}}}const h=[{id:"@jupyterlite/terminal:plugin",description:"A JupyterLite extension providing a custom terminal manager",autoStart:!0,provides:s.ITerminalManager,activate:e=>(console.log("JupyterLite extension @jupyterlite/terminal:plugin is activated!"),new l)},{id:"@jupyterlite/terminal:browsing-context-id",autoStart:!0,optional:[i.IServiceWorkerManager],requires:[s.ITerminalManager],activate:(e,t,n)=>{if(void 0!==n)if("browsingContextId"in t){const{browsingContextId:e}=n;t.browsingContextId=e}else console.warn("Terminal manager does not support setting browsingContextId")}}]}}]);