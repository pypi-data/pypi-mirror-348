(function(w,g){typeof exports=="object"&&typeof module<"u"?g(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],g):(w=typeof globalThis<"u"?globalThis:w||self,g(w.trame_vtklocal={},w.Vue))})(this,function(w,g){"use strict";const k=[],v={};function E(){let n,e;return{promise:new Promise((t,i)=>{n=t,e=i}),resolve:n,reject:e}}function R(n){return n!=null&&n.Id?n:JSON.parse(n)}function z(n){return n!=null&&n.Id?JSON.stringify(n):n}function j(n,e){return n.rendering===e.rendering&&n.exec===e.exec}function p(n){return(n==null?void 0:n.rendering)==="webgpu"?(console.log("WASM use WebGPU"),{preRun:[function(e){e.ENV.VTK_GRAPHICS_BACKEND="WEBGPU"}]}):(console.log("WASM use WebGL2"),{})}function P(n){return v[n]||(v[n]=new Promise(function(e,s){if(k.indexOf(n)===-1){k.push(n);var t=document.createElement("script");t.type="module",t.src=n,t.onload=e,t.onerror=s,document.body.appendChild(t)}else e(!1)})),v[n]}class N{constructor(){this.loaded=!1,this.loadingPending=null,this.wasm=null,this.config={},this.runtimes=[]}async load(e,s={rendering:"webgl",exec:"sync"}){var t,i;if(this.config=s,!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:c,resolve:h}=E();this.loadingPending=c,((t=this.config)==null?void 0:t.rendering)==="webgpu"&&(this.config.exec="async");let d=null,a=null;if(d=`${e}/vtkWebAssemblyInterface${((i=this.config)==null?void 0:i.exec)==="async"?"Async":""}.mjs`,(await fetch(d)).ok&&(a=d),a||(d=`${e}/vtkWasmSceneManager.mjs`,(await fetch(d)).ok&&(a=d)),!a)throw new Error(`Could not fetch wasm bundle from ${e}`);console.log("WASM use",a),await P(a),window.createVTKWASM&&(this.wasm=await window.createVTKWASM(p(this.config))),this.loaded=!0,h()}}async createRemoteSession(e){var t;if(this.wasm)if((t=this.wasm)!=null&&t.isAsync&&this.wasm.isAsync()){if(!e||j(this.config,e))return console.log("(Main runtime in async)"),new this.wasm.vtkRemoteSession;{console.log("(New in async)");const i=await window.createVTKWASM(p(e||this.config));return new i.vtkRemoteSession}}else{console.log("(New in sync)");const i=await window.createVTKWASM(p(e||this.config));return new i.vtkRemoteSession}const s=await window.createVTKWasmSceneManager();return s.initialize(),s}createStandaloneSession(){if(!this.wasm)throw new Error("Current WASM version does not support standalone mode");return new this.wasm.vtkStandaloneSession}createStateDecorator(){return this.wasm?R:z}}const m={};class O{constructor(){this.sceneManager=null,this.loaded=!1,this.updateInProgress=0,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e,s){m[e]||(m[e]=new N),await m[e].load(e,s),this.sceneManager=await m[e].createRemoteSession(s),this.stateDecorator=m[e].createStateDecorator(),this.loaded=!0,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWin32OpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkCocoaRenderWindow","vtkWebAssemblyOpenGLRenderWindow"].forEach(t=>this.sceneManager.skipProperty(t,"Size")))}bindNetwork(e,s,t){this.networkFetchState=e,this.networkFetchHash=s,this.networkFetchStatus=t}freeMemory(e=0){const s=this.sceneManager.getTotalBlobMemoryUsage(),t=Number(e);if(s>t){const i={};let c=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([h,d])=>{d<c&&(c=d);const a=d.toString();i[a]?i[a].push(h):i[a]=[h]});this.sceneManager.getTotalBlobMemoryUsage()>t;){const h=i[c];if(h)for(let d=0;d<h.length;d++)this.sceneManager.unRegisterBlob(h[d]),delete this.hashesMTime[h[d]];c++}}}async fetchState(e){const s=await this.networkFetchState(e);return this.patchState(s)}patchState(e){var s;if(e.length>0){const t=JSON.parse(e),{Id:i,MTime:c}=t;if(this.stateMTimes[i]=c,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(i)&&((s=t==null?void 0:t.Interactor)!=null&&s.Id))return this.renderWindowIdToInteractorId.set(t.Interactor.Id,i),t.CanvasSelector=this.getCanvasSelector(i),delete t.Size,this.renderWindowSizes[i]&&(t.Size=this.renderWindowSizes[i]),t.ClassName="vtkCocoaRenderWindow",JSON.stringify(t);if(this.renderWindowIdToInteractorId.has(i))return t.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(i)),JSON.stringify(t)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const s=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,s}pushHash(e,s){return this.pendingArrays[e]=new Promise(t=>{s.arrayBuffer?s.arrayBuffer().then(i=>{this.sceneManager.registerBlob(e,new Uint8Array(i)),this.hashesMTime[e]=this.currentMTime,t()}):(this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,t())}),this.pendingArrays[e]}async update(e,s=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const t=await this.networkFetchStatus(e),i=[],c=[],h=t.force_push||[];for(let a=0;a<h.length;a++)delete this.stateMTimes[h[a]];t.ids.forEach(([a,r])=>{(!this.stateMTimes[a]||this.stateMTimes[a]<r)&&c.push(this.fetchState(a))}),t.hashes.forEach(a=>{this.hashesMTime[a]||i.push(this.fetchHash(a)),this.hashesMTime[a]=this.currentMTime}),t.cameras.forEach(a=>this.cameraIds.add(Number(a))),t.ignore_ids.forEach(a=>this.sceneManager.unRegisterState(a)),await Promise.all(i),await Promise.all(Object.values(this.pendingArrays));const d=await Promise.all(c);for(this.currentMTime++;d.length;){const a=d.pop();a&&this.sceneManager.registerState(this.stateDecorator(a))}try{this.sceneManager.updateObjectsFromStates();const[a,r]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,a,r),s&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),this.sceneManager.render(e)}catch(a){console.error("WASM update failed"),console.log(a)}}catch(t){console.error("Error in update",t)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,s=!1){const t=Number(e);return s&&this.stateCache[t]?this.stateCache[t]:(this.sceneManager.updateStateFromObject(t),this.sceneManager.getState(t))}clearStateCache(){this.stateCache={}}getStateValue(e,s=!1){const t=Array.isArray(e)?e:[e];let i=null;for(let c=0;c<t.length;c++){const h=t[c];c===0?i=this.getState(h,s):(i=i[h],i.Id&&(i=this.getState(i.Id,s)))}return i}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,s){const t=this.getCanvasSelector(e);let i=this.offlineCanvasContainer.querySelector(t);return i||(i=document.createElement("canvas"),i.setAttribute("class",t.substring(1)),i.setAttribute("tabindex","0")),s.appendChild(i),t}unbindCanvasToDOM(e){const s=this.getCanvasSelector(e),t=document.querySelector(s);t&&this.offlineCanvasContainer.appendChild(t)}setSize(e,s,t){this.renderWindowSizes[e]=[s,t];const i=this.getCanvasSelector(e),c=document.querySelector(i);c&&(c.width=s,c.height=t,this.sceneManager.setSize(e,s,t),this.sceneManager.render(e))}}const S={};function C(n,e,s){return function(){e.clearStateCache();for(const[t,i]of Object.entries(s)){const c={};for(const[h,d]of Object.entries(i))c[h]=e.getStateValue(d,!0);n.state.set(t,c)}e.clearStateCache()}}const A={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},config:{type:Object,default:()=>({rendering:"webgl",exec:"sync"})},listeners:{type:Object}},setup(n,{emit:e}){n.useHandler&&!S[n.useHandler]&&(S[n.useHandler]=new O);const s=g.inject("trame"),t=s.state.get("__trame_vtklocal_wasm_url"),i=[],c=[],h=g.ref(null),d=n.wsClient||(s==null?void 0:s.client),a=g.toRef(n,"listeners"),r=n.useHandler?S[n.useHandler]:new O;let M=null;async function H(l){return await d.getConnection().getSession().call("vtklocal.get.state",[l])}async function x(l){const u=await d.getConnection().getSession().call("vtklocal.get.hash",[l]);return u.arrayBuffer?new Uint8Array(await u.arrayBuffer()):u}async function D(l){return await d.getConnection().getSession().call("vtklocal.get.status",[l])}function L([l]){l.type==="state"&&r.pushState(l.content),l.type==="blob"&&r.pushHash(l.hash,l.content)}async function F(){const l=d.getConnection().getSession();M=l.subscribe("vtklocal.subscriptions",L),await l.call("vtklocal.subscribe.update",[n.renderWindow,1])}async function _(){const l=d.getConnection().getSession();M&&(l.unsubscribe(M),M=null),await l.call("vtklocal.subscribe.update",[n.renderWindow,-1])}function B(){const{width:l,height:o}=h.value.getBoundingClientRect(),u=Math.floor(l*window.devicePixelRatio+.5),f=Math.floor(o*window.devicePixelRatio+.5);r.setSize(n.renderWindow,u,f)}let b=new ResizeObserver(B);function K(){r.freeMemory(n.cacheSize),e("memory-vtk",r.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",r.sceneManager.getTotalBlobMemoryUsage())}async function I(l=!1){r.loaded&&(await r.update(n.renderWindow,l),e("updated"),K())}function G(l){r.sceneManager.resetCamera(l),r.sceneManager.render(n.renderWindow)}async function q(l,o,u){const f=await r.sceneManager.invoke(l,o,u);return f.Id&&f.Success&&(f.Value=r.getState(f.Id)),e("invoke-response",f),f}function J(){r.sceneManager.printSceneManagerInformation()}g.onMounted(async()=>{r.bindNetwork(H,x,D),r.loaded||await r.load(t,n.config);const l=r.bindCanvasToDOM(n.renderWindow,g.unref(h));g.unref(h).querySelector(l).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),n.eagerSync&&F(),b&&b.observe(g.unref(h)),g.watchEffect(()=>{const o=n.verbosity;o.objectManager&&r.sceneManager.setObjectManagerLogVerbosity&&r.sceneManager.setObjectManagerLogVerbosity(o.objectManager),o.invoker&&r.sceneManager.setInvokerLogVerbosity&&r.sceneManager.setInvokerLogVerbosity(o.invoker),o.deserializer&&r.sceneManager.setDeserializerLogVerbosity&&r.sceneManager.setDeserializerLogVerbosity(o.deserializer),o.serializer&&r.sceneManager.setSerializerLogVerbosity&&r.sceneManager.setSerializerLogVerbosity(o.serializer)}),await I(!0),r.sceneManager.addObserver?r.cameraIds.forEach(o=>{i.push([o,r.sceneManager.addObserver(o,"ModifiedEvent",()=>{e("camera",r.getState(o))})])}):r.cameraIds.forEach(o=>{i.push([o,r.sceneManager.observe(o,"ModifiedEvent",()=>{e("camera",r.getState(o))})])}),g.watchEffect(()=>{if(r.sceneManager.removeObserver){for(;c.length;){const[o,u]=c.pop();r.sceneManager.removeObserver(o,u)}for(const[o,u]of Object.entries(a.value||{})){const f=Number(o);for(const[W,T]of Object.entries(u||{})){const y=C(s,r,T);c.push([f,r.sceneManager.addObserver(f,W,y)]),y()}}}else{for(;c.length;){const[o,u]=c.pop();r.sceneManager.unObserve(o,u)}for(const[o,u]of Object.entries(a.value||{})){const f=Number(o);for(const[W,T]of Object.entries(u||{})){const y=C(s,r,T);c.push([f,r.sceneManager.observe(f,W,y)]),y()}}}}),r.sceneManager.startEventLoop(n.renderWindow)||console.error("Could not startEventLoop for",n.renderWindow)}),g.onBeforeUnmount(()=>{M&&_();const l=r.sceneManager.removeObserver?"removeObserver":"unObserve";for(;i.length;){const[o,u]=i.pop();r.sceneManager[l](o,u)}for(;c.length;){const[o,u]=c.pop();r.sceneManager[l](o,u)}r.sceneManager.stopEventLoop(n.renderWindow),b&&(b.disconnect(),b=null),r.unbindCanvasToDOM(n.renderWindow)});function U(l){C(s,r,l)()}function $(){n.useHandler&&S[n.useHandler]&&delete S[n.useHandler]}return{container:h,update:I,resetCamera:G,evalStateExtract:U,invoke:q,printSceneManagerInformation:J,detachHandler:$}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function V(n){Object.keys(A).forEach(e=>{n.component(e,A[e])})}w.install=V,Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});
