(function(M,g){typeof exports=="object"&&typeof module<"u"?g(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],g):(M=typeof globalThis<"u"?globalThis:M||self,g(M.trame_vtklocal={},M.Vue))})(this,function(M,g){"use strict";const k=[],v={};function A(){let n,e;return{promise:new Promise((t,i)=>{n=t,e=i}),resolve:n,reject:e}}function R(n){return n!=null&&n.Id?n:JSON.parse(n)}function z(n){return n!=null&&n.Id?JSON.stringify(n):n}function j(n,e){return n.rendering===e.rendering&&n.exec===e.exec}function p(n){return(n==null?void 0:n.rendering)==="webgpu"?(console.log("WASM use WebGPU"),{preRun:[function(e){e.ENV.VTK_GRAPHICS_BACKEND="WEBGPU"}]}):(console.log("WASM use WebGL2"),{})}function P(n){return v[n]||(v[n]=new Promise(function(e,r){if(k.indexOf(n)===-1){k.push(n);var t=document.createElement("script");t.type="module",t.src=n,t.onload=e,t.onerror=r,document.body.appendChild(t)}else e(!1)})),v[n]}class V{constructor(){this.loaded=!1,this.loadingPending=null,this.wasm=null,this.config={},this.runtimes=[]}async load(e,r={rendering:"webgl",exec:"sync"}){var t,i;if(this.config=r,!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:c,resolve:h}=A();if(this.loadingPending=c,((t=this.config)==null?void 0:t.rendering)==="webgpu"&&(this.config.exec="async"),!window.createVTKWASM){let d=null;document.querySelectorAll("script").forEach(a=>{if(a.src.includes("vtkWebAssemblyInterface")){const{promise:s,resolve:w}=A();a.onload=w,d=s}}),d&&await d}if(!window.createVTKWASM){let d=null,a=null;if(d=`${e}/vtkWebAssemblyInterface${((i=this.config)==null?void 0:i.exec)==="async"?"Async":""}.mjs`,(await fetch(d)).ok&&(a=d),a||(d=`${e}/vtkWasmSceneManager.mjs`,(await fetch(d)).ok&&(a=d)),!a)throw new Error(`Could not fetch wasm bundle from ${e}`);console.log("WASM use",a),await P(a)}window.createVTKWASM&&(this.wasm=await window.createVTKWASM(p(this.config))),this.loaded=!0,h()}}async createRemoteSession(e){var t;if(this.wasm)if((t=this.wasm)!=null&&t.isAsync&&this.wasm.isAsync()){if(!e||j(this.config,e))return console.log("(Main runtime in async)"),new this.wasm.vtkRemoteSession;{console.log("(New in async)");const i=await window.createVTKWASM(p(e||this.config));return new i.vtkRemoteSession}}else{console.log("(New in sync)");const i=await window.createVTKWASM(p(e||this.config));return new i.vtkRemoteSession}const r=await window.createVTKWasmSceneManager();return r.initialize(),r}createStandaloneSession(){if(!this.wasm)throw new Error("Current WASM version does not support standalone mode");return new this.wasm.vtkStandaloneSession}createStateDecorator(){return this.wasm?R:z}}const m={};class O{constructor(){this.sceneManager=null,this.loaded=!1,this.updateInProgress=0,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e,r){m[e]||(m[e]=new V),await m[e].load(e,r),this.sceneManager=await m[e].createRemoteSession(r),this.stateDecorator=m[e].createStateDecorator(),this.loaded=!0,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWin32OpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkCocoaRenderWindow","vtkWebAssemblyOpenGLRenderWindow"].forEach(t=>this.sceneManager.skipProperty(t,"Size")))}bindNetwork(e,r,t){this.networkFetchState=e,this.networkFetchHash=r,this.networkFetchStatus=t}freeMemory(e=0){const r=this.sceneManager.getTotalBlobMemoryUsage(),t=Number(e);if(r>t){const i={};let c=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([h,d])=>{d<c&&(c=d);const a=d.toString();i[a]?i[a].push(h):i[a]=[h]});this.sceneManager.getTotalBlobMemoryUsage()>t;){const h=i[c];if(h)for(let d=0;d<h.length;d++)this.sceneManager.unRegisterBlob(h[d]),delete this.hashesMTime[h[d]];c++}}}async fetchState(e){const r=await this.networkFetchState(e);return this.patchState(r)}patchState(e){var r;if(e.length>0){const t=JSON.parse(e),{Id:i,MTime:c}=t;if(this.stateMTimes[i]=c,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(i)&&((r=t==null?void 0:t.Interactor)!=null&&r.Id))return this.renderWindowIdToInteractorId.set(t.Interactor.Id,i),t.CanvasSelector=this.getCanvasSelector(i),delete t.Size,this.renderWindowSizes[i]&&(t.Size=this.renderWindowSizes[i]),t.ClassName="vtkCocoaRenderWindow",JSON.stringify(t);if(this.renderWindowIdToInteractorId.has(i))return t.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(i)),JSON.stringify(t)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const r=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,r),this.hashesMTime[e]=this.currentMTime,r}pushHash(e,r){return this.pendingArrays[e]=new Promise(t=>{r.arrayBuffer?r.arrayBuffer().then(i=>{this.sceneManager.registerBlob(e,new Uint8Array(i)),this.hashesMTime[e]=this.currentMTime,t()}):(this.sceneManager.registerBlob(e,r),this.hashesMTime[e]=this.currentMTime,t())}),this.pendingArrays[e]}async update(e,r=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const t=await this.networkFetchStatus(e),i=[],c=[],h=t.force_push||[];for(let a=0;a<h.length;a++)delete this.stateMTimes[h[a]];t.ids.forEach(([a,s])=>{(!this.stateMTimes[a]||this.stateMTimes[a]<s)&&c.push(this.fetchState(a))}),t.hashes.forEach(a=>{this.hashesMTime[a]||i.push(this.fetchHash(a)),this.hashesMTime[a]=this.currentMTime}),t.cameras.forEach(a=>this.cameraIds.add(Number(a))),t.ignore_ids.forEach(a=>this.sceneManager.unRegisterState(a)),await Promise.all(i),await Promise.all(Object.values(this.pendingArrays));const d=await Promise.all(c);for(this.currentMTime++;d.length;){const a=d.pop();a&&this.sceneManager.registerState(this.stateDecorator(a))}try{this.sceneManager.updateObjectsFromStates();const[a,s]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,a,s),r&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),await this.sceneManager.render(e)}catch(a){console.error("WASM update failed"),console.log(a)}}catch(t){console.error("Error in update",t)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,r=!1){const t=Number(e);return r&&this.stateCache[t]?this.stateCache[t]:(this.sceneManager.updateStateFromObject(t),this.sceneManager.getState(t))}clearStateCache(){this.stateCache={}}getStateValue(e,r=!1){const t=Array.isArray(e)?e:[e];let i=null;for(let c=0;c<t.length;c++){const h=t[c];c===0?i=this.getState(h,r):(i=i[h],i.Id&&(i=this.getState(i.Id,r)))}return i}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,r){const t=this.getCanvasSelector(e);let i=this.offlineCanvasContainer.querySelector(t);return i||(i=document.createElement("canvas"),i.setAttribute("class",t.substring(1)),i.setAttribute("tabindex","0")),r.appendChild(i),t}unbindCanvasToDOM(e){const r=this.getCanvasSelector(e),t=document.querySelector(r);t&&this.offlineCanvasContainer.appendChild(t)}async setSize(e,r,t){this.renderWindowSizes[e]=[r,t];const i=this.getCanvasSelector(e),c=document.querySelector(i);c&&(c.width=r,c.height=t,this.sceneManager.setSize(e,r,t),await this.sceneManager.render(e))}}const S={};function W(n,e,r){return function(){e.clearStateCache();for(const[t,i]of Object.entries(r)){const c={};for(const[h,d]of Object.entries(i))c[h]=e.getStateValue(d,!0);n.state.set(t,c)}e.clearStateCache()}}const I={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},config:{type:Object,default:()=>({rendering:"webgl",exec:"sync"})},listeners:{type:Object}},setup(n,{emit:e}){n.useHandler&&!S[n.useHandler]&&(S[n.useHandler]=new O);const r=g.inject("trame"),t=r.state.get("__trame_vtklocal_wasm_url"),i=[],c=[],h=g.ref(null),d=n.wsClient||(r==null?void 0:r.client),a=g.toRef(n,"listeners"),s=n.useHandler?S[n.useHandler]:new O;let w=null;async function H(l){return await d.getConnection().getSession().call("vtklocal.get.state",[l])}async function L(l){const u=await d.getConnection().getSession().call("vtklocal.get.hash",[l]);return u.arrayBuffer?new Uint8Array(await u.arrayBuffer()):u}async function x(l){return await d.getConnection().getSession().call("vtklocal.get.status",[l])}function D([l]){l.type==="state"&&s.pushState(l.content),l.type==="blob"&&s.pushHash(l.hash,l.content)}async function F(){const l=d.getConnection().getSession();w=l.subscribe("vtklocal.subscriptions",D),await l.call("vtklocal.subscribe.update",[n.renderWindow,1])}async function _(){const l=d.getConnection().getSession();w&&(l.unsubscribe(w),w=null),await l.call("vtklocal.subscribe.update",[n.renderWindow,-1])}async function K(){const{width:l,height:o}=h.value.getBoundingClientRect(),u=Math.floor(l*window.devicePixelRatio+.5),f=Math.floor(o*window.devicePixelRatio+.5);await s.setSize(n.renderWindow,u,f)}let b=new ResizeObserver(K);function B(){s.freeMemory(n.cacheSize),e("memory-vtk",s.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",s.sceneManager.getTotalBlobMemoryUsage())}async function E(l=!1){s.loaded&&(await s.update(n.renderWindow,l),e("updated"),B())}function G(l){s.sceneManager.resetCamera(l),s.sceneManager.render(n.renderWindow)}async function q(l,o,u){const f=await s.sceneManager.invoke(l,o,u);return f.Id&&f.Success&&(f.Value=s.getState(f.Id)),e("invoke-response",f),f}function J(){s.sceneManager.printSceneManagerInformation()}g.onMounted(async()=>{s.bindNetwork(H,L,x),s.loaded||await s.load(t,n.config);const l=s.bindCanvasToDOM(n.renderWindow,g.unref(h));g.unref(h).querySelector(l).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),n.eagerSync&&F(),b&&b.observe(g.unref(h)),g.watchEffect(()=>{const o=n.verbosity;o.objectManager&&s.sceneManager.setObjectManagerLogVerbosity&&s.sceneManager.setObjectManagerLogVerbosity(o.objectManager),o.invoker&&s.sceneManager.setInvokerLogVerbosity&&s.sceneManager.setInvokerLogVerbosity(o.invoker),o.deserializer&&s.sceneManager.setDeserializerLogVerbosity&&s.sceneManager.setDeserializerLogVerbosity(o.deserializer),o.serializer&&s.sceneManager.setSerializerLogVerbosity&&s.sceneManager.setSerializerLogVerbosity(o.serializer)}),await E(!0),s.sceneManager.addObserver?s.cameraIds.forEach(o=>{i.push([o,s.sceneManager.addObserver(o,"ModifiedEvent",()=>{e("camera",s.getState(o))})])}):s.cameraIds.forEach(o=>{i.push([o,s.sceneManager.observe(o,"ModifiedEvent",()=>{e("camera",s.getState(o))})])}),g.watchEffect(()=>{if(s.sceneManager.removeObserver){for(;c.length;){const[o,u]=c.pop();s.sceneManager.removeObserver(o,u)}for(const[o,u]of Object.entries(a.value||{})){const f=Number(o);for(const[C,T]of Object.entries(u||{})){const y=W(r,s,T);c.push([f,s.sceneManager.addObserver(f,C,y)]),y()}}}else{for(;c.length;){const[o,u]=c.pop();s.sceneManager.unObserve(o,u)}for(const[o,u]of Object.entries(a.value||{})){const f=Number(o);for(const[C,T]of Object.entries(u||{})){const y=W(r,s,T);c.push([f,s.sceneManager.observe(f,C,y)]),y()}}}}),s.sceneManager.startEventLoop(n.renderWindow)||console.error("Could not startEventLoop for",n.renderWindow)}),g.onBeforeUnmount(()=>{w&&_();const l=s.sceneManager.removeObserver?"removeObserver":"unObserve";for(;i.length;){const[o,u]=i.pop();s.sceneManager[l](o,u)}for(;c.length;){const[o,u]=c.pop();s.sceneManager[l](o,u)}s.sceneManager.stopEventLoop(n.renderWindow),b&&(b.disconnect(),b=null),s.unbindCanvasToDOM(n.renderWindow)});function U(l){W(r,s,l)()}function $(){n.useHandler&&S[n.useHandler]&&delete S[n.useHandler]}return{container:h,update:E,resetCamera:G,evalStateExtract:U,invoke:q,printSceneManagerInformation:J,detachHandler:$}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function N(n){Object.keys(I).forEach(e=>{n.component(e,I[e])})}M.install=N,Object.defineProperty(M,Symbol.toStringTag,{value:"Module"})});
