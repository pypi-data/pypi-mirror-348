###############################################################################
### lmp.input

# Johannes Hoermann, johannes.hoermann@imtek.uni-freiburg.de, 2019, 2020

###############################################################################
### global parameters

# index varibles can be overridden by command line parameters "-v varName value"

{#- guideline: variable accessed from both jinja2 and LAMMPS should be given a default here #}
{#- guideline: they should then not have a default in the LAMMPS variable definitions below #}
{#- guideline: if they need not to be accessed in jinja2 logic, then they need not appear here #}
{#- guideline: variables only accessed by jinja should appear in the comments section below #}

{#- switches: generic #}
{%- set read_datafile=read_datafile|default(true) %} {# do not read data file if 0 #}
{%- set read_groups_from_file=read_groups_from_file|default(false) %}
{%- set compute_interactions=compute_interactions|default(false) %} {# group-goup interactions to thermo_out #}
{%- set compute_group_properties=compute_group_properties|default(false) %} {# # compute and output distinct temperatures and pressures for components of the system #}
{%- set mpiio=mpiio|default(true) %} {# parallel io on or off #}
{%- set store_forces=store_forces|default(true) %} {# store constrained AND unconstrained forces in NetcDF #}
{%- set thermo_to_netcdf=thermo_to_netcdf|default(false) %} {# if 1, puts thermo output to netcdf as well. Causes segmentation faults for variables in custom thermo style #}
{%- set write_coeff=write_coeff|default(true) %}{# write force field parameters to independent file #}
{%- set write_coeff_to_datafile=write_coeff_to_datafile|default(false) %} {## write force filed parameters to system datafile #}
{%- set write_groups_to_file=write_groups_to_file|default(true) %}
{%- set verbose=verbose|default(false) %} {# log detailed system info at differents stages of input script #}
{%- set freeze_substrate=freeze_substrate|default(false) %} {# keep substrate frozen (during minim) #}
{%- set neigh_check=neigh_check|default(true) %}
{%- set exclude_frozen_interactions=exclude_frozen_interactions|default(false) %} {# do not compute interactions between frozen atoms #}
{%- set rigid_h_bonds=rigid_h_bonds|default(true) %} {# apply SHAPE or RATTLE to H #}
{%- set shift_system_with_box=shift_system_with_box|default(false) %} {# if box shift desired, then shift atoms together with box #}
{%- set use_eam=use_eam|default(false) %} {# use pairstyle eam for solid #}
{%- set use_ewald=use_ewald|default(true) %} {# switch ewald sum (kspace solver) #}

{#- switches: minimization-relatedt #}
{%- set robust_minimization=robust_minimization|default(false) %} {# this can be useful if a very dense initial packing would result into substrate deformation otherwise #}
{%- set relax_box=relax_box|default(false) %} {# relax box tor specified pressureP in minimization #}

{#- thermostat-related #}
{%- set temper_solid_only=temper_solid_only|default(true) %} {# if false, everything (except frozen atoms) is tempered #}
{%- set temper_substrate_only=temper_substrate_only|default(false) %} {# if true, only substrate is tempered (for Langevin only, DPD always tempers all solid)} #}

{#- barostat-related #}
{%- set use_dpd_tstat=use_dpd_tstat|default(false) %} {# temperizes all solid atoms
                                                # with dpd thermostat (instead
                                                # of Langevin) #}
{%- set dilate_solution_only=dilate_solution_only|default(true) %} {# if true, only solution (i.e.
                                                # non-solid, non-frozen) atoms
                                                # are rescaled with a change of
                                                # volume #}
{%- set pressurize_z_only=pressurize_z_only|default(false) %} {# if true, barostats are applied in z direction only #}
{%- set pressurize_solution_only=pressurize_solution_only|default(false) %} {# if false, pressurizes all non-frozen atoms, otherwise only liquid #}
{%- set use_barostat=use_barostat|default(true) %} {# if false, run NVT instead of NPT or NVE instead of NPH #}
{%- set use_berendsen_bstat=use_berendsen_bstat|default(false) %} {# use Berenden instead of Parrinelol-Rahman barostat (i.e. for NPT equilibration) #}

{%- set add_vacuum=add_vacuum|default(false) %} {# adds vacuum of specified thickness in z-direction #}
{%- set is_restart=is_restart|default(false) %} {# marks current run as restart #}
{%- set has_vacuum=has_vacuum|default(false) %} {# z-direction not pressurized #}
{%- set pbc2d=pbc2d|default(false) %} {# false: 3d periodic, true: 2d periodic #}
{%- set reinitialize_velocities=reinitialize_velocities|default(false) %}
{%- set remove_drift=remove_drift|default(false) %} {# remove substrate COM movement #}
{%- set shrink_wrap_once=shrink_wrap_once|default(false) %} {# shrinks simulation box around system once after reading data #}
{%- set substrate_recenter=substrate_recenter|default(false) %} {# same as remove drift #}

{#- AFM-tip related #}
{%- set has_indenter=has_indenter|default(false) %}
{%- set rigid_indenter=rigid_indenter|default(false) %} {# treat whole indenter as rigid #}
{%- set restrained_indenter=restrained_indenter|default(false) %} {# do not treat indenter as rigid but remove total linear and angular momentum #}

{%- set constant_indenter_velocity=constant_indenter_velocity|default(0.0)|float %}
{%- set direction_of_linear_movement=direction_of_linear_movement|default(2)|int %}  {# 0,1,2 for x,y,z of ind. mov. #}
{%- set indenter_nve_noforce=indenter_nve_noforce|default(false) %} {# use 'fix nve/noforce' instead of 'fix setforce' to treat indenter as rigid #}
{%- set manual_indenter_region=manual_indenter_region|default(false) %} {# if set to 1 use measures below #}

{#- non-boolean #}
{%- set mode=mode|default("production") %}
{%- set box_shift_z=box_shift_z|default(0.0, false)|float %}
{%- set comm_cutoff=comm_cutoff|default(0.0, false)|float %} {# if 0.0, then not specified in input script #}
{%- set freeze_substrate_layer=freeze_substrate_layer|default(0.0, false)|float %}
{%- set restrain_substrate_layer=restrain_substrate_layer|default(0.0, false)|float %}
{%- set rigid_indenter_core_radius=rigid_indenter_core_radius|default(0.0, false)|float %} {# only treatthe indenter core as rigid #}
{%- set thermo_frequency=thermo_frequency|default(1000, false)|int %}
{%- set thermo_average_frequency=thermo_average_frequency|default(thermo_frequency) %}

{%- set solvent_types=solvent_types|default([8,9]) %}
{%- set counterion_type=counterion_type|default(10) %}
{%- set substrate_type=substrate_type|default(11) %}

{%- set solvent_angle=solvent_angle|default(11) %}

# template-level options
#     mode = {{ mode }}
#     read_datafile = {{ read_datafile }}
#     read_groups_from_file = {{ read_groups_from_file }}
#     compute_interactions = {{ compute_interactions }}
#     compute_group_properties = {{ compute_group_properties }}
#     mpiio = {{ mpiio }}
#     store_forces = {{ store_forces }}
#     thermo_to_netcdf = {{ thermo_to_netcdf }}
#     write_coeff = {{ write_coeff }}
#     write_coeff_to_datafile = {{ write_coeff_to_datafile }}
#     write_groups_to_file = {{ write_groups_to_file }}
#     verbose = {{ verbose }}
#     freeze_substrate = {{ freeze_substrate }}
#     neigh_check = {{ neigh_check }}
#     exclude_frozen_interactions = {{ exclude_frozen_interactions }}
#     rigid_h_bonds = {{ rigid_h_bonds }}
#     shift_system_with_box = {{ shift_system_with_box }}
#     use_eam = {{ use_eam }}
#     use_ewald = {{ use_ewald }}
#
# switches: minimization-related
#     robust_minimization = {{ robust_minimization }}
#     relax_box = {{ relax_box }}
#
# thermostat-related
#     temper_solid_only = {{ temper_solid_only }}
#     temper_substrate_only = {{ temper_substrate_only }}
#
# barostat-related
#     use_dpd_tstat = {{ use_dpd_tstat }}
#     dilate_solution_only = {{ dilate_solution_only }}
#     pressurize_z_only = {{ pressurize_z_only }}
#     pressurize_solution_only = {{ pressurize_solution_only }}
#     use_barostat = {{ use_barostat }}
#     use_berendsen_bstat = {{ use_berendsen_bstat }}
#
#     add_vacuum = {{ add_vacuum }}
#     is_restart = {{ is_restart }}
#     has_vacuum = {{ has_vacuum }}
#     pbc2d = {{ pbc2d }}
#     reinitialize_velocities = {{ reinitialize_velocities }}
#     remove_drift = {{ remove_drift }}
#     shrink_wrap_once = {{ shrink_wrap_once }}
#     substrate_recenter = {{ substrate_recenter }}
#
# AFM-tip related
#     has_indenter = {{ has_indenter }}
#     rigid_indenter = {{ rigid_indenter }}
#     restrained_indenter = {{ restrained_indenter }}
#
#     indenter_nve_noforce = {{ indenter_nve_noforce }}
#     manual_indenter_region = {{ manual_indenter_region }}

# non-boolean
#     box_shift_z = {{ box_shift_z }}
#     comm_cutoff = {{ comm_cutoff }}
#     freeze_substrate_layer = {{ freeze_substrate_layer }}
#     restrain_substrate_layer = {{ restrain_substrate_layer }}
#     rigid_indenter_core_radius = {{ rigid_indenter_core_radius }}
#     thermo_frequency = {{ thermo_frequency }}
#     thermo_average_frequency = {{ thermo_average_frequency }}
#
# types and topology
#     solvent_types = {{ solvent_types }}
#     counterion_type = {{ counterion_type }}
#     substrate_type = {{ substrate_type }}
#
#     solvent_angle = {{ solvent_angle }}

# name of restart file dpends on whether mpiio is used or not
{%- if not is_restart is sameas true %}
print 'Initial run on system'
{%- elif not mpiio is sameas true %}
variable restart_file index default.restart
{%- else %}
variable restart_file index default.mpiio.restart
# in the last case, run is restart and mpiio is used
{%- endif %}

{%- if is_restart is sameas true %}
# In case of a restart, group definitions are not repeated and no datafile is read.
# All other settings are explicitly redefined even if not necessary.
read_restart ${restart_file}
{%- if verbose is sameas true %}
print "Force field parameters from restart file:"
info coeffs out screen
info coeffs out log
print "Computes from restart file:"
info computes out screen
info computes out log
print "Fixes from restart file:"
info fixes out screen
info fixes out log
print "Groups from restart file:"
info groups out screen
info groups out log
print "Regions from restart file:"
info regions out screen
info regions out log
print "System info from restart file:"
info system out screen
info system out log
print "Variables from restart file:"
info variables out screen
info variables out log
{%- endif %}
{%- endif %}

###############################################################################
### lmp_header.input

# input settings
variable base_name               index  {{ base_name|default("default", true) }}
variable coeff_infile            index  {{ coeff_infile|default("coeff_dummy.input", true) }}  # file to read ff parameters
variable pair_coeff_infile       index  {{ pair_coeff_infile|default("pair_coeff_dummy.input", true) }}  # allow to read non-bonded ...
variable bonded_coeff_infile     index  {{ bonded_coeff_infile|default("bonded_coeff_dummy.input", true) }}  # ... and bonded coeffs from different files
variable colvars_file            index  {{ colvars_file|default("colvars.inp", true) }}
variable data_file               index  {{ data_file|default("datafile.lammps", true) }}
variable eam_alloy_file          index  {{ eam_alloy_file|default("default.eam.alloy", true) }}

# output settings
variable coeff_outfile           index  {{ coeff_outfile|default("coeff.input.transient", true) }} # file to store ff parameters
variable netcdf_frequency        index  {{ netcdf_frequency|default(1000, false)|int }}
variable png_frequency           index  {{ png_frequency|default(100000, false)|int }}
variable restart_frequency       index  {{ restart_frequency|default(100000, false)|int }}
variable thermo_frequency        index  {{ thermo_frequency }} # outputs stats at single time step
variable thermo_average_frequency index ${thermo_frequency} # outputs stats averaged over N timesteps. 0: disabled
variable ndx_file                index  {{ ndx_file|default("groups.ndx", true) }}

# minimization-related settings:
variable minimization_maxiter    index  {{ minimization_maxiter|default(100000, false)|int }}
variable minimization_maxeval    index  {{ minimization_maxeval|default(1000000, false)|int }}
variable minimization_ftol       index  {{ minimization_ftol|default(0.00001, false)|float }}  {# Jinja2 supports scientific notation only >= 2.11 #}

# neighbour list settings
variable skin_distance           index  {{ skin_distance|default(2.0, false)|float }}  # skin distance for neighbour list
variable neigh_delay             index  {{ neigh_delay|default(2, false)|int }}
variable neigh_every             index  {{ neigh_every|default(1, false)|int }}
variable neigh_page              index  {{ neigh_page|default(100000, false)|int }}
variable neigh_one               index  {{ neigh_one|default(2000, false)|int }}
variable comm_cutoff             index  {{ comm_cutoff|default(0.0, false)|float }}

# force field settings

## CHARMM-related:
variable inner_cutoff            index  {{ inner_cutoff|default(8.0, false)|float }}     # CHARMM standard
variable outer_cutoff            index  {{ outer_cutoff|default(12.0, false)|float }}    # CHARMM standard
variable coulomb_cutoff          index  {{ coulomb_cutoff|default(12.0, false)|float }}    # Coulomb cutoff

## Ewald summation settings:
variable ewald_accuracy          index  {{ ewald_accuracy|default(0.0001, false)|float }} # relative RMS

# thermostat-related

## Langevin thermostat related:
variable langevin_damping        index  {{ langevin_damping|default(100, false)|int }}     # fs, damping parameter for
                                                # Langevin thermostat
                                                # 100 fs seem harsh, but
                                                # usually used for equilibration
                                                # purposes only

## DPD thermostat related:
variable dpd_cutoff              index  {{ dpd_cutoff|default(5.5, false)|float }}     # Ang, matches EAM cutoff by
                                                # Au-Grochola-JCP05
variable dpd_damping_parameter   index  {{ dpd_damping_parameter|default(461.21, false)|float }}  # kcal fs mol^-1 Ang^-2,
                                                # converted from metal units
                                                # 0.02 eV ps Ang^-2 (conversion
                                                # factor 23.06*1000)
# barostat-related

variable barostat_damping        index  {{ barostat_damping|default(1000, false)|int }}    # fs, damping parameter for
                                                # Parrinello-Rahman barostat
# other technical settings:
variable box_shift_z             index  {{ box_shift_z }}     # shift box once in negative
                                                # direction by this distance
variable freeze_substrate_layer  index  {{ freeze_substrate_layer }}     # if > 0, a substrate layer of
                                                # the specified thickness is
                                                # frozen at the bottom box
                                                # boundary
variable restrain_substrate_layer index  {{ restrain_substrate_layer }}    # if > 0, a substrate layer of
                                                # the specified thickness is
                                                # frozen at the bottom box
                                                # boundary
variable random_seed             index  {{ random_seed|default(range(0,900000000)|random, false)|int }} # global random seed
# The initial seed for this random number generator must be a positive integer less than or equal to 900 million,
# otherwise will rise "Invalid seed for Marsaglia random # generator".
variable timestep                index  {{ timestep|default(2, false)|float }}       # fs

# variable use_colvars             index  0

# system settings
# variable surfactant_name         index  SDS     # SDS or CTAB
variable temperatureT            index  {{ temperatureT|default(298, false)|float }}     # K
variable initialT                index  {{ initialT|default(temperatureT, false)|default(298, false)|float }}  # for ramped temp.
variable pressureP               index  {{ pressureP|default(1, false)|float }}       # atm

variable production_steps         index  {{ production_steps|default(5000000, false)|int }} #  10 ns

# AFM-tip-related settings:
variable rigid_indenter_core_radius index {{ rigid_indenter_core_radius }}   # treat indenter core around COM
                                                # of this radius as rigid
variable constant_indenter_velocity index {{ constant_indenter_velocity }}   # for approach towards substrate
variable direction_of_linear_movement index {{ direction_of_linear_movement }}   # 0,1,2 for x,y,z of ind. mov.
variable indenter_substrate_dist    index {{ indenter_substrate_dist|default(30.0, false)|float }}  # Ang, default distance
                                                # subst. surf. - indenter apex
variable substrate_thickness        index {{ substrate_thickness|default(14.0, false)|float }}  # Ang
variable indenter_height            index {{ indenter_height|default(45.0, false)|float }}  # Ang
variable region_tolerance           index {{ region_tolerance|default(5.0, false)|float }}   # Ang

# the standard TIP3P water model requires not only hydrogen bonds to be rigid,
# but also the HOH angle. Here we set the ID of this angle.
# Look it up within the data file. Usually 11 for SDS, 16 for CTAB

variable angle_id_water index {{ solvent_angle }}
# if "${surfactant_name} == SDS" then &
#   "variable angleIdWater   index     11" &
# else &
#   "variable angleIdWater   index     16"

# per default substrate is gold and assumed to be type 11
variable substrate_type index {{ substrate_type }}

###############################################################################
### system initialization
{%- if (pbc2d is sameas true) %}
boundary p p f
{%- endif %}

{%- if (not is_restart is sameas true) %}
# units command must not appear if reading restart file, otherwise LAMMPS will fail with
#   ERROR: Units command after simulation box is defined (src/input.cpp:1906)

units real
# http://lammps.sandia.gov/doc/units.html
    #mass = grams/mole
    #distance = Angstroms
    #time = femtoseconds
    #energy = Kcal/mole
    #velocity = Angstroms/femtosecond
    #force = Kcal/mole-Angstrom, compared to gmx: kJ mol^-1 nm^-1,
      # conversion F_lmp = F_gmx * 0.1 [nm/Ang] / 4.184 [kJ/kcal] ~ gmx / 41.81
      # 1000 kJ / (mol*nm) ~ 25 kCal/(mol*Ang)
    #torque = Kcal/mole
    #temperature = Kelvin
    #pressure = atmospheres, 1 atm = 1013 hPa ~ 100 kPa
    #dynamic viscosity = Poise
    #charge = multiple of electron charge (1.0 is a proton)
    #dipole = charge*Angstroms
    #electric field = volts/Angstrom
    #density = gram/cm^dim
{%- endif %}

neighbor ${skin_distance} bin
# The style value selects what algorithm is used to build the list. The bin
# style creates the list by binning which is an operation that scales linearly
# with N/P, the number of atoms per processor where N = total number of atoms
# and P = number of processors. It is almost always faster than the nsq style
# which scales as (N/P)^2. For unsolvated small molecules in a non-periodic
# box, the nsq choice can sometimes be faster. Either style should give the
# same answers.
# Defaults: 2.0 bin for units = real or metal, skin = 2.0 Angstroms


{%- if neigh_check is sameas true %}
neigh_modify delay ${neigh_delay} every ${neigh_every} check yes &
    page ${neigh_page} one ${neigh_one}
{%- else %}}
neigh_modify delay ${neigh_delay} every ${neigh_every} check no &
    page ${neigh_page} one ${neigh_one}
{%- endif %}
# This command sets parameters that affect the building and use of pairwise
# neighbor lists. Depending on what pair interactions and other commands
# are defined, a simulation may require one or more neighbor lists.

# Note on possible error:
# Out of range atoms - cannot compute PPPM
#    One or more atoms are attempting to map their charge to a PPPM grid point
#    that is not owned by a processor. This is likely for one of two reasons,
#    both of them bad. First, it may mean that an atom near the boundary of a
#    processor's sub-domain has moved more than 1/2 the neighbor skin distance
#    without neighbor lists being rebuilt and atoms being migrated to new
#    processors. This also means you may be missing pairwise interactions that
#    need to be computed. The solution is to change the re-neighboring criteria
#    via the neigh_modify command. The safest settings are "delay 0 every 1
#    check yes". Second, it may mean that an atom has moved far outside a
#    processor's sub-domain or even the entire simulation box. This indicates
#    bad physics, e.g. due to highly overlapping atoms, too large a timestep,
#    etc.

###############################################################################
### CHARMM potential specific styles

{%- if (not is_restart is sameas true) %}
# in case of reading a restart file above, styles must not be redefined,
# otherwise LAMMPS fails with
#  ERROR: Atom_style command after simulation box is defined (src/input.cpp:1324)
atom_style      full
# Other styles below are allowed to be redefined.
{%- endif %}

bond_style      harmonic

angle_style     charmm
# Source: http://lammps.sandia.gov/doc/angle_charmm.html
# angle potential E = K * ( theta - theta_0)^2 + K_UB * ( r - r_UB )^2

dihedral_style  charmmfsw
# Source: http://lammps.sandia.gov/doc/dihedral_charmm.html
# dihedral potential E = K * [ 1 + cos( n*phi - d ) ]
#
# (MacKerell) MacKerell, Bashford, Bellott, Dunbrack, Evanseck, Field, Fischer,
#             Gao, Guo, Ha, et al, J Phys Chem B, 102, 3586 (1998).

improper_style  harmonic

###############################################################################
### hybrid potential style descriptions

### without EAM

{%- if (not use_eam is sameas true) and (use_ewald is sameas true) and (use_dpd_tstat is sameas true) %}
pair_style hybrid/overlay &
    lj/charmmfsw/coul/long ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff} &
    dpd/tstat ${temperatureT} ${temperatureT} ${dpd_cutoff} ${random_seed}
{%- elif (not use_eam is sameas true) and (use_dpd_tstat is sameas true) %}
pair_style hybrid/overlay &
    lj/charmmfsw/coul/charmmfsh ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff} &
    dpd/tstat ${temperatureT} ${temperatureT} ${dpd_cutoff} ${random_seed}
{%- elif (not use_eam is sameas true) and (use_ewald is sameas true) %}
pair_style lj/charmmfsw/coul/long ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff}
{%- elif (not use_eam is sameas true) %}
pair_style lj/charmmfsw/coul/charmmfsh ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff}
{%- endif %}

# Quote from http://lammps.sandia.gov/doc/pair_charmm.html
# The newer styles with charmmfsw or charmmfsh in their name replace the
# energy switching with force switching (fsw) and force shifting (fsh)
# functions, for LJ and Coulombic interactions respectively. These follow the
# formulas and description given in (Steinbach) and (Brooks) to minimize these
# artifacts.
#
# (Steinbach) Steinbach, Brooks, J Comput Chem, 15, 667 (1994).
# (Brooks)    Brooks, et al, J Comput Chem, 30, 1545 (2009).

# The newest CHARMM pair styles reset the Coulombic energy conversion factor
# used internally in the code, from the LAMMPS value to the CHARMM value, as
# if it were effectively a parameter of the force field. This is because the
# CHARMM code uses a slightly different value for the this conversion factor
# in real units (Kcal/mole), namely CHARMM = 332.0716, LAMMPS = 332.06371.
# This is to enable more precise agreement by LAMMPS with the CHARMM force
# field energies and forces, when using one of these two CHARMM pair styles.

# #
# Storm, S., Jakobtorweihen, S., Smirnova, I., Panagiotopoulos, A.Z., 2013.
# Molecular dynamics simulation of SDS and CTAB micellization and prediction
# of partition equilibria with COSMOmic. Langmuir 29, 11582-11592.
#
# recommend an 8 Ang inner cutoff:
#
# "Recently, Piggot el al. compared different force fields for lipids. Although
# "their recommendations for CHARMM36 force field (CHARMM TIP3P water model,
# "0.8 nm Lennard-Jones switching) are based on bilayer simulations, they were
# "followed here
#
# #
# http://www.gromacs.org/Documentation/Terminology/Force_Fields/CHARMM
#
# notes
#
# Please also note that the switching distance is a matter of some debate in
# lipid bilayer simulations, and it is dependent to some extent on the nature
# of the lipid. Some studies have found that an 0.8-1.0 nm switch is
# appropriate, others argue 0.8-1.2 nm is best, and yet others stand by
# 1.0-1.2 nm. The user is cautioned to thoroughly investigate the force field
# literature for their chosen lipid(s) before beginning a simulation!
#
# #
# https://www.charmmtutorial.org/index.php/The_Energy_Function#Suggested_Nonbond_cutoff_scheme
#
# Suggested Nonbond cutoff scheme
#
# In general, it is a good idea to go with the nonbond cutoff scheme given in
# the parameter file of the force field that you will be using. For example,
# the CHARMM27 Protein/Nucleic acid force field gives default nonbond
#  parameters of:
#
# NONBONDED nbxmod  5 atom cdiel shift -
#  vatom vdistance vswitch -
#  cutnb 14.0 ctofnb 12.0 ctonnb 10.0 -
#  eps 1.0 e14fac 1.0 wmin 1.5
#
# These are good default values for most simulations. In some cases when running
# in vacuum, it might be necessary to use VSHIft instead of VSWItch. There are a
# couple other points to remember:
#
# 1    Always set INBFrq to -1 so nonbond updates are done heuristically.
# 2    You can safely increase CUTNb to decrease the frequency of nonbond list
#      updates (at the expense of a higher memory requirement for the nonbond
#      list).
# 3    In general, a nonbond cut off of less than 12 angstroms should not be
#      used (the errors are too great).
# 4    In Ewald calculations, the electrostatic cut-off method (SHIFt vs. SWITch
#      is ignored as the Ewald summation is used to calculate long-range
#      electrostatics. Replace this with the Ewald parameters described above.
#
# As an example, nonbond setup for a simulation using PBC might look like:
#
# nonbond nbxmod 5 atom cdiel -
#  elec ewald pme kappa 0.34 spline order 6 -
#  vdw vatom vswitch -
#  cutnb 14.0 ctofnb 12.0 ctonnb 10.0
#
# Be very careful to check compatibility of your nonbond specification with the
# force fields and implicit solvent models you're using (if any)! This is
# critically important to the correctness of your simulation!

### with EAM

{%- if (use_eam is sameas true) and (use_ewald is sameas true) and (use_dpd_tstat is sameas true) %}
pair_style hybrid/overlay &
    lj/charmmfsw/coul/long ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff} &
    eam/alloy &
    dpd/tstat ${temperatureT} ${temperatureT} ${dpd_cutoff} ${random_seed}
{%- elif (use_eam is sameas true) and (use_dpd_tstat is sameas true) %}
pair_style hybrid/overlay &
    lj/charmmfsw/coul/charmmfsh ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff} &
    eam/alloy &
    dpd/tstat ${temperatureT} ${temperatureT} ${dpd_cutoff} ${random_seed}
{%- elif (use_eam is sameas true) and (use_ewald is sameas true) %}
pair_style hybrid &
    lj/charmmfsw/coul/long ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff} &
    eam/alloy
{%- elif (use_eam is sameas true) %}
pair_style hybrid lj/charmmfsw/coul/charmmfsh ${inner_cutoff} ${outer_cutoff} ${coulomb_cutoff} eam/alloy
{%- endif %}
# The hybrid and hybrid/overlay styles enable the use of multiple pair styles in
# one simulation. With the hybrid style, exactly one pair style is assigned to
# each pair of atom types. With the hybrid/overlay style, one or more pair
# styles can be assigned to each pair of atom types. The assignment of pair
# styles to type pairs is made via the pair_coeff command.

pair_modify mix arithmetic

{%- if use_ewald is sameas true %}
kspace_style    pppm ${ewald_accuracy}
# Quote from http://lammps.sandia.gov/doc/kspace_style.html:
# pppm value = accuracy
#  accuracy = desired relative error in forces
#
# The pppm style invokes a particle-particle particle-mesh solver (Hockney)
# which maps atom charge to a 3d mesh, uses 3d FFTs to solve Poisson's
# equation on the mesh, then interpolates electric fields on the mesh points
# back to the atoms. It is closely related to the particle-mesh Ewald
# technique (PME) (Darden) used in AMBER and CHARMM. The cost of traditional
# Ewald summation scales as N^(3/2) where N is the number of atoms in the
# system. The PPPM solver scales as Nlog(N) due to the FFTs, so it is almost
# always a faster choice (Pollock).
#
# [...]
#
# The specified accuracy determines the relative RMS error in per-atom forces
# calculated by the long-range solver. It is set as a dimensionless number,
# relative to the force that two unit point charges (e.g. 2 monovalent ions)
# exert on each other at a distance of 1 Angstrom. This reference value was
# chosen as representative of the magnitude of electrostatic forces in atomic
#  systems. Thus an accuracy value of 1.0e-4 means that the RMS error will be
#  a factor of 10000 smaller than the reference force.
#
# The accuracy setting is used in conjunction with the pairwise cutoff to
# determine the number of K-space vectors for style ewald or the grid size for
#  style pppm or msm.
#
# (Hockney)   Hockney and Eastwood, Computer Simulation Using Particles,
#             Adam Hilger, NY (1989).
# (Darden)    Darden, York, Pedersen, J Chem Phys, 98, 10089 (1993).
# (Pollock)   Pollock and Glosli, Comp Phys Comm, 95, 93 (1996).
{%- endif %}

{%- if (pbc2d is sameas true) and (use_ewald is sameas true) %}
kspace_modify slab 3.0
# The slab keyword allows an Ewald or PPPM solver to be used for a systems that
# are periodic in x,y but non-periodic in z - a boundary setting of
# "boundary p p f". This is done by treating the system as if it were periodic
# in z, but inserting empty volume between atom slabs and removing dipole
# inter-slab interactions so that slab-slab interactions are effectively turned
# off. The volfactor value sets the ratio of the extended dimension in z divided
# by the actual dimension in z. The recommended value is 3.0. A larger value is
# inefficient; a smaller value introduces unwanted slab-slab interactions. The
# use of fixed boundaries in z means that the user must prevent particle
# migration beyond the initial z-bounds, typically by providing a wall-style
# fix. The methodology behind the slab option is explained in the paper by
# (Yeh). The slab option is also extended to non-neutral systems (Ballenegger).
#
# An alternative slab option can be invoked with the nozforce keyword in lieu of
# the volfactor. This turns off all kspace forces in the z direction. The
# nozforce option is not supported by MSM. For MSM, any combination of periodic,
# non-periodic, or shrink-wrapped boundaries can be set using boundary (the slab
# approximation in not needed). The slab keyword is not currently supported by
# Ewald or PPPM when using a triclinic simulation cell. The slab correction has
# also been extended to point dipole interactions (Klapp) in kspace_style
# ewald/disp.

# If you wish to apply an electric field in the Z-direction, in conjunction with
# the slab keyword, you should do it by adding explicit charged particles to the
# +/- Z surfaces. If you do it via the fix efield command, it will not give the
# correct dielectric constant due to the Yeh/Berkowitz (Yeh) correction not
# being compatible with how fix efield works.
{%- endif %}

{%- if (not is_restart is sameas true) and (read_datafile is sameas true)%}
###############################################################################
### data file input

read_data ${data_file}
{%- endif %}

###############################################################################
### box modifications

# shrink wrap if desired to "tighten" box around system:
{%- if shrink_wrap_once is sameas true %}
change_box all boundary s s s
{%- endif %}

{%- if (shrink_wrap_once is sameas true) and (pbc2d is sameas true) %}
change_box all boundary p p f
{%- elif shrink_wrap_once is sameas true %}
change_box all boundary p p p
{%- endif %}

{%- if add_vacuum > 0.0 %}
# add vacuum to box
change_box all z final $(zlo) $(zhi+v_add_vacuum) units box
{%- endif %}

# shift (periodic) box, but not atom coordinates:
# This can be used to avoid having frozen substrate atoms close to the periodic
# boundary, resulting in them transitioning across the boundary due to box
# scaling in the NPT ensemble
# By shifting, solvent molecules are likely to be split across the boundary.
# For proper constraining, SHAKE (and RATTLE) need the image flags to be set
# correctly in this case. change_box does not alter the image flags.
# A combination of displace_atoms and change_box with remapping achieves
# the preservation of atom coordinates and setting of image flags if crossing
# a periodic boundary during the box shift.
{%- if box_shift_z != 0.0 %}
variable desired_zlo equal $(zlo-v_box_shift_z)
variable desired_zhi equal $(zhi-v_box_shift_z)
print "Box current z range [$(zlo),$(zhi)], desired z range [${desired_zlo},${desired_zhi}]"
{%- if shift_system_with_box is sameas false %}
displace_atoms all move 0.0 0.0 ${box_shift_z} units box
{%- endif %}
change_box all set z final ${desired_zlo} ${desired_zhi} remap units box
{%- endif %}

###############################################################################
### force field parameter input

# LAMMPS does not allow conditional includes. We simulate this by including
# an empty file per default:
shell touch coeff_dummy.input
# read force field parameter from file if specified:
include ${coeff_infile}

shell touch pair_coeff_dummy.input
include ${pair_coeff_infile}

shell touch bonded_coeff_dummy.input
include ${bonded_coeff_infile}

{%- if (use_eam is sameas true) %}
###############################################################################
### EAM potential pair coeffs

# override Au-Au LJ interaction by EAM potential:
# TODO: currently, substrate must be last type
pair_coeff * * eam/alloy ${eam_alloy_file} &
    {% for i in range(substrate_type-1) %} NULL{% endfor %} {{ substrate_element|default("Au", true) }}
# https://lammps.sandia.gov/doc/pair_hybrid.html
# For the hybrid style, each atom type pair I,J is assigned to exactly one
# sub-style. Just as with a simulation using a single pair style, if you specify
# the same atom type pair in a second pair_coeff command, the previous
# assignment will be overwritten.
#
# A subset of atom types is assigned to the many-body potential with a single
# pair_coeff command, using "* *" to include all types and the NULL keywords
# described above to exclude specific types not assigned to that potential. If
# types 1,3,4 were assigned in that way (but not type 2), this means that all
# many-body interactions between all atoms of types 1,3,4 will be computed by
# that potential. Pair_style hybrid allows interactions between type pairs 2-2,
# 1-2, 2-3, 2-4 to be specified for computation by other pair styles. You could
# even add a second interaction for 1-1 to be computed by another pair style,
# assuming pair_style hybrid/overlay is used.
#
# https://lammps.sandia.gov/doc/pair_eam.html#pair-style-eam-fs-command
# [...] All of these files are parameterized in terms of LAMMPS metal units.
#
# [...] where there are N additional arguments after the filename, where N is
# the number of LAMMPS atom types. See the pair_coeff doc page for alternate
# ways to specify the path for the potential file. The N values determine the
# mapping of LAMMPS atom types to EAM elements in the file, as described above
# for style eam/alloy. As with eam/alloy, if a mapping value is NULL, the
# mapping is not performed. This can be used when an eam/fs potential is used as
# part of the hybrid pair style. The NULL values are used as placeholders for
# atom types that will be used with other potentials.

# Setfl files in the potentials directory of the LAMMPS distribution have an
# ".eam.alloy" suffix. A DYNAMO multi-element setfl file is formatted as
# follows:
#    lines 1,2,3 = comments (ignored)
#    line 4: Nelements Element1 Element2 ... ElementN
#    line 5: Nrho, drho, Nr, dr, cutoff
#
# FS EAM files include more information than the DYNAMO setfl format files read
# by eam/alloy, in that i,j density functionals for all pairs of elements are
# included as needed by the Finnis/Sinclair formulation of the EAM.
#
# FS EAM files in the potentials directory of the LAMMPS distribution have an
# ".eam.fs" suffix. They are formatted as follows:
#
#     lines 1,2,3 = comments (ignored)
#     line 4: Nelements Element1 Element2 ... ElementN
#     line 5: Nrho, drho, Nr, dr, cutoff
#
# The 5-line header section is identical to an EAM setfl file.
#
# Following the header are Nelements sections, one for each element I, each with
# the following format:
#
#     line 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)
#     embedding function F(rho) (Nrho values)
#     density function rho(r) for element I at element 1 (Nr values)
#     density function rho(r) for element I at element 2
#     ...
#     density function rho(r) for element I at element Nelement
#
# The units of these quantities in line 1 are the same as for setfl files. Note
# that the rho(r) arrays in Finnis/Sinclair can be asymmetric (i,j != j,i) so
# there are Nelements^2 of them listed in the file.
#
# The eam pair styles do not write their information to binary restart files,
# since it is stored in tabulated potential files. Thus, you need to re-specify
# the pair_style and pair_coeff commands in an input script that reads a restart
# file.
{%- endif %}

###############################################################################
### DPD thermostat pair coeffs

# if using dpd/tstat, pair_style is hybrid/overlay, and thus AU-AU LJ
# interactions must be switched of explicitely
{%- if (use_dpd_tstat is sameas true) and (use_ewald is sameas true) %}
pair_coeff ${substrate_type} ${substrate_type} lj/charmmfsw/coul/long 0.0 0.0
{%- elif use_dpd_tstat is sameas true %}
pair_coeff ${substrate_type} ${substrate_type} lj/charmmfsw/coul/charmmfsh 0.0 0.0
{%- endif %}

{%- if use_dpd_tstat is sameas true %}
pair_coeff ${substrate_type} ${substrate_type} dpd/tstat ${dpd_damping_parameter}
# https://lammps.sandia.gov/doc/pair_hybrid.html
# For the hybrid/overlay style, each atom type pair I,J can be assigned to one
# or more sub-styles. If you specify the same atom type pair in a second
# pair_coeff command with a new sub-style, then the second sub-style is
# added to the list of potentials that will be calculated for two interacting
# atoms of those types. If you specify the same atom type pair in a second
# pair_coeff command with a sub-style that has already been defined for
# that pair of atoms, then the new pair coefficients simply override the
# previous ones, as in the normal usage of the pair_coeff command.
#
# If an assignment to none is made in a simulation with the hybrid/overlay
# pair style, it wipes out all previous assignments of that atom type pair
# to sub-styles.
{%- endif %}

###############################################################################
### communication settings (after pair styles definitions)

{%- if (comm_cutoff > 0.0) and (use_dpd_tstat is sameas true) %}
# explicitly specify single communication cutoff for all atoms, otherwise LAMMMPS warns about
#   WARNING: Communication cutoff 0.0 is shorter than a bond length based estimate ...
# although "cutoff default of 0.0 means that ghost cutoff = neighbor cutoff = pairwise force cutoff + neighbor skin.",
# according to https://lammps.sandia.gov/doc/comm_modify.html. See also discussion at
# https://lammps.sandia.gov/threads/msg87835.html.
comm_modify mode single cutoff ${comm_cutoff} vel yes
{%- elif comm_cutoff > 0.0 %}
comm_modify mode single cutoff ${comm_cutoff}
{%- elif use_dpd_tstat is sameas true %}
comm_modify vel yes
# https://lammps.sandia.gov/doc/comm_modify.html
# The vel keyword enables velocity information to be communicated with ghost
# particles. Depending on the atom_style, velocity info includes the
# translational velocity, angular velocity, and angular momentum of a particle.
# If the vel option is set to yes, then ghost atoms store these quantities; if
# no then they do not. The yes setting is needed by some pair styles which
# require the velocity state of both the I and J particles to compute a
# pairwise I,J interaction, as well as by some compute and fix commands.
{%- endif %}

# force field is defined completely at this point
{%- if (write_coeff is sameas true) %}
write_coeff ${coeff_outfile}
{%- endif %}
# The write_coeff command is not yet fully implemented as some pair styles do
# not output their coefficient information. This means you will need to add/copy
# this information manually.

###############################################################################
### region definitions

# determine center # OBSOLETE, 2020/12/05
variable x_center equal $(( xlo + xhi ) / 2.0)
variable y_center equal $(( ylo + yhi ) / 2.0)
variable z_center equal $(( zlo + zhi ) / 2.0)

# For style plane, a plane is defined which contain the point (px,py,pz) and
# has a normal vector (nx,ny,nz). The normal vector does not have to be of unit
# length. The "inside" of the plane is the half-space in the direction of the
# normal vector; see the discussion of the side option below.
#
{%- if (manual_indenter_region is sameas true) %}
variable indenter_region_bottom equal $((zlo + v_substrate_thickness + v_indenter_substrate_dist - v_region_tolerance))
variable indenter_region_top equal $((zlo + v_substrate_thickness + v_indenter_substrate_dist + v_indenter_height + v_region_tolerance))
region indenter_region block INF INF INF INF ${indenter_region_bottom} ${indenter_region_top} units box
{%- else %}
# ATTENTION: if no manual indenter position and measures are specified, then
# upper half of simulation box is used to select indenter.
# if indenter protudes into lower half, this results in wrong atom selection!
region indenter_region plane 0  0  ${region_tolerance} 0 0 1 side in units box
#                                 ^x ^y ^z                  ^plane normal
#                                                                 ^everything in direction of normal in region
#                                                                         ^Ang as unit
{%- endif %}

# 2019/04/26: contrary to previous practice, now expect substrate to be z < 0

special_bonds charmm
# http://lammps.sandia.gov/doc/special_bonds.html
# The charmm keyword sets the 3 coefficients to 0.0, 0.0, 0.0 for both LJ and
# Coulombic interactions, which is the default for a commonly used version of
# the CHARMM force field. Note that in pair styles lj/charmm/coul/charmm and
# lj/charmm/coul/long the 1-4 coefficients are defined explicitly, and these
# pairwise contributions are computed as part of the charmm dihedral style
# - see the pair_coeff and dihedral_style commands for more information.
# See (MacKerell) for a description of the CHARMM force field.

# if "${use_eam} > 0" then &
#     "special_bonds  pair eam/fs 1.0 1.0 1.0"
# The special and compute/tally keywords can only be used in conjunction with
# the pair keyword and must directly follow it. special allows to override the
# special_bonds settings for the specified sub-style. compute/tally allows to
# disable or enable registering compute */tally computes for a given sub-style.
# More details are given below.

timestep ${timestep}

###############################################################################
### group definitions

# pre-define groups:
{%- if (not is_restart is sameas true) %}
group atoms_in_central_column empty
group atoms_in_frozen_substrate_layer_region empty
group atoms_in_indenter_region empty
group frozen empty
group frozen_substrate_layer empty
group indenter empty
group indenter_apex empty
group ion empty
group nonwater empty
group nonindenter empty
group nonsolid empty
group nonsolvent empty
group nonsubstrate empty
group solvent empty
group solid empty
group substrate empty
group surfactant empty
group surface empty
group water empty
{%- endif %}

{%- if (not is_restart is sameas true) %}
group solvent    type {% for type in solvent_types %} {{ type }} {% endfor %}  # 8 - H, 10 - O
group solid      type {{ substrate_type }}
group ion        type {{ counterion_type }}
group surfactant subtract all solvent solid ion
group nonwater   subtract all solvent
group nonsolid   subtract all solid
{%- endif %}

# correct if indenter is present
{%- if (not is_restart is sameas true) and (has_indenter is sameas true) %}
group atoms_in_indenter_region region indenter_region
group substrate      subtract  solid atoms_in_indenter_region
group indenter       subtract  solid substrate
variable indenterComX equal xcm(indenter,x)
variable indenterComY equal xcm(indenter,y)
variable indenterComZ equal xcm(indenter,z)
region central_column cylinder z ${indenterComX} ${indenterComY} 2.0 ${region_tolerance} $((zhi)) side in
#                              ^cylinder axis
#                                ^cylinder coordinates in x,y dim
#                                                        ^cylinder radius
#                                                            ^lower and ^upper point
group atoms_in_central_column  region central_column
group indenter_apex  intersect indenter atoms_in_central_column
group nonindenter    subtract all indenter
group nonsubstrate   subtract all substrate
{%- elif not is_restart is sameas true %}
group substrate      intersect all solid
group nonsubstrate   subtract all substrate
{%- endif %}

{%- if (not is_restart is sameas true) and (has_indenter is sameas true) and (rigid_indenter is sameas true) %}
# freeze indenter if explicitly specified
group frozen union frozen indenter
{%- elif (not is_restart is sameas true) and (has_indenter is sameas true) and (rigid_indenter_core_radius > 0.0) %}
region rigid_indenter_core_region sphere ${indenterComX} ${indenterComY} &
        ${indenterComZ} ${rigid_indenter_core_radius}
group rigid_indenter_core  region  rigid_indenter_core_region
group frozen               union   frozen rigid_indenter_core
{%- endif %}

# define region of frozen substrate layer if desired:
{%- if (not is_restart is sameas true) and (freeze_substrate_layer > 0.0) %}
region frozen_substrate_layer_region plane 0 0 $((bound(substrate,zmin)+v_freeze_substrate_layer)) 0 0 1 side out units box
{%- endif %}

{%- if (not is_restart is sameas true) and (restrain_substrate_layer > 0.0) %}
# define region of restrained substrate layer if desired:
region restrained_substrate_layer_region plane 0 0 $((bound(substrate,zmin)+v_restrain_substrate_layer)) 0 0 1 side out units box
{%- endif %}

{%- if (not is_restart is sameas true) and (freeze_substrate_layer > 0.0) %}
# create substrate layer group to hold frozen at bottom if desired:
group atoms_in_frozen_substrate_layer_region region frozen_substrate_layer_region
group frozen_substrate_layer intersect substrate atoms_in_frozen_substrate_layer_region
group frozen union frozen frozen_substrate_layer
{%- endif %}

{%- if (not is_restart is sameas true) and (restrain_substrate_layer > 0.0) %}
# create substrate layer group to hold restrained at bottom if desired:
group atoms_in_restrained_substrate_layer_region region restrained_substrate_layer_region
group restrained_substrate_layer intersect substrate atoms_in_restrained_substrate_layer_region
{%- endif %}

# create groups of substrate and indenter without frozen parts for computes
{%- if not is_restart is sameas true %}
group warm_substrate   subtract substrate      frozen
group warm_indenter    subtract indenter       frozen
group warm_nonindenter subtract nonindenter    frozen
group warm_system      subtract all            frozen
{%- endif %}

{%- if not is_restart is sameas true %}
# If the group ID already exists, the group command adds the specified atoms to the group.
# for compatibility reasons:
group surface     intersect all substrate
group water       intersect all solvent
group nonsolvent  subtract all solvent
{%- endif %}

{%- if read_groups_from_file is sameas true %}
ndx2group ${ndx_file}
print "#atoms atoms_in_central_column:                $(count(atoms_in_central_column))"
print "#atoms atoms_in_frozen_substrate_layer_region: $(count(atoms_in_frozen_substrate_layer_region))"
print "#atoms atoms_in_indenter_region:               $(count(atoms_in_indenter_region))"
print "#atoms frozen:                                 $(count(frozen))"
print "#atoms frozen_substrate_layer:                 $(count(frozen_substrate_layer))"
print "#atoms indenter:                               $(count(indenter))"
print "#atoms indenter_apex:                          $(count(indenter_apex))"
print "#atoms ion:                                    $(count(ion))"
print "#atoms nonwater:                               $(count(nonwater))"
print "#atoms nonindenter:                            $(count(nonindenter))"
print "#atoms nonsolid:                               $(count(nonsolid))"
print "#atoms nonsolvent:                             $(count(nonsolvent))"
print "#atoms nonsubstrate:                           $(count(nonsubstrate))"
print "#atoms solvent:                                $(count(solvent))"
print "#atoms solid:                                  $(count(solid))"
print "#atoms substrate:                              $(count(substrate))"
print "#atoms surfactant:                             $(count(surfactant))"
print "#atoms surface:                                $(count(surface))"
print "#atoms water:                                  $(count(water))"
{%- elif write_groups_to_file is sameas true %}
group2ndx ${ndx_file}
{%- endif %}
# https://lammps.sandia.gov/doc/group2ndx.html#ndx2group-command
# Without specifying any group IDs, all groups except System will be read from
# the index file and the corresponding groups recreated. If a group of the same
# name already exists, it will be completely reset. When specifying group IDs,
# those groups, if present, will be read from the index file and restored.

###############################################################################
### compute definitions

# compute temperature based upon non-frozen components of system:
compute system_temp warm_system temp
# however, compute pressure for all atoms in whole volume based on this temp:
compute system_press all pressure system_temp
# compute the virial
compute system_virial all pressure NULL virial
# https://lammps.sandia.gov/doc/compute_pressure.html
# The temperature and kinetic energy tensor is not calculated by this compute,
# but rather by the temperature compute specified with the command. If the
# kinetic energy is not included in the pressure, than the temperature compute
# is not used and can be specified as NULL. Normally the temperature compute
# used by compute pressure should calculate the temperature of all atoms for
# consistency with the virial term, but any compute style that calculates
# temperature can be used, e.g. one that excludes frozen atoms or other degrees
# of freedom.

# Note that if desired the specified temperature compute can be one that
# subtracts off a bias to calculate a temperature using only the thermal
# velocity of the atoms, e.g. by subtracting a background streaming velocity.
# See the doc pages for individual compute commands to determine which ones
# include a bias.

# kspace no: AU atoms neutral
{%- if compute_interactions is sameas true and has_indenter is sameas true %}
compute indenter_substrate_interaction indenter group/group substrate pair yes kspace no
compute indenter_surfactant_interaction indenter group/group surfactant pair yes kspace no
compute indenter_solvent_interaction indenter group/group solvent pair yes kspace no
compute indenter_ion_interaction indenter group/group ion pair yes kspace no
compute indenter_nonindenter_interaction indenter group/group nonindenter pair yes kspace no
{%- endif %}
# indenter_substrate_interaction indenter_surfactant_interaction
# indenter_solvent_interaction indenter_ion_interaction

{%- if compute_interactions is sameas true %}
compute substrate_solvent_interaction substrate group/group solvent pair yes kspace no
compute substrate_surfactant_interaction substrate group/group surfactant pair yes kspace no
compute substrate_ion_interaction substrate group/group ion pair yes kspace no
compute surfactant_surfactant_intermolecular_interaction surfactant group/group surfactant pair yes kspace yes molecule inter
compute surfactant_surfactant_intramolecular_interaction surfactant group/group surfactant pair yes kspace yes molecule intra
compute surfactant_solvent_interaction surfactant group/group solvent pair yes kspace yes
compute surfactant_ion_interaction surfactant group/group solvent pair yes kspace yes
# substrate_solvent_interaction substrate_surfactant_interaction
# substrate_ion_interaction surfactant_surfactant_intermolecular_interaction
# surfactant_surfactant_intramolecular_interaction surfactant_solvent_interaction
# surfactant_solvent_interaction surfactant_ion_interaction
{%- endif %}

{%- if compute_group_properties is sameas true %}
# in the follwoing, only "warm" (i.e. not frozen) parts are considered for
# temperature and pressure computations. Two temperatures and pressures are
# determined for the indenter, namely biased and unbiased, latter corrected
# for some possibly prescribed indenter center of mass velocity:
compute indenter_temp_biased warm_indenter temp
compute indenter_temp      warm_indenter   temp/com
compute ion_temp           ion             temp
compute solvent_temp       solvent         temp
compute substrate_temp     warm_substrate  temp
compute surfactant_temp    surfactant      temp
compute peratom_stress     all stress/atom NULL
compute peratom_indenter_stress warm_indenter &
        stress/atom indenter_temp
compute indenter_stress_biased warm_indenter reduce &
        sum c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
compute indenter_stress warm_indenter reduce &
        sum c_peratom_indenter_stress[1] c_peratom_indenter_stress[2] &
            c_peratom_indenter_stress[3]
compute ion_stress ion reduce &
        sum c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
compute solvent_stress solvent reduce &
        sum c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
compute substrate_stress warm_substrate reduce &
        sum c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
compute surfactant_stress surfactant reduce &
        sum c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
compute total_stress all reduce &
        sum c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
variable indenter_press_biased equal &
        -(c_indenter_stress_biased[1]+c_indenter_stress_biased[2]+c_indenter_stress_biased[3])/(3*vol)
variable indenter_press equal &
        -(c_indenter_stress[1]+c_indenter_stress[2]+c_indenter_stress[3])/(3*vol)
variable ion_press equal &
        -(c_ion_stress[1]+c_ion_stress[2]+c_ion_stress[3])/(3*vol)
variable solvent_press equal &
        -(c_solvent_stress[1]+c_solvent_stress[2]+c_solvent_stress[3])/(3*vol)
variable substrate_press equal &
        -(c_substrate_stress[1]+c_substrate_stress[2]+c_substrate_stress[3])/(3*vol)
variable surfactant_press equal &
        -(c_surfactant_stress[1]+c_surfactant_stress[2]+c_surfactant_stress[3])/(3*vol)
variable total_press equal &
        -(c_total_stress[1]+c_total_stress[2]+c_total_stress[3])/(3*vol)
# ATTENTION: the "pressures" here are not normalized by group volume, but by
#            total system volume!

# https://lammps.sandia.gov/doc/compute_temp.html
# A kinetic energy tensor, stored as a 6-element vector, is also calculated by
# this compute for use in the computation of a pressure tensor. The formula for
# the components of the tensor is the same as the above formula, except that v^2
# is replaced by vx*vy for the xy component, etc. The 6 components of the vector
# are ordered xx, yy, zz, xy, xz, yz.
#
# This compute subtracts out degrees-of-freedom due to fixes that constrain
# molecular motion, such as fix shake and fix rigid. This means the temperature
# of groups of atoms that include these constraints will be computed correctly.
# If needed, the subtracted degrees-of-freedom can be altered using the extra
# option of the compute_modify command.

# https://lammps.sandia.gov/doc/compute_temp_com.html
# Define a computation that calculates the temperature of a group of atoms,
# after subtracting out the center-of-mass velocity of the group. This is useful
# if the group is expected to have a non-zero net velocity for some reason. A
# compute of this style can be used by any command that computes a temperature,
# e.g. thermo_modify, fix temp/rescale, fix npt, etc.
#
# The removal of the center-of-mass velocity by this fix is essentially
# computing the temperature after a "bias" has been removed from the velocity of
# the atoms. If this compute is used with a fix command that performs
# thermostatting then this bias will be subtracted from each atom,
# thermostatting of the remaining thermal velocity will be performed, and the
# bias will be added back in. Thermostatting fixes that work in this way include
# fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.

# https://lammps.sandia.gov/doc/compute_stress_atom.html
# The temp-ID argument can be used to affect the per-atom velocities used in the
# kinetic energy contribution to the total stress. If the kinetic energy is not
# included in the stress, than the temperature compute is not used and can be
# specified as NULL. If the kinetic energy is included and you wish to use atom
# velocities as-is, then temp-ID can also be specified as NULL. If desired, the
# specified temperature compute can be one that subtracts off a bias to leave
# each atom with only a thermal velocity to use in the formula above, e.g. by
# subtracting a background streaming velocity. See the doc pages for individual
# compute commands to determine which ones include a bias.
#
# Note that as defined in the formula, per-atom stress is the negative of the
# per-atom pressure tensor. It is also really a stress*volume formulation,
# meaning the computed quantity is in units of pressure*volume. It would need to
# be divided by a per-atom volume to have units of stress (pressure), but an
# individual atom's volume is not well defined or easy to compute in a deformed
# solid or a liquid. See the compute voronoi/atom command for one possible way
# to estimate a per-atom volume.
#
# Thus, if the diagonal components of the per-atom stress tensor are summed for
# all atoms in the system and the sum is divided by dV, where d = dimension and
# V is the volume of the system, the result should be -P, where P is the total
# pressure of the system.
#
# The per-atom array values will be in pressure*volume units as discussed above.
#
# The per-atom stress does not include any Lennard-Jones tail corrections to the
# pressure added by the pair_modify tail yes command, since those are
# contributions to the global system pressure.
{%- endif %}

# https://lammps.sandia.gov/doc/compute_reduce.html
# Define a calculation that "reduces" one or more vector inputs into scalar
# values, one per listed input.
#
# Each listed input is operated on independently. For per-atom inputs, the group
# specified with this command means only atoms within the group contribute to
# the result. For per-atom inputs, if the compute reduce/region command is used,
# the atoms must also currently be within the region. Note that an input that
# produces per-atom quantities may define its own group which affects the
# quantities it returns. For example, if a compute is used as an input which
# generates a per-atom vector, it will generate values of 0.0 for atoms that are
# not in the group specified for that compute.
# SDS - specific
#       1      1.008  # HAL2
#       2      1.008  # HAL3
#       3     12.011  # CTL2
#       4     12.011  # CTL3
#       5    15.9994  # OSL
#       6    15.9994  # O2L
#       7      32.06  # SL
#       8      1.008  # HT
#       9    15.9994  # OT
#      10   22.98977  # SOD
#      11   196.9665  # AU

# CTAB - specific
#
# group          water      type  8 9    #  8 - H, 10 - O
# group          surface    type  11     # 11 - Au
# group          ion        type  10     # 10 - Br-
# group          surfactant subtract all water surface ion
# group          nonwater   subtract all water
#
# From "41_CTAB_on_AU_111_21x12x2_bilayer_psfgen.data"
#        1      1.008  # HL
#        2      1.008  # HAL2
#        3      1.008  # HAL3
#        4     12.011  # CTL2
#        5     12.011  # CTL3
#        6     12.011  # CTL5
#        7     14.007  # NTL
#        8      1.008  # HT
#        9    15.9994  # OT
#       10     79.904  # BR
#       11   196.9665  # AU

###############################################################################
### group-based modifications, etc.
#
# exclude intra-frozen interactions for rigid indenter and substrate
variable number_of_frozen_atoms equal count(frozen)
{%- if exclude_frozen_interactions is sameas true %}
if "${number_of_frozen_atoms} > 0" then &
  "neigh_modify exclude group frozen frozen"
{%- endif %}

# walls if box non-periodic, use AU paramters (sigma ignored)
{%- if pbc2d is sameas true %}
fix upper_wall all wall/harmonic zhi EDGE 5.29 2.629 3.0
fix_modify upper_wall energy yes virial yes
#                   ^style        ^face
#                                        ^coord
#                                             ^epsilon
#                                                  ^sigma
#                                                        ^cutoff
# https://lammps.sandia.gov/doc/fix_wall.html
# args = coord epsilon sigma cutoff
#  coord = position of wall = EDGE or constant or variable
#    EDGE = current lo or hi edge of simulation box
#    constant = number like 0.0 or -30.0 (distance units)
#    variable = equal-style variable like v_x or v_wiggle
# epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)
#    epsilon can be a variable (see below)
# sigma = size factor for wall-particle interaction (distance units)
#    sigma can be a variable (see below)
# cutoff = distance from wall at which wall-particle interaction is cut off (distance units)
#
# The harmonic style is a softer potential and does not blow up as r -> 0, but
# you must use a large enough epsilon that particles always reamin on the
# correct side of the wall (r > 0).
#
# The forces due to this fix are imposed during an energy minimization, invoked
# by the minimize command.
#
# If you want the atom/wall interaction energy to be included in the total
# potential energy of the system (the quantity being minimized), you MUST enable
# the fix_modify energy option for this fix.
#
# No information about this fix is written to binary restart files.
#
# The fix_modify energy option is supported by this fix to add the energy of
# interaction between atoms and each wall to the system's potential energy as
# part of thermodynamic output.
#
# The fix_modify virial option is supported by this fix to add the contribution
# due to the interaction between atoms and each wall to the system's virial as
# part of thermodynamic output. The default is virial no
{%- endif %}

###############################################################################
### thermo outputs

# fix thermoAveOut all ave/time 1 100 100 c_thermo_etotal c_thermo_ke c_thermo_pe &
#   c_thermo_temp c_thermo_press c_thermo_enthalpy c_thermo_ebond c_thermo_eangle &
#   c_thermo_edihed c_thermo_eimp c_thermo_epair c_thermo_evdwl c_thermo_ecoul  &
#   c_thermo_elong c_thermo_etail c_thermo_vol &
#   mode scalar file ${base_name}.out

# (1) If the last printable character on the line is a "&" character, the
# command is assumed to continue on the next line. The next line is concatenated
# to the previous line by removing the "&" character and line break. This allows
# long commands to be continued across two or more lines. See the discussion of
# triple quotes in (6) for how to continue a command across multiple line
# without using "&" characters.

# output cases
#
# index | indenter  | c_inter   | c_group
# 1     | yes       | yes       | yes
# 2     | yes       | yes       | no
# 3     | yes       | no        | yes
# 4     | yes       | no        | no        same as no no no
# 5     | no        | yes       | yes
# 6     | no        | yes       | no
# 7     | no        | no        | yes
# 8     | no        | no        | no        covers case 4 as well

{%- if compute_group_properties is sameas true and compute_interactions is sameas true and has_indenter is sameas true %}
thermo_style custom step etotal ke pe temp press enthalpy ebond eangle &
   edihed eimp epair evdwl ecoul elong etail vol &
   pxx pyy pzz pxy pxz pyz &
   c_indenter_temp_biased c_indenter_temp c_ion_temp c_solvent_temp &
   c_substrate_temp c_surfactant_temp &
   v_indenter_press_biased v_indenter_press v_ion_press v_solvent_press &
   v_substrate_press v_surfactant_press v_total_press &
   c_indenter_stress_biased[*] c_indenter_stress[*] c_ion_stress[*] &
   c_solvent_stress[*] c_substrate_stress[*] c_surfactant_stress[*] &
   c_total_stress[*] &
   c_substrate_solvent_interaction c_substrate_solvent_interaction[*] &
   c_substrate_surfactant_interaction c_substrate_surfactant_interaction[*] &
   c_substrate_ion_interaction c_substrate_ion_interaction[*] &
   c_surfactant_surfactant_intermolecular_interaction &
   c_surfactant_surfactant_intermolecular_interaction[*] &
   c_surfactant_surfactant_intramolecular_interaction &
   c_surfactant_surfactant_intramolecular_interaction[*] &
   c_surfactant_solvent_interaction c_surfactant_solvent_interaction[*] &
   c_surfactant_ion_interaction c_surfactant_ion_interaction[*] &
   c_indenter_substrate_interaction c_indenter_substrate_interaction[*] &
   c_indenter_surfactant_interaction c_indenter_surfactant_interaction[*] &
   c_indenter_solvent_interaction c_indenter_solvent_interaction[*] &
   c_indenter_ion_interaction c_indenter_ion_interaction[*]
{%- elif compute_interactions is sameas true and has_indenter is sameas true %}
thermo_style   custom step etotal ke pe temp press enthalpy ebond eangle &
   edihed eimp epair evdwl ecoul elong etail vol &
   pxx pyy pzz pxy pxz pyz &
   c_substrate_solvent_interaction c_substrate_solvent_interaction[*] &
   c_substrate_surfactant_interaction c_substrate_surfactant_interaction[*] &
   c_substrate_ion_interaction c_substrate_ion_interaction[*] &
   c_surfactant_surfactant_intermolecular_interaction &
   c_surfactant_surfactant_intermolecular_interaction[*] &
   c_surfactant_surfactant_intramolecular_interaction &
   c_surfactant_surfactant_intramolecular_interaction[*] &
   c_surfactant_solvent_interaction c_surfactant_solvent_interaction[*] &
   c_surfactant_ion_interaction c_surfactant_ion_interaction[*] &
   c_indenter_substrate_interaction c_indenter_substrate_interaction[*] &
   c_indenter_surfactant_interaction c_indenter_surfactant_interaction[*] &
   c_indenter_solvent_interaction c_indenter_solvent_interaction[*] &
   c_indenter_ion_interaction c_indenter_ion_interaction[*]
{%- elif compute_group_properties is sameas true and has_indenter is sameas true %}
thermo_style custom step etotal ke pe temp press enthalpy ebond eangle &
    edihed eimp epair evdwl ecoul elong etail vol &
    pxx pyy pzz pxy pxz pyz &
    c_indenter_temp_biased c_indenter_temp c_ion_temp c_solvent_temp &
    c_substrate_temp c_surfactant_temp &
    v_indenter_press_biased v_indenter_press v_ion_press v_solvent_press &
    v_substrate_press v_surfactant_press v_total_press &
    c_indenter_stress_biased[*] c_indenter_stress[*] c_ion_stress[*] &
    c_solvent_stress[*] c_substrate_stress[*] c_surfactant_stress[*] &
    c_total_stress[*]
{%- elif compute_group_properties is sameas true and compute_interactions is sameas true %}
thermo_style custom step etotal ke pe temp press enthalpy ebond eangle &
    edihed eimp epair evdwl ecoul elong etail vol &
    pxx pyy pzz pxy pxz pyz &
    c_ion_temp c_solvent_temp &
    c_substrate_temp c_surfactant_temp &
    v_ion_press v_solvent_press &
    v_substrate_press v_surfactant_press v_total_press &
    c_ion_stress[*] c_solvent_stress[*] &
    c_substrate_stress[*] c_surfactant_stress[*] c_total_stress[*] &
    c_substrate_solvent_interaction c_substrate_solvent_interaction[*] &
    c_substrate_surfactant_interaction c_substrate_surfactant_interaction[*] &
    c_substrate_ion_interaction c_substrate_ion_interaction[*] &
    c_surfactant_surfactant_intermolecular_interaction &
    c_surfactant_surfactant_intermolecular_interaction[*] &
    c_surfactant_surfactant_intramolecular_interaction &
    c_surfactant_surfactant_intramolecular_interaction[*] &
    c_surfactant_solvent_interaction c_surfactant_solvent_interaction[*] &
    c_surfactant_ion_interaction c_surfactant_ion_interaction[*]
{%- elif compute_interactions is sameas true %}
thermo_style custom step etotal ke pe temp press enthalpy ebond eangle &
    edihed eimp epair evdwl ecoul elong etail vol &
    pxx pyy pzz pxy pxz pyz &
    c_substrate_solvent_interaction c_substrate_solvent_interaction[*] &
    c_substrate_surfactant_interaction c_substrate_surfactant_interaction[*] &
    c_substrate_ion_interaction c_substrate_ion_interaction[*] &
    c_surfactant_surfactant_intermolecular_interaction &
    c_surfactant_surfactant_intermolecular_interaction[*] &
    c_surfactant_surfactant_intramolecular_interaction &
    c_surfactant_surfactant_intramolecular_interaction[*] &
    c_surfactant_solvent_interaction c_surfactant_solvent_interaction[*] &
    c_surfactant_ion_interaction c_surfactant_ion_interaction[*]
{%- elif compute_group_properties is sameas true %}
thermo_style custom step etotal ke pe temp press enthalpy ebond eangle &
    edihed eimp epair evdwl ecoul elong etail vol &
    pxx pyy pzz pxy pxz pyz &
    c_ion_temp c_solvent_temp &
    c_substrate_temp c_surfactant_temp &
    v_ion_press v_solvent_press &
    v_substrate_press v_surfactant_press v_total_press &
    c_ion_stress[*] c_solvent_stress[*] &
    c_substrate_stress[*] c_surfactant_stress[*] c_total_stress[*]
{%- else %}
thermo_style custom step etotal ke pe temp press enthalpy ebond eangle &
    edihed eimp epair evdwl ecoul elong etail vol &
    pxx pyy pzz pxy pxz pyz
{%- endif %}

# log output every 2 ps per default
thermo         ${thermo_frequency}

# https://lammps.sandia.gov/doc/thermo_style.html
# Several of the thermodynamic quantities require a temperature to be computed:
# "temp", "press", "ke", "etotal", "enthalpy", "pxx", etc. By default this is
# done by using a temperature compute which is created when LAMMPS starts up, as
# if this command had been issued:
#
#   compute thermo_temp all temp
#
# See the compute temp command for details. Note that the ID of this compute is
# thermo_temp and the group is all. You can change the attributes of this
# temperature (e.g. its degrees-of-freedom) via the compute_modify command.
# Alternatively, you can directly assign a new compute (that calculates
# temperature) which you have defined, to be used for calculating any
# thermodynamic quantity that requires a temperature. This is done via the
# thermo_modify command.
#
# Thus, we modify the the thermo output to only include "warm" components of
# our system:
#
# https://lammps.sandia.gov/doc/thermo_modify.html
# These options apply to the currently defined thermo style. When you specify a
# thermo_style command, all thermodynamic settings are restored to their default
# values, including those previously reset by a thermo_modify command. Thus if
# your input script specifies a thermo_style command, you should use the
# thermo_modify command after it.
#
# The temp keyword is used to determine how thermodynamic temperature is
# calculated, which is used by all thermo quantities that require a temperature
# ("temp", "press", "ke", "etotal", "enthalpy", "pxx", etc). The specified
# compute ID must have been previously defined by the user via the compute
# command and it must be a style of compute that calculates a temperature. As
# described in the thermo_style command, thermo output uses a default compute
# for temperature with ID = thermo_temp. This option allows the user to override
# the default.
#
# The press keyword is used to determine how thermodynamic pressure is
# calculated, which is used by all thermo quantities that require a pressure
# ("press", "enthalpy", "pxx", etc). The specified compute ID must have been
# previously defined by the user via the compute command and it must be a style
# of compute that calculates a pressure. As described in the thermo_style
# command, thermo output uses a default compute for pressure with ID =
# thermo_press. This option allows the user to override the default.
#
# If both the temp and press keywords are used in a single thermo_modify command
# (or in two separate commands), then the order in which the keywords are
# specified is important. Note that a pressure compute defines its own
# temperature compute as an argument when it is specified. The temp keyword will
# override this (for the pressure compute being used by thermodynamics), but
# only if the temp keyword comes after the press keyword. If the temp keyword
# comes before the press keyword, then the new pressure compute specified by the
# press keyword will be unaffected by the temp setting.
thermo_modify temp system_temp press system_press norm no flush yes
# Note that some computes calculate "intensive" global quantities like
# temperature; others calculate "extensive" global quantities like kinetic
# energy that are summed over all atoms in the compute group. Intensive
# quantities are printed directly without normalization by thermo_style custom.
# Extensive quantities may be normalized by the total number of atoms in the
# simulation (NOT the number of atoms in the compute group) when output,
# depending on the thermo_modify norm option being used.

# averaging output
#     v Nrepeat                   v Nfreq
#   v Nevery
{%- if thermo_average_frequency > 0 and compute_interactions is sameas true and has_indenter is sameas true %}
fix thermo_average all ave/time &
    1 ${thermo_average_frequency} ${thermo_average_frequency} &
    c_thermo_pe c_thermo_temp c_thermo_press &
    c_substrate_solvent_interaction c_substrate_solvent_interaction[*] &
    c_substrate_surfactant_interaction c_substrate_surfactant_interaction[*] &
    c_substrate_ion_interaction c_substrate_ion_interaction[*] &
    c_surfactant_surfactant_intermolecular_interaction &
    c_surfactant_surfactant_intermolecular_interaction[*] &
    c_surfactant_surfactant_intramolecular_interaction &
    c_surfactant_surfactant_intramolecular_interaction[*] &
    c_surfactant_solvent_interaction c_surfactant_solvent_interaction[*] &
    c_surfactant_ion_interaction c_surfactant_ion_interaction[*] &
    c_indenter_substrate_interaction c_indenter_substrate_interaction[*] &
    c_indenter_surfactant_interaction c_indenter_surfactant_interaction[*] &
    c_indenter_solvent_interaction c_indenter_solvent_interaction[*] &
    c_indenter_ion_interaction c_indenter_ion_interaction[*] &
    file thermo_ave.out
{%- elif thermo_average_frequency > 0 and compute_interactions is sameas true %}
fix thermo_average all ave/time &
    1 ${thermo_average_frequency} ${thermo_average_frequency} &
    c_thermo_pe c_thermo_temp c_thermo_press &
    c_substrate_solvent_interaction c_substrate_solvent_interaction[*] &
    c_substrate_surfactant_interaction c_substrate_surfactant_interaction[*] &
    c_substrate_ion_interaction c_substrate_ion_interaction[*] &
    c_surfactant_surfactant_intermolecular_interaction &
    c_surfactant_surfactant_intermolecular_interaction[*] &
    c_surfactant_surfactant_intramolecular_interaction &
    c_surfactant_surfactant_intramolecular_interaction[*] &
    c_surfactant_solvent_interaction c_surfactant_solvent_interaction[*] &
    c_surfactant_ion_interaction c_surfactant_ion_interaction[*] &
    file thermo_ave.out
{%- elif thermo_average_frequency > 0 %}
fix thermo_average all ave/time &
    1 ${thermo_average_frequency} ${thermo_average_frequency} &
    c_thermo_pe c_thermo_temp c_thermo_press &
    file thermo_ave.out
{%- endif %}
# https://lammps.sandia.gov/doc/fix_ave_time.html
# Use one or more global values as inputs every few timesteps, and average them
# over longer timescales. The resulting averages can be used by other output
# commands such as thermo_style custom, and can also be written to a file.
# Note that if no time averaging is done, this command can be used as a
# convenient way to simply output one or more global values to a file.
#
# The group specified with this command is ignored. However, note that specified
# values may represent calculations performed by computes and fixes which store
# their own "group" definitions.
#
# Each listed value can be the result of a compute or fix or the evaluation of
# an equal-style or vector-style variable. In each case, the compute, fix, or
# variable must produce a global quantity, not a per-atom or local quantity. If
# you wish to spatial- or time-average or histogram per-atom quantities from a
# compute, fix, or variable, then see the fix ave/chunk, fix ave/atom, or fix
# ave/histo commands. If you wish to sum a per-atom quantity into a single
# global quantity, see the compute reduce command.
#
# The Nevery, Nrepeat, and Nfreq arguments specify on what timesteps the input
# values will be used in order to contribute to the average. The final averaged
# quantities are generated on timesteps that are a multiple of Nfreq. The
# average is over Nrepeat quantities, computed in the preceding portion of the
# simulation every Nevery timesteps. Nfreq must be a multiple of Nevery and
# Nevery must be non-zero even if Nrepeat is 1. Also, the timesteps
# contributing to the average value cannot overlap, i.e. Nrepeat*Nevery
# can not exceed Nfreq.
#
# For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on timesteps
# 90,92,94,96,98,100 will be used to compute the final average on timestep 100.
# Similarly for timesteps 190,192,194,196,198,200 on timestep 200, etc. If
# Nrepeat=1 and Nfreq = 100, then no time averaging is done; values are simply
# generated on timesteps 100,200,etc.
#
# Defaults: The option defaults are mode = scalar, ave = one, start = 0,
# no file output, format = %g, title 1,2,3 = strings as described above,
# and no off settings for any input values.

###############################################################################
### system info

{%- if verbose is sameas true %}
print "Force field parameters in lmp_header.input:"
info coeffs out screen
info coeffs out log
print "Computes in lmp_header.input:"
info computes out screen
info computes out log
print "Fixes in lmp_header.input:"
info fixes out screen
info fixes out log
print "Groups in lmp_header.input:"
info groups out screen
info groups out log
print "Regions in lmp_header.input:"
info regions out screen
info regions out log
print "System info in lmp_header.input:"
info system out screen
info system out log
print "Variables in lmp_header.input:"
info variables out screen
info variables out log
{%- endif %}
### end lmp_header.input
###############################################################################

{%- if mode == "split_datafile" %}
###############################################################################
### lmp_split_datafile.input
###############################################################################
# split a data file into force field parameters and data file with topology information
# does not work properly for style 'hybrid'
# force field parameters written above already above
{%- if write_coeff_to_datafile is sameas true %}
write_data ${base_name}.lammps
{%- else %}
write_data ${base_name}.lammps nocoeff
{%- endif %}

{%- elif mode == "minimization" %}
###############################################################################
### lmp_minimizatin.input
###############################################################################
neigh_modify            delay 0 every 1 check yes
# https://lammps.sandia.gov/doc/neigh_modify.html
# The every, delay, check, and once options affect how often lists are built as
# a simulation runs. The delay setting means never build new lists until at
# least N steps after the previous build. The every setting means build lists
# every M steps (after the delay has passed). If the check setting is no, the
# lists are built on the first step that satisfies the delay and every settings.
# If the check setting is yes, then the every and delay settings determine when
# a build may possibly be performed, but an actual build only occurs if some
# atom has moved more than half the skin distance (specified in the neighbor
# command) since the last build.
# If the "delay" setting is non-zero, then it must be a multiple of the "every"
# setting.

###############################################################################
### restraints

{%- if has_indenter is sameas true %}
# Keep indenter restrained during minimzation
# Note that you can minimize some atoms in the system while holding the
# coordinates of other atoms fixed by applying fix setforce to the other atoms.
print 'Indenter frozen during minimization'
fix freeze indenter setforce 0.0 0.0 0.0
# https://lammps.sandia.gov/doc/fix_setforce.html
# Set each component of force on each atom in the group to the specified value
# fx,fy,fz. This erases all previously computed forces on the atom, though
# additional fixes could add new forces. This command can be used to freeze
# certain atoms in the simulation by zeroing their force, either for running
# dynamics or performing an energy minimization. For dynamics, this assumes
# their initial velocity is also zero.
{%- endif %}

{%- if freeze_substrate is sameas true %}
# keep substrate restrained during minimization
print 'Substrate frozen during minimization'
fix freezeSubstrate substrate setforce 0.0 0.0 0.0
{%- endif %}

###############################################################################
### box relaxation

{%- if (relax_box is sameas true) and ((pbc2d is sameas true) or (has_vacuum is sameas true)) %}
fix boxRelaxation all box/relax x ${pressureP} y ${pressureP} couple none fixedpoint 0 0 0 nreset 100
{%- elif (relax_box is sameas true) and (pressurize_z_only is sameas true) %}
fix boxRelaxation all box/relax z ${pressureP} couple none fixedpoint 0 0 0 nreset 100
{%- elif (relax_box is sameas true) %}
fix boxRelaxation all box/relax aniso ${pressureP} fixedpoint 0 0 0 nreset 100
{%- endif %}
# https://lammps.sandia.gov/doc/fix_box_relax.html
# Apply an external pressure or stress tensor to the simulation box during an
# energy minimization. This allows the box size and shape to vary during the
# iterations of the minimizer so that the final configuration will be both an
# energy minimum for the potential energy of the atoms, and the system pressure
# tensor will be close to the specified external tensor. Conceptually,
# specifying a positive pressure is like squeezing on the simulation box; a
# negative pressure typically allows the box to expand.
#
# When the size of the simulation box changes, all atoms are re-scaled to new
# positions, unless the keyword dilate is specified with a value of partial, in
# which case only the atoms in the fix group are re-scaled. This can be useful
# for leaving the coordinates of atoms in a solid substrate unchanged and
# controlling the pressure of a surrounding fluid.
#
# The fixedpoint keyword specifies the fixed point for cell relaxation. By
# default, it is the center of the box. Whatever point is chosen will not move
# during the simulation. For example, if the lower periodic boundaries pass
# through (0,0,0), and this point is provided to fixedpoint, then the lower
# periodic boundaries will remain at (0,0,0), while the upper periodic
# boundaries will move twice as far. In all cases, the particle positions at
# each iteration are unaffected by the chosen value, except that all particles
# are displaced by the same amount, different on each iteration.
#
# Performing a minimization with this fix is not a mathematically well-defined
# minimization problem. This is because the objective function being minimized
# changes if the box size/shape changes. In practice this means the minimizer
# can get "stuck" before you have reached the desired tolerance. The solution to
# this is to restart the minimizer from the new adjusted box size/shape, since
# that creates a new objective function valid for the new box size/shape. Repeat
# as necessary until the box size/shape has reached its new equilibrium.

# The couple keyword allows two or three of the diagonal components of the
# pressure tensor to be "coupled" together. The value specified with the keyword
# determines which are coupled. For example, xz means the Pxx and Pzz components
# of the stress tensor are coupled. Xyz means all 3 diagonal components are
# coupled. Coupling means two things: the instantaneous stress will be computed
# as an average of the corresponding diagonal components, and the coupled box
# dimensions will be changed together in lockstep, meaning coupled dimensions
# will be dilated or contracted by the same percentage every timestep. The
# Ptarget values for any coupled dimensions must be identical. Couple xyz can be
# used for a 2d simulation; the z dimension is simply ignored.
#
# The iso, aniso, and tri keywords are simply shortcuts that are equivalent to
# specifying several other keywords together.
#
# The keyword iso means couple all 3 diagonal components together when pressure
# is computed (hydrostatic pressure), and dilate/contract the dimensions
# together. Using "iso Ptarget" is the same as specifying these 4 keywords:
#
# x Ptarget
# y Ptarget
# z Ptarget
# couple xyz
#
# The keyword aniso means x, y, and z dimensions are controlled independently
# using the Pxx, Pyy, and Pzz components of the stress tensor as the driving
# forces, and the specified scalar external pressure. Using "aniso Ptarget" is
# the same as specifying these 4 keywords:
#
# x Ptarget
# y Ptarget
# z Ptarget
# couple none
#
# [...] only applies when the box dimensions are equal to those of
# the reference dimensions. If this is not the case, then the converged stress
# tensor will not equal that specified by the user. We can resolve this problem
# by periodically resetting the reference dimensions. The keyword nreset
# controls how often this is done. If this keyword is not used, or is given a
# value of zero, then the reference dimensions are set to those of the initial
# simulation domain and are never changed. A value of nstep means that every
# nstep minimization steps, the reference dimensions are set to those of the
# current simulation domain. Note that resetting the reference dimensions
# changes the objective function and gradients, which sometimes causes the
# minimization to fail. This can be resolved by changing the value of nreset, or
# simply continuing the minimization from a restart file.

###############################################################################
### output

dump dumpPng nonsolvent image ${png_frequency} ${base_name}.*.png type type

{%- if mpiio is sameas true %}
print 'netcdf/mpiio output'
dump dumpNetCDF all netcdf/mpiio ${netcdf_frequency} &
    ${base_name}.nc id mol type mass x y z
{%- else %}
print 'netcdf output (no netcdf/mpiiio)'
dump dumpNetCDF all netcdf ${netcdf_frequency} &
    ${base_name}.nc id mol type mass x y z
{%- endif %}

###############################################################################
### minimization

# fix restraint surfactant spring/self 10.0
# http://lammps.sandia.gov/doc/fix_spring_self.html
# Apply a spring force independently to each atom in the group to tether it to
# its initial position. The initial position for each atom is its location at
# the time the fix command was issued. At each timestep, the magnitude of the
# force on each atom is -Kr, where r is the displacement of the atom from its
# current position to its initial position. The distance r correctly takes into
# account any crossings of periodic boundary by the atom since it was in its
# initial position.

print "LAMMPS state before minimization:"
info all out log

{%- if robust_minimization is sameas true %}
print 'Using alternative robust minimization settings'
neigh_modify delay 0 every 1 check yes one 5000 page 250000
{%- endif %}

minimize 0.0 ${minimization_ftol} ${minimization_maxiter} ${minimization_maxeval}

# minimize etol ftol maxiter maxeval
# Quote from http://lammps.sandia.gov/doc/minimize.html
# Perform an energy minimization of the system, by iteratively adjusting atom
# coordinates. Iterations are terminated when one of the stopping criteria is
# satisfied. At that point the configuration will hopefully be in local
# potential energy minimum. More precisely, the configuration should
# approximate a critical point for the objective function (see below), which
# may or may not be a local minimum.
#
#    etol = stopping tolerance for energy (unitless)
#    ftol = stopping tolerance for force (force units)
#    maxiter = max iterations of minimizer
#    maxeval = max number of force/energy evaluations
#
# Either or both of the etol and ftol values can be set to 0.0, in which case
# some other criterion will terminate the minimization.

{%- if write_coeff_to_datafile is sameas true %}
write_data ${base_name}.lammps
{%- else %}
write_data ${base_name}.lammps nocoeff
{%- endif %}
### end lmp_minimizeation.input
###############################################################################
{%- else %}
###############################################################################
### lmp_production.input
###############################################################################
#
# consecutively numbered restart files ...
# restart               100000 ${baseName}.restart # every 200 ps
# ... or two alternating files ...
{%- if mpiio is sameas true %}
print 'mpiio restart files'
restart ${restart_frequency} ${base_name}.mpiio.restart1 ${base_name}.mpiio.restart2
{%- else %}
print 'standard restart files (no mpiiio)'
restart ${restart_frequency} ${base_name}.restart1 ${base_name}.restart2
{%- endif %}
# Source: https://lammps.sandia.gov/doc/restart.html
# [...]
# If a "%" character appears in the restart filename(s), then one file is
# written for each processor and the "%" character is replaced with the
# processor ID from 0 to P-1. An additional file with the "%" replaced by
# "base" is also written, which contains global information. For example,
# the files written on step 1000 for filename restart.% would be
# restart.base.1000, restart.0.1000, restart.1.1000, ..., restart.P-1.1000.
# This creates smaller files and can be a fast mode of output and subsequent
# input on parallel machines that support parallel I/O. The optional fileper
# and nfile keywords discussed below can alter the number of files written.
#
# The restart file can also be written in parallel as one large binary file via
# the MPI-IO library, which is part of the MPI standard for versions 2.0 and
# above. Using MPI-IO requires two steps. First, build LAMMPS with its MPIIO
# package installed [...]
#
# Second, use a restart filename which contains ".mpiio". Note that it does not
# have to end in ".mpiio", just contain those characters. Unlike MPI-IO dump
# files, a particular restart file must be both written and read using MPI-IO.
#                       ^ every 200 ps

{%- if store_forces is sameas true %}
###############################################################################
### Monitor unconstrained forces
fix storeUnconstrainedForces all store/force
fix storeUnconstrainedForcesAve all ave/atom 1 ${netcdf_frequency} &
    ${netcdf_frequency} f_storeUnconstrainedForces[*]
# https://lammps.sandia.gov/doc/fix_store_force.html
# Store the forces on atoms in the group at the point during each timestep when
# the fix is invoked, as described below. This is useful for storing forces
# before constraints or other boundary conditions are computed which modify the
# forces, so that unmodified forces can be written to a dump file or accessed by
# other output commands that use per-atom quantities.

# This fix is invoked at the point in the velocity-Verlet timestepping
# immediately after pair, bond, angle, dihedral, improper, and long-range forces
# have been calculated. It is the point in the timestep when various fixes that
# compute constraint forces are calculated and potentially modify the force on
# each atom. Examples of such fixes are fix shake, fix wall, and fix indent.

# The order in which various fixes are applied which operate at the same point
# during the timestep, is the same as the order they are specified in the input
# script. Thus normally, if you want to store per-atom forces due to force field
# interactions, before constraints are applied, you should list this fix first
# within that set of fixes, i.e. before other fixes that apply constraints.
# However, if you wish to include certain constraints (e.g. fix shake) in the
# stored force, then it could be specified after some fixes and before others.
{%- endif %}

{%- if use_colvars is sameas true %}
################################################################################
### Collective variables group interface

# variable colvarsFile             index  colvars.inp
# set in lmp_header.lammps

group2ndx colvars.ndx
# https://lammps.sandia.gov/doc/group2ndx.html
# Write or read a Gromacs style index file in text format that associates atom
# IDs with the corresponding group definitions. This index file can be used with
# in combination with Gromacs analysis tools or to import group definitions into
# the fix colvars input file. It can also be used to save and restore group
# definitions for static groups.
#
# The group2ndx command will write group definitions to an index file. Without
# specifying any group IDs, all groups will be written to the index file. When
# specifying group IDs, only those groups will be written to the index file. In
# order to follow the Gromacs conventions, the group all will be renamed to
# System in the index file.

###############################################################################
### Collective variables

fix cv all colvars ${colvars_file} seed ${random_seed} output ${base_name} unwrap yes
#      ^ID ^group (ignored)          ^random seed  ^prefix for all out files
# source: https://lammps.sandia.gov/doc/fix_colvars.html
# This fix interfaces LAMMPS to the collective variables "Colvars" library,
# which allows to calculate potentials of mean force (PMFs) for any set of
# colvars, using different sampling methods: currently implemented are the
# Adaptive Biasing Force (ABF) method, metadynamics, Steered Molecular Dynamics
# (SMD) and Umbrella Sampling (US) via a flexible harmonic restraint bias.

# The group-ID entry is ignored. The collective variable module will always
# apply to the entire system and there can only be one instance of the colvars
# fix at a time. The colvars fix will only communicate the minimum information
# necessary and the colvars library supports multiple, completely independent
# collective variables, so there is no restriction to functionality by limiting
# the number of colvars fixes.

# The input keyword allows to specify a state file that would contain the
# restart information required in order to continue a calculation from a
# prerecorded state. Fix colvars records it state in binary restart files, so
# when using the read_restart command, this is usually not needed. The output
# keyword allows to specify the output prefix. All output files generated will
# use this prefix followed by the ".colvars." and a word like "state" or "traj".

# The seed keyword contains the seed for the random number generator that will
# be used in the colvars module.

# The unwrap keyword controls whether wrapped or unwrapped coordinates are
# passed to the colvars library for calculation of the collective variables and
# the resulting forces. The default is yes, i.e. to use the image flags to
# reconstruct the absolute atom positions. Setting this to no will use the
# current local coordinates that are wrapped back into the simulation cell at
# each re-neighboring instead.

# The tstat keyword can be either NULL or the label of a thermostating fix that
# thermostats all atoms in the fix colvars group. This will be used to provide
# the colvars module with the current thermostat target temperature.
{%- endif %}

{%- if store_forces is sameas true %}
###############################################################################
###  Monitor ante-freeze forces
fix storeAnteFreezeForces all store/force
fix storeAnteFreezeForcesAve all ave/atom 1 ${netcdf_frequency} &
    ${netcdf_frequency} f_storeAnteFreezeForces[*]
{%- endif %}

################################################################################
### con- & restraints
{%- if (has_indenter is sameas true) and (rigid_indenter_core_radius > 0.0) %}
group rigid_part_of_indenter intersect all rigid_indenter_core
{%- elif (has_indenter is sameas true) and (rigid_indenter is sameas true) %}
group rigid_part_of_indenter intersect all indenter
{%- endif %}

# if indenter in system, then either move whole indenter or only frozen core
{%- if (has_indenter is sameas true) and (constant_indenter_velocity != 0.0) and (direction_of_linear_movement == 0) %}
velocity rigid_part_of_indenter set ${constant_indenter_velocity} 0.0 0.0 sum no units box
#                                   ^vx                           ^vy ^vz
{%- elif (has_indenter is sameas true) and (constant_indenter_velocity != 0.0) and (direction_of_linear_movement == 1) %}
velocity rigid_part_of_indenter set 0.0 ${constant_indenter_velocity} 0.0 sum no units box
#                                   ^vx ^vy                           ^vz
{%- elif (has_indenter is sameas true) and (constant_indenter_velocity != 0.0) and (direction_of_linear_movement == 2) %}
velocity rigid_part_of_indenter set 0.0 0.0 ${constant_indenter_velocity} sum no units box
#                                   ^vx ^vy ^vz
{%- endif %}
# The sum keyword is used by all styles, except zero. The new velocities will be
# added to the existing ones if sum = yes, or will replace them if sum = no.
# The units keyword is used by set and ramp. If units = box, the velocities and
# coordinates specified in the velocity command are in the standard units
# described by the units command (e.g. Angstroms/fmsec for real units). If
# units = lattice, velocities are in units of lattice spacings per time (e.g.
# spacings/fmsec) and coordinates are in lattice spacings. The lattice command
# must have been previously used to define the lattice spacing.

# treats indenter rigid, i.e. removes all forces on indenter
# 20190227: doubts about performance of nve/noforce
# 20190228: unjustified, same performance for both options
{%- if (has_indenter is sameas true) and (indenter_nve_noforce is sameas true) and (constant_indenter_velocity != 0.0) %}
fix integrateIndenter rigid_part_of_indenter nve/noforce
{%- elif (has_indenter is sameas true) and (constant_indenter_velocity != 0.0) %}
fix freeze rigid_part_of_indenter setforce 0.0 0.0 0.0
fix integrateIndenter rigid_part_of_indenter nve
{%- elif (has_indenter is sameas true) and (rigid_indenter is sameas true) %}
fix freeze rigid_part_of_indenter setforce 0.0 0.0 0.0
{%- endif %}
# source: https://lammps.sandia.gov/doc/fix_nve_noforce.html
# Perform updates of position, but not velocity for atoms in the group each
# timestep. In other words, the force on the atoms is ignored and their velocity
# is not updated. The atom velocities are used to update their positions.
#
# This can be useful for wall atoms, when you set their velocities, and want the
# wall to move (or stay stationary) in a prescribed fashion.
#
# This can also be accomplished via the fix setforce command, but with fix
# nve/noforce, the forces on the wall atoms are unchanged, and can thus be
# printed by the dump command or queried with an equal-style variable that uses
# the fcm() group function to compute the total force on the group of atoms.

{%- if freeze_substrate_layer is sameas true %}
# Keep substrate layer frozen
velocity frozen_substrate_layer set 0.0 0.0 0.0 sum no units box
fix freeze_substrate_layer frozen_substrate_layer setforce 0.0 0.0 0.0
{%- endif %}

{%- if store_forces is sameas true %}
################################################################################
### Monitor ante-npt-barostatting forces

# store forces before thermo- and barostatting, but after contraints
fix storeAnteStatForces all store/force
fix storeAnteStatForcesAve all ave/atom 1 ${netcdf_frequency} ${netcdf_frequency} f_storeAnteStatForces[*]
{%- endif %}

################################################################################
### THERMOSTAT

# either only temper solid, and only the non-frozen part,
# or everything (except frozen atoms):
{%- if (not is_restart is sameas true) and (temper_solid_only is sameas true) %}
group tempered_group subtract solid frozen
{%- elif (not is_restart is sameas true) and (temper_substrate_only is sameas true) %}
group tempered_group subtract substrate frozen
{%- elif (not is_restart is sameas true) %}
group tempered_group subtract all frozen
{%- endif %}

{%- if not use_dpd_tstat is sameas true %}
# not applying DPD thermostat
fix thermostat tempered_group langevin ${initialT} ${temperatureT} &
    ${langevin_damping} ${random_seed}
#   ^ID        ^group-ID      ^langevin
#                                      ^Tstart     ^Tstop
#   ^damp               ^seed
# source: https://lammps.sandia.gov/doc/fix_langevin.html
# fix ID group-ID langevin Tstart Tstop damp seed keyword values ...
# Apply a Langevin thermostat as described in (Schneider) to a group of atoms
# which models an interaction with a background implicit solvent. Used with
# fix nve, this command performs Brownian dynamics (BD), since the total force
# on each atom will have the form:
#
# F = Fc + Ff + Fr
# Ff = - (m / damp) v
# Fr is proportional to sqrt(Kb T m / (dt damp))
#
# Note that unless you use the omega or angmom keywords, the thermostat effect
# of this fix is applied to only the translational degrees of freedom for the
# particles, which is an important consideration for finite-size particles,
# which have rotational degrees of freedom, are being thermostatted. The
# translational degrees of freedom can also have a bias velocity removed
# from them before thermostatting takes place; see the description below.
#
# Unlike the fix nvt command which performs Nose/Hoover thermostatting
# AND time integration, this fix does NOT perform time integration. It
# only modifies forces to effect thermostatting. Thus you must use a
# separate time integration fix, like fix nve to actually update the
# velocities and positions of atoms using the modified forces. Likewise,
# this fix should not normally be used on atoms that also have their
# temperature controlled by another fix - e.g. by fix nvt or fix
# temp/rescale commands.
#
# The damp parameter is specified in time units and determines how rapidly the
# temperature is relaxed. For example, a value of 100.0 means to relax the
# temperature in a timespan of (roughly) 100 time units (tau or fmsec or psec
# - see the units command). The damp factor can be thought of as inversely
# related to the viscosity of the solvent. I.e. a small relaxation time
# implies a hi-viscosity solvent and vice versa. See the discussion about
# gamma and viscosity in the documentation for the fix viscous command for
# more details.
{%- endif %}

################################################################################
### BAROSTAT

{%- if (not is_restart is sameas true) and (not pressurize_solution_only is sameas true) %}
# the "pressured" group are all atoms, except the frozen ones
group pressured_group subtract all frozen
{%- elif (not is_restart is sameas true) %}
group pressured_group subtract all frozen solid
{%- endif %}

{%- if (not is_restart is sameas true) and (not dilate_solution_only is sameas true) %}
group dilated_group subtract all frozen
{%- elif (not is_restart is sameas true) %}
group dilated_group subtract all frozen solid
{%- endif %}

{%- if (use_berendsen_bstat is sameas true) and (( pbc2d is sameas true) or (has_vacuum is sameas true)) %}
fix barostat pressured_group press/berendsen x ${pressureP} ${pressureP} 100 y ${pressureP} ${pressureP} 100 couple none modulus 2.1e6 dilate partial
{%- elif (use_berendsen_bstat is sameas true) and ( pressurize_z_only is sameas true) %}
fix barostat pressured_group press/berendsen z ${pressureP} ${pressureP} 100 couple none modulus 2.1e6 dilate partial
{%- elif (use_berendsen_bstat is sameas true) %}
fix barostat pressured_group press/berendsen aniso ${pressureP} ${pressureP} 100 modulus 2.1e6 dilate partial
{%- elif (use_barostat is sameas true) and (pressurize_z_only is sameas true) %}
fix barostat pressured_group nph z ${pressureP} ${pressureP} &
    ${barostat_damping} dilate dilated_group fixedpoint $(xlo) $(ylo) $(zlo)
{%- elif (use_barostat is sameas true) %}
fix barostat pressured_group nph aniso ${pressureP} ${pressureP} &
    ${barostat_damping} dilate dilated_group fixedpoint $(xlo) $(ylo) $(zlo)
{%- else %}
fix nve pressured_group nve
# fix nve is necessary for integration if nor barostat is applied
{%- endif %}

# source https://lammps.sandia.gov/doc/fix_nh.html#fix-nph-command
# As with the thermostats, the Nose/Hoover methods (fix npt and fix nph) perform
# time integration. Fix press/berendsen does NOT, so it should be used with one
# of the constant NVE fixes or with one of the NVT fixes.

# In some cases (e.g. for solids) the pressure (volume) and/or temperature of
# the system can oscillate undesirably when a Nose/Hoover barostat and
# thermostat is applied. The optional drag keyword will damp these oscillations,
# although it alters the Nose/Hoover equations. A value of 0.0 (no drag) leaves
# the Nose/Hoover formalism unchanged. A non-zero value adds a drag term; the
# larger the value specified, the greater the damping effect. Performing a short
# run and monitoring the pressure and temperature is the best way to determine
# if the drag term is working. Typically a value between 0.2 to 2.0 is
# sufficient to damp oscillations after a few periods. Note that use of the drag
# keyword will interfere with energy conservation and will also change the
# distribution of positions and velocities so that they do not correspond to the
# nominal NVT, NPT, or NPH ensembles.

################################################################################
### INDENTER AND SUBSTRATE RESTRAINT

{%- if restrain_substrate_layer > 0.0 %}
fix restrain_substrate restrained_substrate_layer momentum 1 linear 1 1 1 angular rescale
{%- endif %}

{%- if (has_indenter is sameas true) and (restrained_indenter is sameas true) %}
fix restrain_indenter indenter momentum 1 linear 1 1 1 angular rescale
#                                       ^N       ^xyz          ^preserve kinetic energy
# source: https://lammps.sandia.gov/doc/fix_momentum.html
# If the linear keyword is used, the linear momentum is zeroed by subtracting
# the center-of-mass velocity of the group from each atom. This does not change
# the relative velocity of any pair of atoms. One or more dimensions can be
# excluded from this operation by setting the corresponding flag to 0.
#
# If the angular keyword is used, the angular momentum is zeroed by subtracting
# a rotational component from each atom.
#
# This command can be used to insure the entire collection of atoms (or a
# subset of them) does not drift or rotate during the simulation due to random
# perturbations (e.g. fix langevin thermostatting).
#
# The rescale keyword enables conserving the kinetic energy of the group of
# atoms by rescaling the velocities after the momentum was removed.
#
# No information about this fix is written to binary restart files. None of the
# fix_modify options are relevant to this fix. No global or per-atom quantities
# are stored by this fix for access by various output commands. No parameter of
# this fix can be used with the start/stop keywords of the run command. This
# fix is not invoked during energy minimization.
{%- endif %}

{%- if (remove_drift is sameas true) or (substrate_recenter is sameas true) %}
################################################################################
### DRIFT REMOVAL

# Keep substrate slab's position COM position fixed, remove relative drift
fix fixedSubstrateCOM frozen_substrate_layer recenter INIT INIT INIT shift all
#   ^ID               ^group-ID
#                                             ^style   ^x   ^y   ^z   ^keyword
#                                                                          ^group
# source: https://lammps.sandia.gov/doc/fix_recenter.html
# fix ID group-ID recenter x y z keyword value ...
#   shift value = group-ID
#     group-ID = group of atoms whose coords are shifted
#
# Constrain the center-of-mass position of a group of atoms by adjusting the
# coordinates of the atoms every timestep. This is simply a small shift that
# does not alter the dynamics of the system or change the relative coordinates
# of any pair of atoms in the group. This can be used to insure the entire
# collection of atoms (or a portion of them) do not drift during the simulation
# due to random perturbations (e.g. fix langevin thermostatting).
#
# The center-of-mass (COM) is computed for the group specified by the fix.
# If the current COM is different than the specified x,y,z, then a group of
# atoms has their coordinates shifted by the difference. By default the shifted
# group is also the group specified by the fix. A different group can be shifted
# by using the shift keyword. For example, the COM could be computed on a
# protein to keep it in the center of the simulation box. But the entire system
# (protein + water) could be shifted.
#
# Distance units for the x,y,z values are determined by the setting of the units
# keyword, as discussed below. One or more x,y,z values can also be specified
# as NULL, which means exclude that dimension from this operation. Or it can be
# specified as INIT which means to constrain the center-of-mass to its initial
# value at the beginning of the run.
{%- endif %}

{%- if store_forces is sameas true %}
################################################################################
### Monitor forces before SHAKE constraint
fix storeAnteShakeForces all store/force
fix storeAnteShakeForcesAve all ave/atom 1 ${netcdf_frequency} &
    ${netcdf_frequency} f_storeAnteShakeForces[*]
{%- endif %}

{%- if rigid_h_bonds is sameas true %}
################################################################################
### RIGID TIP3P WATER and RIGID HYDROGEN BONDS

#
# fix equilibrateNVT all nvt temp ${temperatureT} ${temperatureT} 100 tchain 1
#  WARNING: Fix rattle should come after all other integration fixes
#    (../fix_rattle.cpp:147)
fix rigidHbonds pressured_group rattle 1e-6 500 0 m 1.0 a ${angle_id_water}
# fix rigidHbonds all shake 1e-6 500 0 m 1.0 a ${angle_id_water}

# The b constraint lists bond types that will be constrained.
# The t constraint lists atom types. All bonds connected to an
#  atom of the specified type will be constrained. The m constraint
# lists atom masses. All bonds connected to atoms of the specified
# masses will be constrained (within a fudge factor of MASSDELTA specified
# in fix_shake.cpp). The a constraint lists angle types. If both bonds in
# the angle are constrained then the angle will also be constrained if its
# type is in the list.
# The mentioned MASSDELTA is defined as 0.1 (16Mar18).
# Therefore, all hydrogen
# The fix rattle command modifies forces and velocities and thus should be
# defined after all other integration fixes in your input script. If you
# define other fixes that modify velocities or forces after fix rattle operates,
# then fix rattle will not take them into account and the overall time
# integration will typically not satisfy the RATTLE constraints. You can
# check whether the constraints work correctly by setting the value of
# RATTLE_DEBUG in src/fix_rattle.cpp to 1 and recompiling LAMMPS.
# The degrees-of-freedom removed by SHAKE bonds and angles are accounted for in
# temperature and pressure computations. Similarly, the SHAKE contribution to
# the pressure of the system (virial) is also accounted for.
{%- endif %}

################################################################################
### OUTPUT

{%- if store_forces is sameas true %}
# average final (constrained) forces
fix storeForcesAve all ave/atom 1 ${netcdf_frequency} &
  ${netcdf_frequency} fx fy fz
{%- endif %}

{%- if compute_group_properties is sameas true %}
# average per atom stress
fix peratom_stress_ave all ave/atom &
  1 ${netcdf_frequency} ${netcdf_frequency} c_peratom_stress[*]
{%- endif %}


dump dumpPng nonsolvent image ${png_frequency} ${base_name}.*.png type type

# output format for stored forces:
# col  1 -  5: id mol type position[3]
# col  6 - 17: instantaneous forces:
#  fully_constrained[3] ante_shake[3] ante_stats[3] unconstrained[3]
# col 18 - 26: interval-averaged forces
#  fully_constrained[3] ante_shake[3] ante_stats[3] unconstrained[3]
#
# output cases
#
# index | mpiio     | f_forces  | c_group
# 1     | yes       | yes       | yes
# 2     | yes       | yes       | no
# 3     | yes       | no        | yes
# 4     | yes       | no        | no
# 5     | no        | yes       | yes
# 6     | no        | yes       | no
# 7     | no        | no        | yes
# 8     | no        | no        | no        covers case 4 as well

{%- if (compute_group_properties is sameas true) and (mpiio is sameas true) and (store_forces is sameas true) %}
print 'netcdf/mpiio output, store constrained and unconstrained forces as well as per atom stresses'
dump dumpNetCDF all netcdf/mpiio ${netcdf_frequency} &
  ${base_name}.nc id mol type mass x y z vx vy vz fx fy fz &
   f_storeAnteShakeForces[1]         f_storeAnteShakeForces[2]         f_storeAnteShakeForces[3] &
   f_storeAnteStatForces[1]          f_storeAnteStatForces[2]          f_storeAnteStatForces[3] &
   f_storeAnteFreezeForces[1]        f_storeAnteFreezeForces[2]        f_storeAnteFreezeForces[3] &
   f_storeUnconstrainedForces[1]     f_storeUnconstrainedForces[2]     f_storeUnconstrainedForces[3] &
   f_storeForcesAve[1]               f_storeForcesAve[2]               f_storeForcesAve[3] &
   f_storeAnteShakeForcesAve[1]      f_storeAnteShakeForcesAve[2]      f_storeAnteShakeForcesAve[3] &
   f_storeAnteStatForcesAve[1]       f_storeAnteStatForcesAve[2]       f_storeAnteStatForcesAve[3] &
   f_storeAnteFreezeForcesAve[1]     f_storeAnteFreezeForcesAve[2]     f_storeAnteFreezeForcesAve[3] &
   f_storeUnconstrainedForcesAve[1]  f_storeUnconstrainedForcesAve[2]  f_storeUnconstrainedForcesAve[3] &
   c_peratom_stress[1]               c_peratom_stress[2]               c_peratom_stress[3] &
   f_peratom_stress_ave[1]           f_peratom_stress_ave[2]           f_peratom_stress_ave[3]
{%- elif (mpiio is sameas true) and (store_forces is sameas true) %}
print 'netcdf/mpiio output, store constrained and unconstrained forces'
dump dumpNetCDF all netcdf/mpiio ${netcdf_frequency} &
  ${base_name}.nc id mol type mass x y z vx vy vz fx fy fz &
   f_storeAnteShakeForces[1]         f_storeAnteShakeForces[2]         f_storeAnteShakeForces[3] &
   f_storeAnteStatForces[1]          f_storeAnteStatForces[2]          f_storeAnteStatForces[3] &
   f_storeAnteFreezeForces[1]        f_storeAnteFreezeForces[2]        f_storeAnteFreezeForces[3] &
   f_storeUnconstrainedForces[1]     f_storeUnconstrainedForces[2]     f_storeUnconstrainedForces[3] &
   f_storeForcesAve[1]               f_storeForcesAve[2]               f_storeForcesAve[3] &
   f_storeAnteShakeForcesAve[1]      f_storeAnteShakeForcesAve[2]      f_storeAnteShakeForcesAve[3] &
   f_storeAnteStatForcesAve[1]       f_storeAnteStatForcesAve[2]       f_storeAnteStatForcesAve[3] &
   f_storeAnteFreezeForcesAve[1]     f_storeAnteFreezeForcesAve[2]     f_storeAnteFreezeForcesAve[3] &
   f_storeUnconstrainedForcesAve[1]  f_storeUnconstrainedForcesAve[2]  f_storeUnconstrainedForcesAve[3]
{%- elif (compute_group_properties is sameas true) and (mpiio is sameas true) %}
print 'netcdf/mpiio output, store per atom stresses'
dump dumpNetCDF all netcdf/mpiio ${netcdf_frequency} &
  ${base_name}.nc id mol type mass x y z vx vy vz &
  c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3]
{%- elif mpiio is sameas true %}
print 'netcdf/mpiio output'
dump dumpNetCDF all netcdf/mpiio ${netcdf_frequency} &
  ${base_name}.nc id mol type mass x y z vx vy vz
{%- elif (compute_group_properties is sameas true) and (store_forces is sameas true) %}
print 'netcdf output (no netcdf/mpiiio), store constrained and unconstrained forces as well as per atom stresses'
dump dumpNetCDF all netcdf ${netcdf_frequency} &
  ${base_name}.nc id mol type mass x y z vx vy vz fx fy fz &
   f_storeAnteShakeForces[1]         f_storeAnteShakeForces[2]         f_storeAnteShakeForces[3] &
   f_storeAnteStatForces[1]          f_storeAnteStatForces[2]          f_storeAnteStatForces[3] &
   f_storeAnteFreezeForces[1]        f_storeAnteFreezeForces[2]        f_storeAnteFreezeForces[3] &
   f_storeUnconstrainedForces[1]     f_storeUnconstrainedForces[2]     f_storeUnconstrainedForces[3] &
   f_storeForcesAve[1]               f_storeForcesAve[2]               f_storeForcesAve[3] &
   f_storeAnteShakeForcesAve[1]      f_storeAnteShakeForcesAve[2]      f_storeAnteShakeForcesAve[3] &
   f_storeAnteStatForcesAve[1]       f_storeAnteStatForcesAve[2]       f_storeAnteStatForcesAve[3] &
   f_storeAnteFreezeForcesAve[1]     f_storeAnteFreezeForcesAve[2]     f_storeAnteFreezeForcesAve[3] &
   f_storeUnconstrainedForcesAve[1]  f_storeUnconstrainedForcesAve[2]  f_storeUnconstrainedForcesAve[3] &
   c_peratom_stress[1]               c_peratom_stress[2]               c_peratom_stress[3] &
   f_peratom_stress_ave[1]           f_peratom_stress_ave[2]           f_peratom_stress_ave[3]
{%- elif store_forces is sameas true %}
print 'netcdf output (no netcdf/mpiiio), store constrained and unconstrained forces'
dump dumpNetCDF all netcdf ${netcdf_frequency} &
  ${base_name}.nc id mol type mass x y z vx vy vz fx fy fz &
   f_storeAnteShakeForces[1]         f_storeAnteShakeForces[2]         f_storeAnteShakeForces[3] &
   f_storeAnteStatForces[1]          f_storeAnteStatForces[2]          f_storeAnteStatForces[3] &
   f_storeAnteFreezeForces[1]        f_storeAnteFreezeForces[2]        f_storeAnteFreezeForces[3] &
   f_storeUnconstrainedForces[1]     f_storeUnconstrainedForces[2]     f_storeUnconstrainedForces[3] &
   f_storeForcesAve[1]               f_storeForcesAve[2]               f_storeForcesAve[3] &
   f_storeAnteShakeForcesAve[1]      f_storeAnteShakeForcesAve[2]      f_storeAnteShakeForcesAve[3] &
   f_storeAnteStatForcesAve[1]       f_storeAnteStatForcesAve[2]       f_storeAnteStatForcesAve[3] &
   f_storeAnteFreezeForcesAve[1]     f_storeAnteFreezeForcesAve[2]     f_storeAnteFreezeForcesAve[3] &
   f_storeUnconstrainedForcesAve[1]  f_storeUnconstrainedForcesAve[2]  f_storeUnconstrainedForcesAve[3]
{%- elif compute_group_properties is sameas true %}
print 'netcdf output (no netcdf/mpiiio), store per atom stresses'
dump dumpNetCDF all netcdf ${netcdf_frequency} &
  ${baseName}.nc id mol type mass x y z vx vy vz &
   c_peratom_stress[1] c_peratom_stress[2] c_peratom_stress[3] &
   f_peratom_stress_ave[1]           f_peratom_stress_ave[2]           f_peratom_stress_ave[3]
{%- else %}
print 'netcdf output (no netcdf/mpiiio)'
dump dumpNetCDF all netcdf ${netcdf_frequency} &
  ${baseName}.nc id mol type mass x y z vx vy vz
{%- endif %}
# interestingly, wildcard * operator does not work for dump netcdf


# if variables in custom thermo style (i.e. v_total_press), then
# dump_modify thermo yes caused NetCDF module to throw segmentation fault
{%- if thermo_to_netcdf is sameas true %}
dump_modify dumpNetCDF thermo yes flush yes
{%- else %}
dump_modify dumpNetCDF flush yes
{%- endif %}

# The flush keyword determines whether a flush operation is invoked after a dump
# snapshot is written to the dump file. A flush insures the output in that file
# is current (no buffering by the OS), even if LAMMPS halts before the
# simulation completes. Flushes cannot be performed with dump style xtc.

# The thermo keyword only applies the dump netcdf style. It triggers writing of
# thermo information to the dump file alongside per-atom data. The values
# included in the dump file are identical to the values specified by
# thermo_style.

# What is the purpose of this line?
# if "${store_forces} > 0" then "dump_modify dumpNetCDF append yes"
# https://lammps.sandia.gov/doc/dump_modify.html
# The append keyword applies to all dump styles except cfg and xtc and dcd. It
# also applies only to text output files, not to binary or gzipped or
# image/movie files. If specified as yes, then dump snapshots are appended to
# the end of an existing dump file. If specified as no, then a new dump file
# will be created which will overwrite an existing file with the same name.

{%- if reinitialize_velocities is sameas true %}
velocity pressured_group create ${initialT} ${random_seed} &
  rot yes mom yes dist gaussian
{%- endif %}

{%- if write_groups_to_file is sameas true %}
# groups immediately before run, for debugging
group2ndx ${ndx_file}.transient
{%- endif %}

print "LAMMPS state before production:"
info all
# at 2 fs time step output every 2 ps
run             ${production_steps} upto

{%- if write_coeff_to_datafile is sameas true %}
write_data ${base_name}.lammps
{%- else %}
write_data ${base_name}.lammps nocoeff
{%- endif %}
### end lmp_prodction.input
###############################################################################
{%- endif %}
