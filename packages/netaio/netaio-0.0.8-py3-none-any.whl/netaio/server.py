from .common import (
    Header,
    AuthFields,
    Body,
    Message,
    MessageType,
    HeaderProtocol,
    AuthFieldsProtocol,
    BodyProtocol,
    MessageProtocol,
    AuthPluginProtocol,
    CipherPluginProtocol,
    PeerPluginProtocol,
    Peer,
    keys_extractor,
    make_error_response,
    auth_error_handler,
    Handler,
    AuthErrorHandler,
    DefaultPeerPlugin,
    default_server_logger,
)
from enum import IntEnum
from typing import Callable, Coroutine, Hashable
import asyncio
import logging


def not_found_handler(*_) -> MessageProtocol | None:
    return make_error_response("not found")


class TCPServer:
    """TCP server class."""
    port: int
    interface: str
    local_peer: Peer
    peers: dict[bytes, Peer]
    peer_addrs: dict[tuple[str, int], bytes]
    handlers: dict[Hashable, tuple[Handler, AuthPluginProtocol|None, CipherPluginProtocol|None]]
    default_handler: Handler
    header_class: type[HeaderProtocol]
    message_type_class: type[IntEnum]
    auth_fields_class: type[AuthFieldsProtocol]
    body_class: type[BodyProtocol]
    message_class: type[MessageProtocol]
    extract_keys: Callable[[MessageProtocol], list[Hashable]]
    make_error: Callable[[str], MessageProtocol]
    subscriptions: dict[Hashable, set[asyncio.StreamWriter]]
    clients: set[asyncio.StreamWriter]
    logger: logging.Logger
    auth_plugin: AuthPluginProtocol
    cipher_plugin: CipherPluginProtocol
    handle_auth_error: AuthErrorHandler

    def __init__(
            self, port: int = 8888, interface: str = "0.0.0.0",
            local_peer: Peer = None,
            header_class: type[HeaderProtocol] = Header,
            message_type_class: type[IntEnum] = MessageType,
            auth_fields_class: type[AuthFieldsProtocol] = AuthFields,
            body_class: type[BodyProtocol] = Body,
            message_class: type[MessageProtocol] = Message,
            keys_extractor: Callable[[MessageProtocol], list[Hashable]] = keys_extractor,
            make_error_response: Callable[[str], MessageProtocol] = make_error_response,
            default_handler: Handler = not_found_handler,
            logger: logging.Logger = default_server_logger,
            auth_plugin: AuthPluginProtocol = None,
            cipher_plugin: CipherPluginProtocol = None,
            peer_plugin: PeerPluginProtocol = None,
            auth_error_handler: AuthErrorHandler = auth_error_handler,
        ):
        """Initialize the TCPServer.
            `interface` is the interface to listen on.
            `port` is the port to listen on.
            `local_peer` is the local peer information for this server.
            `header_class`, `auth_fields_class`, `body_class`, and
            `message_class` will be used for sending messages and
            parsing responses.
            `message_type_class` is the class to inject in calls to the
            decode method of the header class.
            `keys_extractor` is a function that extracts the keys from a
            message.
            `make_error_response` is a function that makes an error
            response.
            `default_handler` is the default handler to use for messages
            that do not match any registered handler keys.
            If `auth_plugin` is provided, it will be used to check the
            authenticity/authorization of all received messages and set
            the auth_fields of every sent message.
            If `cipher_plugin` is provided, it will be used to encrypt
            and decrypt all messages.
            If `peer_plugin` is provided, it will be used to encode and
            decode peer data.
            `auth_error_handler` is a function that handles auth errors,
            i.e. when an auth check fails for a received message. If it
            returns a message, that message will be sent as a response
            to the sender of the message that failed the auth check. The
            default handler returns the error message generated by the
            auth plugin and should be replaced if you do not want to
            send error messages for failed auth checks (e.g. if the
            auth plugin is an anti-spam plugin and messages that fail
            the auth check should just be dropped).
        """
        self.interface = interface
        self.port = port
        self.local_peer = local_peer
        self.peers = {}
        self.peer_addrs = {}
        self.handlers = {}
        self.subscriptions = {}
        self.clients = set()
        self.header_class = header_class
        self.message_type_class = message_type_class
        self.auth_fields_class = auth_fields_class
        self.body_class = body_class
        self.message_class = message_class
        self.extract_keys = keys_extractor
        self.make_error = make_error_response
        self.default_handler = default_handler
        self.logger = logger
        self.auth_plugin = auth_plugin
        self.cipher_plugin = cipher_plugin
        self.peer_plugin = peer_plugin or DefaultPeerPlugin()
        self.handle_auth_error = auth_error_handler

    def add_handler(
            self, key: Hashable,
            handler: Handler,
            auth_plugin: AuthPluginProtocol = None,
            cipher_plugin: CipherPluginProtocol = None
        ):
        """Register a handler for a specific key. The handler must
            accept a MessageProtocol object as an argument and return a
            MessageProtocol, None, or a Coroutine that resolves to
            MessageProtocol | None. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the server. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the server. These
            plugins will also be used for preparing any response
            message sent by the handler.
        """
        self.logger.debug("Adding handler for key=%s", key)
        self.handlers[key] = (handler, auth_plugin, cipher_plugin)

    def on(
            self, key: Hashable,
            auth_plugin: AuthPluginProtocol = None,
            cipher_plugin: CipherPluginProtocol = None
        ):
        """Decorator to register a handler for a specific key. The
            handler must accept a MessageProtocol object as an argument
            and return a MessageProtocol, None, or a Coroutine that
            resolves to a MessageProtocol or None. If an auth plugin is
            provided, it will be used to check the message in addition
            to any auth plugin that is set on the server. If a cipher
            plugin is provided, it will be used to decrypt the message in
            addition to any cipher plugin that is set on the server.
            These plugins will also be used for preparing any response
            message sent by the handler.
        """
        def decorator(func: Handler):
            self.add_handler(key, func, auth_plugin, cipher_plugin)
            return func
        return decorator

    def remove_handler(self, key: Hashable):
        """Remove a handler for a specific key."""
        self.logger.debug("Removing handler for key=%s", key)
        if key in self.handlers:
            del self.handlers[key]

    def subscribe(self, key: Hashable, writer: asyncio.StreamWriter):
        """Subscribe a client to a specific key. The key must be a
            Hashable object.
        """
        self.logger.debug("Subscribing client to key=%s", key)
        if key not in self.subscriptions:
            self.subscriptions[key] = set()
        self.subscriptions[key].add(writer)

    def unsubscribe(self, key: Hashable, writer: asyncio.StreamWriter):
        """Unsubscribe a client from a specific key. If no subscribers
            are left, the key will be removed from the subscriptions
            dictionary.
        """
        self.logger.debug("Unsubscribing client from key=%s", key)
        if key in self.subscriptions:
            self.subscriptions[key].remove(writer)
            if not self.subscriptions[key]:
                del self.subscriptions[key]

    async def handle_client(
            self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter,
            use_auth: bool = True, use_cipher: bool = True
        ):
        """Handle a client connection. When a client connects, it is
            added to the clients set. The client is then read from using
            the receive method coroutine until the connection is lost.
            The receive method calls the proper handlers if they are
            defined and the message is valid. If use_auth is False, the
            auth plugin set on the server will not be used. If
            use_cipher is False, the cipher plugin set on the server
            will not be used.
        """
        addr = writer.get_extra_info("peername")
        self.logger.info("Client connected from %s", addr)
        self.clients.add(writer)

        try:
            while True:
                await self.receive(reader, writer, use_auth, use_cipher)
        except asyncio.IncompleteReadError:
            self.logger.info("Client disconnected from %s", addr)
            pass  # Client disconnected
        except ConnectionResetError:
            self.logger.info("Client disconnected from %s", addr)
            pass  # Client disconnected
        except Exception as e:
            self.logger.error("Error handling client:", exc_info=True)
        finally:
            self.logger.info("Removing closed client %s", addr)
            self.clients.discard(writer)
            for key, subscribers in list(self.subscriptions.items()):
                if writer in subscribers:
                    subscribers.discard(writer)
                    if not subscribers:
                        del self.subscriptions[key]
            writer.close()
            await writer.wait_closed()

    async def receive(
            self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter,
            use_auth: bool = True, use_cipher: bool = True,
        ):
        """Receive and process a message from a client. Used by the
            handle_client coroutine. Calls the proper handlers if they
            are defined and the message is valid. If use_auth is False,
            the auth plugin set on the server will not be used. If
            use_cipher is False, the cipher plugin set on the server
            will not be used.
        """
        addr = writer.get_extra_info("peername")
        self.logger.info("Client connected from %s", addr)
        self.clients.add(writer)
        header_length = self.header_class.header_length()
        peer_id = self.peer_addrs.get(addr, None)
        peer = self.peers.get(peer_id, None)
        auth_plugin = None
        cipher_plugin = None
        header_bytes = await reader.readexactly(header_length)
        header: HeaderProtocol = self.header_class.decode(
            header_bytes,
            message_type_factory=self.message_type_class
        )

        auth_bytes = await reader.readexactly(header.auth_length)
        auth: AuthFieldsProtocol = self.auth_fields_class.decode(auth_bytes)

        body_bytes = await reader.readexactly(header.body_length)
        body: BodyProtocol = self.body_class.decode(body_bytes)

        message: MessageProtocol = self.message_class(
            header=header,
            auth_data=auth,
            body=body
        )
        self.logger.debug(
            "Received message with checksum=%s from %s",
            message.header.checksum, addr
        )

        if not message.check():
            self.logger.debug(
                "Invalid message received from %s",
                addr
            )
            response = self.make_error("invalid message")
        else:
            # outer auth
            if use_auth and self.auth_plugin is not None:
                self.logger.debug("Calling self.auth_plugin.check on auth and body")
                check = self.auth_plugin.check(
                    message.auth_data, message.body, self, peer,
                    self.peer_plugin
                )
                if not check:
                    self.logger.warning(
                        "Invalid auth_fields received from %s", addr
                    )
                    response = self.handle_auth_error(self, self.auth_plugin, message)
                    if response is not None:
                        await self.send(writer, response, use_auth=False, use_cipher=False)
                        response = None # prevent double sending
                    return
                else:
                    self.logger.debug(
                        "Valid auth_fields received from %s", addr
                    )

            # outer cipher
            if use_cipher and self.cipher_plugin is not None:
                self.logger.debug(
                    "Calling self.cipher_plugin.decrypt on message"
                )
                try:
                    message = self.cipher_plugin.decrypt(
                        message, self, peer, self.peer_plugin
                    )
                except Exception as e:
                    self.logger.warning(
                        "Error decrypting message; dropping",
                        exc_info=True
                    )
                    return

            keys = self.extract_keys(message)
            self.logger.debug(
                "Message received from %s with keys=%s", addr, keys
            )

            for key in keys:
                if key in self.handlers:
                    handler, auth_plugin, cipher_plugin = self.handlers[key]

                    # inner auth
                    if auth_plugin is not None:
                        self.logger.debug(
                            "Calling auth_plugin.check on auth and body"
                        )
                        check = auth_plugin.check(
                            message.auth_data, message.body, self, peer,
                            self.peer_plugin
                        )
                        if not check:
                            self.logger.warning(
                                "Invalid auth_fields received from %s",
                                addr
                            )
                            response = self.handle_auth_error(
                                self, auth_plugin, message
                            )
                            if response is not None:
                                await self.send(
                                    writer, response, use_auth=False,
                                    use_cipher=False
                                )
                                response = None # prevent double sending
                                break

                    # inner cipher
                    if cipher_plugin is not None:
                        self.logger.debug(
                            "Calling cipher_plugin.decrypt on message"
                        )
                        try:
                            message = cipher_plugin.decrypt(
                                message, self, peer, self.peer_plugin
                            )
                        except Exception as e:
                            self.logger.warning(
                                "Error decrypting message; dropping",
                                exc_info=True
                            )
                            return

                    self.logger.debug("Calling handler for key=%s", key)
                    response = handler(message, writer)
                    if isinstance(response, Coroutine):
                        response = await response
                    break
            else:
                self.logger.warning(
                    "No handler found for keys=%s, calling default handler",
                    keys
                )
                response = self.default_handler(message, writer)

        if response is not None:
            # inner cipher
            if cipher_plugin is not None:
                self.logger.debug(
                    "Calling cipher_plugin.encrypt on response (handler)"
                )
                response = cipher_plugin.encrypt(
                    response, self, peer, self.peer_plugin
                )

            # inner auth
            if auth_plugin is not None:
                self.logger.debug(
                    "Calling auth_plugin.make on response.body (handler)"
                )
                auth_plugin.make(
                    response.auth_data, response.body, self, peer,
                    self.peer_plugin
                )

            # outer cipher
            if use_cipher and self.cipher_plugin is not None:
                self.logger.debug(
                    "Calling cipher_plugin.encrypt on response"
                )
                response = self.cipher_plugin.encrypt(
                    response, self, peer, self.peer_plugin
                )

            # outer auth
            if use_auth and self.auth_plugin is not None:
                self.logger.debug(
                    "Calling self.auth_plugin.make on response.body"
                )
                self.auth_plugin.make(
                    response.auth_data, response.body, self, peer,
                    self.peer_plugin
                )

            await self.send(
                writer, response, use_auth=False, use_cipher=False
            )

    async def start(self, use_auth: bool = True, use_cipher: bool = True):
        """Start the server."""
        server = await asyncio.start_server(
            lambda r, w: self.handle_client(r, w, use_auth, use_cipher),
            self.interface, self.port
        )
        async with server:
            self.logger.info(f"Server started on {self.interface}:{self.port}")
            await server.serve_forever()

    def prepare_message(
        self, message: MessageProtocol, use_auth: bool = True,
        use_cipher: bool = True, auth_plugin: AuthPluginProtocol|None = None,
        cipher_plugin: CipherPluginProtocol|None = None, peer: Peer|None = None,
    ) -> MessageProtocol|None:
        """Prepares a message for transmission by invoking all necessary
            plugins.
        """
        # inner cipher
        if cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.encrypt on message")
            try:
                message = cipher_plugin.encrypt(
                    message, self, peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error encrypting message; dropping", exc_info=True
                )
                return

        # inner auth
        if auth_plugin is not None:
            self.logger.debug("Calling auth_plugin.make on auth_data and body")
            try:
                auth_plugin.make(
                    message.auth_data, message.body, self, peer,
                    self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error making message; dropping", exc_info=True
                )
                return

        # outer cipher
        if use_cipher and self.cipher_plugin is not None:
            self.logger.debug("Calling self.cipher_plugin.encrypt on message")
            try:
                message = self.cipher_plugin.encrypt(
                    message, self, peer, self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error encrypting message; dropping", exc_info=True
                )
                return

        # outer auth
        if use_auth and self.auth_plugin is not None:
            self.logger.debug(
                "Calling self.auth_plugin.make on auth_data and body"
            )
            try:
                self.auth_plugin.make(
                    message.auth_data, message.body, self, peer,
                    self.peer_plugin
                )
            except Exception as e:
                self.logger.warning(
                    "Error making message; dropping", exc_info=True
                )
                return

        return message

    async def send(
            self, client: asyncio.StreamWriter, message: MessageProtocol,
            collection: set = None, use_auth: bool = True,
            use_cipher: bool = True, auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Helper coroutine to send a message to a client. On error, it
            logs the exception and removes the client from the given
            collection. If an auth plugin is provided, it will be used
            to authorize the message in addition to any auth plugin that
            is set on the server. If a cipher plugin is provided, it
            will be used to encrypt the message in addition to any
            cipher plugin that is set on the server. If use_auth is
            False, the auth plugin set on the server will not be used.
            If use_cipher is False, the cipher plugin set on the
            server will not be used.
        """
        addr = client.get_extra_info("peername")
        peer_id = self.peer_addrs.get(addr, None)
        peer = self.peers.get(peer_id, None)
        message = self.prepare_message(
            message, use_auth=use_auth, use_cipher=use_cipher,
            auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
            peer=peer,
        )
        if not message:
            return

        try:
            self.logger.debug("Sending message to %s", addr)
            client.write(message.encode())
            await client.drain()
        except Exception as e:
            self.logger.error("Error sending to client:", exc_info=True)
            if collection is not None:
                self.logger.info("Removing client %s from collection", addr)
                collection.discard(client)

    async def broadcast(
            self, message: MessageProtocol, use_auth: bool = True,
            use_cipher: bool = True, auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send the message to all connected clients concurrently using
            asyncio.gather. If an auth plugin is provided, it will be
            used to authorize the message in addition to any auth plugin
            that is set on the server. If a cipher plugin is provided,
            it will be used to encrypt the message in addition to any
            cipher plugin that is set on the server. If use_auth is
            False, the auth plugin set on the server will not be used. If
            use_cipher is False, the cipher plugin set on the
            server will not be used.
        """
        self.logger.debug("Broadcasting message to all clients")

        # check if any plugin is peer-specific
        peer_specific = False
        if use_auth and self.auth_plugin and self.auth_plugin.is_peer_specific():
            peer_specific = True
        if use_cipher and self.cipher_plugin and self.cipher_plugin.is_peer_specific():
            peer_specific = True
        if auth_plugin and auth_plugin.is_peer_specific():
            peer_specific = True
        if cipher_plugin and cipher_plugin.is_peer_specific():
            peer_specific = True

        if peer_specific:
            # for peer-specific plugins, send unique message to each client
            tasks = [
                self.send(
                    client, message.copy(), collection=self.clients,
                    use_auth=use_auth, use_cipher=use_cipher,
                    auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
                )
                for client in self.clients
            ]
        else:
            # optimize for non-peer-specific plugins by doing all calculations once
            message = self.prepare_message(
                message, use_auth=use_auth, use_cipher=use_cipher,
                auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
            )
            if not message:
                return
            # create coroutines
            tasks = [
                self.send(
                    client, message, collection=self.clients,
                    use_auth=False, use_cipher=False,
                )
                for client in self.clients
            ]
        await asyncio.gather(*tasks, return_exceptions=True)

    async def notify(
            self, key: Hashable, message: MessageProtocol, use_auth: bool = True,
            use_cipher: bool = True, auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send the message to all subscribed clients for the given key
            concurrently using asyncio.gather. If an auth plugin is
            provided, it will be used to authorize the message in
            addition to any auth plugin that is set on the server. If a
            cipher plugin is provided, it will be used to encrypt the
            message in addition to any cipher plugin that is set on
            the server. If use_auth is False, the auth plugin set on the
            server will not be used. If use_cipher is False, the
            cipher plugin set on the server will not be used.
        """
        if key not in self.subscriptions:
            self.logger.debug(
                "No subscribers found for key=%s, skipping notification", key
            )
            return

        subscribers = self.subscriptions.get(key, set())
        if not subscribers:
            self.logger.debug(
                "No subscribers found for key=%s, removing from subscriptions",
                key
            )
            del self.subscriptions[key]
            return

        self.logger.debug("Notifying %d clients for key=%s", len(subscribers), key)

        # check if any plugin is peer-specific
        peer_specific = False
        if use_auth and self.auth_plugin.is_peer_specific():
            peer_specific = True
        if use_cipher and self.cipher_plugin.is_peer_specific():
            peer_specific = True
        if auth_plugin and auth_plugin.is_peer_specific():
            peer_specific = True
        if cipher_plugin and cipher_plugin.is_peer_specific():
            peer_specific = True

        if peer_specific:
            # for peer-specific plugins, send unique message to each client
            tasks = [
                self.send(
                    client, message.copy(), collection=self.clients,
                    use_auth=use_auth, use_cipher=use_cipher,
                    auth_plugin=auth_plugin, cipher_plugin=cipher_plugin
                )
                for client in subscribers
            ]
        else:
            # optimize for non-peer-specific plugins by doing all calculations once
            message = self.prepare_message(
                message, use_auth=use_auth, use_cipher=use_cipher,
                auth_plugin=auth_plugin, cipher_plugin=cipher_plugin,
            )
            if not message:
                return
            # create coroutines
            tasks = [
                self.send(
                    client, message, collection=self.clients,
                    use_auth=False, use_cipher=False,
                )
                for client in subscribers
            ]

        await asyncio.gather(*tasks, return_exceptions=True)

        self.logger.debug("Notified %d clients for key=%s", len(subscribers), key)

    def add_or_update_peer(
            self, peer_id: bytes, peer_data: bytes, addr: tuple[str, int]
        ) -> bool:
        """Add or update a peer in the peer list. If the peer is the
            local peer, it will not be added to the peer list. Returns
            True if a PEER_DISCOVERED message should be sent (False if
            it is the local peer).
        """
        if peer_id == self.local_peer.id:
            self.logger.debug("Ignoring local peer.")
            return False
        if peer_id in self.peers:
            self.logger.debug(
                "Updating peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id].update(peer_data)
            self.peers[peer_id].addrs.add(addr)
        else:
            self.logger.debug(
                "Adding peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id] = Peer({addr}, peer_id, peer_data)
        self.peer_addrs[addr] = peer_id
        return True

    def get_peer(
            self, addr: tuple[str, int]|None = None, peer_id: bytes|None = None
        ) -> Peer|None:
        """Get a peer from the peer list if addr or peer_id is provided
            and if it exists. Prefers peer_id if both are provided but
            will fall back to addr if the provided peer_id is not found.
        """
        peer = None
        if peer_id is not None:
            peer = self.peers.get(peer_id, None)
        if addr is not None and peer is None:
            peer_id = self.peer_addrs.get(addr, None)
            peer = self.peers.get(peer_id, None)
        return peer

    def remove_peer(self, writer: asyncio.StreamWriter, peer_id: bytes):
        """Remove a peer from the peer list and all related subscriptions."""
        addr = writer.get_extra_info("peername")
        self.logger.debug(
            "Removing peer 0x%s at %s from peer list", peer_id.hex(), addr
        )
        if peer_id in self.peers:
            peer = self.peers[peer_id]
            del self.peers[peer_id]
            for addr in peer.addrs:
                if addr in self.subscriptions:
                    del self.subscriptions[addr]
        if addr in self.peer_addrs:
            del self.peer_addrs[addr]
        for key in self.subscriptions:
            if writer in self.subscriptions[key]:
                self.subscriptions[key].remove(writer)

    async def manage_peers_automatically(
            self, app_id: bytes = b'netaio',
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Begins automatic peer management. This registers 3 handlers:
            1) for the 'ADVERTISE_PEER' message, which will add the peer
            to the peer list and send a 'PEER_DISCOVERED' message to
            reciprocate; 2) for the 'PEER_DISCOVERED' message type which
            will add the peer to the peer list; and 3) for the
            'DISCONNECT' message which will remove the peer from the
            local peer list. Then, it will send an 'ADVERTISE_PEER'
            message to each client that has already connected to it. For
            new connections, the client is expected to introduce itself
            before the server responds with its peer data; it will not
            send an 'ADVERTISE_PEER' message to newly connected clients.
            Raises AssertionError if `local_peer` is not set or if the
            message_type_class does not contain 'ADVERTISE_PEER',
            'PEER_DISCOVERED', and 'DISCONNECT' message types.
        """
        # preconditions
        assert self.local_peer is not None
        assert hasattr(self.message_type_class, 'ADVERTISE_PEER')
        assert hasattr(self.message_type_class, 'PEER_DISCOVERED')
        assert hasattr(self.message_type_class, 'DISCONNECT')

        # create the handlers
        @self.on((self.message_type_class.ADVERTISE_PEER, app_id), auth_plugin, cipher_plugin)
        def handle_advertise_peer(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received ADVERTISE_PEER message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring ADVERTISE_PEER message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content)
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            if not self.add_or_update_peer(peer.id, peer.data, addr):
                return

            # prepare the response
            return self.message_class.prepare(
                self.body_class.prepare(
                    self.peer_plugin.pack(self.local_peer),
                    app_id
                ),
                self.message_type_class.PEER_DISCOVERED
            )

        @self.on((self.message_type_class.PEER_DISCOVERED, app_id), auth_plugin, cipher_plugin)
        def handle_peer_discovered(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received PEER_DISCOVERED message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring PEER_DISCOVERED message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content)
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            self.add_or_update_peer(peer.id, peer.data, addr)

        @self.on((self.message_type_class.DISCONNECT, app_id), auth_plugin, cipher_plugin)
        def handle_disconnect(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received DISCONNECT message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring DISCONNECT message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content)
            except Exception as e:
                self.logger.error("Error unpacking peer id: %s", e)
                return

            self.remove_peer(writer, peer.id)

    async def stop_peer_management(self, app_id: bytes = b'netaio'):
        """Stops automatic peer management by removing the handlers."""
        self.remove_handler((self.message_type_class.ADVERTISE_PEER, app_id))
        self.remove_handler((self.message_type_class.PEER_DISCOVERED, app_id))
        self.remove_handler((self.message_type_class.DISCONNECT, app_id))

    def set_logger(self, logger: logging.Logger):
        """Replace the current logger."""
        self.logger = logger
