# netaio

## Classes

### `TCPClient`

TCP client class.

#### Annotations

- hosts: dict[tuple[str, int], tuple[asyncio.streams.StreamReader,
asyncio.streams.StreamWriter]]
- default_host: tuple[str, int]
- port: <class 'int'>
- local_peer: <class 'netaio.common.Peer'>
- peers: dict[bytes, netaio.common.Peer]
- peer_addrs: dict[tuple[str, int], bytes]
- header_class: type[netaio.common.HeaderProtocol]
- message_type_class: type[enum.IntEnum]
- auth_fields_class: type[netaio.common.AuthFieldsProtocol]
- body_class: type[netaio.common.BodyProtocol]
- message_class: type[netaio.common.MessageProtocol]
- handlers: dict[typing.Hashable,
tuple[typing.Callable[[netaio.common.MessageProtocol,
asyncio.streams.StreamWriter], typing.Union[netaio.common.MessageProtocol,
NoneType, typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol
| None]]], netaio.common.AuthPluginProtocol | None,
netaio.common.CipherPluginProtocol | None]]
- extract_keys: typing.Callable[[netaio.common.MessageProtocol],
list[typing.Hashable]]
- logger: <class 'logging.Logger'>
- auth_plugin: <class 'netaio.common.AuthPluginProtocol'>
- cipher_plugin: <class 'netaio.common.CipherPluginProtocol'>
- peer_plugin: <class 'netaio.common.PeerPluginProtocol'>
- handle_auth_error: typing.Callable[[netaio.common.NetworkNodeProtocol,
netaio.common.AuthPluginProtocol, netaio.common.MessageProtocol | None],
netaio.common.MessageProtocol | None]

#### Methods

##### `__init__(host: str = '127.0.0.1', port: int = 8888, local_peer: Peer = None, header_class: type = Header, message_type_class: type = <enum 'MessageType'>, auth_fields_class: type = AuthFields, body_class: type = Body, message_class: type = Message, extract_keys: Callable = <function keys_extractor at 0x79d6fbdda9e0>, logger: Logger = <Logger netaio.client (INFO)>, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None, peer_plugin: PeerPluginProtocol = None, auth_error_handler: Callable = <function auth_error_handler at 0x79d6fbbc4940>):`

Initialize the TCPClient. `host` is the default host IPv4 address to connect to.
`port` is the default port to connect to. `local_peer` is the local peer
information for this client. `header_class`, `auth_fields_class`, `body_class`,
and `message_class` will be used for sending messages and parsing responses.
`message_type_class` is the class to inject in calls to the decode method of the
header class. `extract_keys` is a function that extracts the keys from a
message. If `auth_plugin` is provided, it will be used to check the
authenticity/authorization of all received messages and set the auth_fields of
every sent message. If `cipher_plugin` is provided, it will be used to encrypt
and decrypt all messages. If `peer_plugin` is provided, it will be used to
encode and decode peer data. `auth_error_handler` is a function that handles
auth errors, i.e. when an auth check fails for a received message. If it returns
a message, that message will be sent as a response to the sender of the message
that failed the auth check. The default handler returns the error message
generated by the auth plugin and should be replaced if you do not want to send
error messages for failed auth checks (e.g. if the auth plugin is an anti-spam
plugin and messages that fail the auth check should just be dropped).

##### `add_handler(key: Hashable, handler: Callable, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Register a handler for a specific key. The handler must accept a MessageProtocol
object as an argument and return MessageProtocol, None, or a Coroutine that
resolves to MessageProtocol | None. If an auth plugin is provided, it will be
used to check the message in addition to any auth plugin that is set on the
client. If a cipher plugin is provided, it will be used to decrypt the message
in addition to any cipher plugin that is set on the client.

##### `on(key: Hashable, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Decorator to register a handler for a specific key. The handler must accept a
MessageProtocol object as an argument and return a MessageProtocol, None, or a
Coroutine that resolves to a MessageProtocol or None. If an auth plugin is
provided, it will be used to check the message in addition to any auth plugin
that is set on the client. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the client.

##### `remove_handler(key: Hashable):`

Remove a handler for a specific key.

##### `async connect(host: str = None, port: int = None):`

Connect to a server.

##### `async send(message: MessageProtocol, server: tuple = None, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Send a message to the server. If use_auth is True and an auth plugin is set, it
will be called to set the auth fields on the message. If an auth plugin is
provided, it will be used to authorize the message in addition to any auth
plugin that is set on the client. If a cipher plugin is provided, it will be
used to encrypt the message in addition to any cipher plugin that is set on the
client. If use_auth is False, the auth plugin set on the client will not be
used. If use_cipher is False, the cipher plugin set on the client will not be
used.

##### `async receive_once(server: tuple = None, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None) -> netaio.common.MessageProtocol | None:`

Receive a message from the server. If a handler was registered for the message
key, the handler will be called with the message as an argument, and the result
will be returned if it is not None; otherwise, the received message will be
returned. If the message checksum fails, the message will be discarded and None
will be returned. If an auth plugin is set, it will be checked before the
message handler is called, and if the check fails, the message will be discarded
and None will be returned. If use_auth is False, the auth plugin set on the
client will not be used. If use_cipher is False, the cipher plugin set on the
client will not be used. If an auth plugin is provided, it will be used to check
the message in addition to any auth plugin that is set on the client. If a
cipher plugin is provided, it will be used to decrypt the message in addition to
any cipher plugin that is set on the client.

##### `async receive_loop(server: tuple = None, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Receive messages from the server indefinitely. Use with asyncio.create_task() to
run concurrently, then use task.cancel() to stop. If use_auth is False, the auth
plugin set on the client will not be used. If use_cipher is False, the cipher
plugin set on the client will not be used. If an auth plugin is provided, it
will be used to check the message in addition to any auth plugin that is set on
the client. If a cipher plugin is provided, it will be used to decrypt the
message in addition to any cipher plugin that is set on the client.

##### `async close(server: tuple = None):`

Close the connection to the server.

##### `add_or_update_peer(peer_id: bytes, peer_data: bytes, addr: tuple) -> bool:`

Add or update a peer in the peer list. If the peer is the local peer, it will
not be added to the peer list. Returns True if a PEER_DISCOVERED message should
be sent (False if it is the local peer).

##### `get_peer(addr: tuple[str, int] | None = None, peer_id: bytes | None = None) -> netaio.common.Peer | None:`

Get a peer from the peer list if addr or peer_id is provided and if it exists.
Prefers peer_id if both are provided but will fall back to addr if the provided
peer_id is not found.

##### `remove_peer(addr: tuple, peer_id: bytes):`

Remove a peer from the peer list.

##### `async manage_peers_automatically(app_id: bytes = b'netaio', auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Begins automatic peer management: when the client connects to a server, it will
send its local_peer data. This also registers 3 handlers: 1) for the
'ADVERTISE_PEER' message, which will add the peer to the peer list and send a
'PEER_DISCOVERED' message to reciprocate; 2) for the 'PEER_DISCOVERED' message
type which will add the peer to the peer list; and 3) for the 'DISCONNECT'
message which will remove the peer from the local peer list. Then, it will send
an 'ADVERTISE_PEER' message to each server it has already connected to. Raises
AssertionError if `local_peer` is not set or if the message_type_class does not
contain 'ADVERTISE_PEER', 'PEER_DISCOVERED', and 'DISCONNECT' message types.

##### `async stop_peer_management(app_id: bytes = b'netaio'):`

Stops automatic peer management by disabling the feature, sending a DISCONNECT
message, and removing the handlers.

##### `set_logger(logger: Logger):`

Replace the current logger.

### `TCPServer`

TCP server class.

#### Annotations

- port: <class 'int'>
- interface: <class 'str'>
- local_peer: <class 'netaio.common.Peer'>
- peers: dict[bytes, netaio.common.Peer]
- peer_addrs: dict[tuple[str, int], bytes]
- handlers: dict[typing.Hashable,
tuple[typing.Callable[[netaio.common.MessageProtocol,
asyncio.streams.StreamWriter], typing.Union[netaio.common.MessageProtocol,
NoneType, typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol
| None]]], netaio.common.AuthPluginProtocol | None,
netaio.common.CipherPluginProtocol | None]]
- default_handler: typing.Callable[[netaio.common.MessageProtocol,
asyncio.streams.StreamWriter], typing.Union[netaio.common.MessageProtocol,
NoneType, typing.Coroutine[typing.Any, typing.Any, netaio.common.MessageProtocol
| None]]]
- header_class: type[netaio.common.HeaderProtocol]
- message_type_class: type[enum.IntEnum]
- auth_fields_class: type[netaio.common.AuthFieldsProtocol]
- body_class: type[netaio.common.BodyProtocol]
- message_class: type[netaio.common.MessageProtocol]
- extract_keys: typing.Callable[[netaio.common.MessageProtocol],
list[typing.Hashable]]
- make_error: typing.Callable[[str], netaio.common.MessageProtocol]
- subscriptions: dict[typing.Hashable, set[asyncio.streams.StreamWriter]]
- clients: set[asyncio.streams.StreamWriter]
- logger: <class 'logging.Logger'>
- auth_plugin: <class 'netaio.common.AuthPluginProtocol'>
- cipher_plugin: <class 'netaio.common.CipherPluginProtocol'>
- handle_auth_error: typing.Callable[[netaio.common.NetworkNodeProtocol,
netaio.common.AuthPluginProtocol, netaio.common.MessageProtocol | None],
netaio.common.MessageProtocol | None]

#### Methods

##### `__init__(port: int = 8888, interface: str = '0.0.0.0', local_peer: Peer = None, header_class: type = Header, message_type_class: type = <enum 'MessageType'>, auth_fields_class: type = AuthFields, body_class: type = Body, message_class: type = Message, keys_extractor: Callable = <function keys_extractor at 0x79d6fbdda9e0>, make_error_response: Callable = <function make_error_response at 0x79d6fbbc48b0>, default_handler: Callable = <function not_found_handler at 0x79d6fbbc5240>, logger: Logger = <Logger netaio.server (INFO)>, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None, peer_plugin: PeerPluginProtocol = None, auth_error_handler: Callable = <function auth_error_handler at 0x79d6fbbc4940>):`

Initialize the TCPServer. `interface` is the interface to listen on. `port` is
the port to listen on. `local_peer` is the local peer information for this
server. `header_class`, `auth_fields_class`, `body_class`, and `message_class`
will be used for sending messages and parsing responses. `message_type_class` is
the class to inject in calls to the decode method of the header class.
`keys_extractor` is a function that extracts the keys from a message.
`make_error_response` is a function that makes an error response.
`default_handler` is the default handler to use for messages that do not match
any registered handler keys. If `auth_plugin` is provided, it will be used to
check the authenticity/authorization of all received messages and set the
auth_fields of every sent message. If `cipher_plugin` is provided, it will be
used to encrypt and decrypt all messages. If `peer_plugin` is provided, it will
be used to encode and decode peer data. `auth_error_handler` is a function that
handles auth errors, i.e. when an auth check fails for a received message. If it
returns a message, that message will be sent as a response to the sender of the
message that failed the auth check. The default handler returns the error
message generated by the auth plugin and should be replaced if you do not want
to send error messages for failed auth checks (e.g. if the auth plugin is an
anti-spam plugin and messages that fail the auth check should just be dropped).

##### `add_handler(key: Hashable, handler: Callable, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Register a handler for a specific key. The handler must accept a MessageProtocol
object as an argument and return a MessageProtocol, None, or a Coroutine that
resolves to MessageProtocol | None. If an auth plugin is provided, it will be
used to check the message in addition to any auth plugin that is set on the
server. If a cipher plugin is provided, it will be used to decrypt the message
in addition to any cipher plugin that is set on the server. These plugins will
also be used for preparing any response message sent by the handler.

##### `on(key: Hashable, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Decorator to register a handler for a specific key. The handler must accept a
MessageProtocol object as an argument and return a MessageProtocol, None, or a
Coroutine that resolves to a MessageProtocol or None. If an auth plugin is
provided, it will be used to check the message in addition to any auth plugin
that is set on the server. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the server.
These plugins will also be used for preparing any response message sent by the
handler.

##### `remove_handler(key: Hashable):`

Remove a handler for a specific key.

##### `subscribe(key: Hashable, writer: StreamWriter):`

Subscribe a client to a specific key. The key must be a Hashable object.

##### `unsubscribe(key: Hashable, writer: StreamWriter):`

Unsubscribe a client from a specific key. If no subscribers are left, the key
will be removed from the subscriptions dictionary.

##### `async handle_client(reader: StreamReader, writer: StreamWriter, use_auth: bool = True, use_cipher: bool = True):`

Handle a client connection. When a client connects, it is added to the clients
set. The client is then read from using the receive method coroutine until the
connection is lost. The receive method calls the proper handlers if they are
defined and the message is valid. If use_auth is False, the auth plugin set on
the server will not be used. If use_cipher is False, the cipher plugin set on
the server will not be used.

##### `async receive(reader: StreamReader, writer: StreamWriter, use_auth: bool = True, use_cipher: bool = True):`

Receive and process a message from a client. Used by the handle_client
coroutine. Calls the proper handlers if they are defined and the message is
valid. If use_auth is False, the auth plugin set on the server will not be used.
If use_cipher is False, the cipher plugin set on the server will not be used.

##### `async start(use_auth: bool = True, use_cipher: bool = True):`

Start the server.

##### `prepare_message(message: MessageProtocol, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None, peer: netaio.common.Peer | None = None) -> netaio.common.MessageProtocol | None:`

Prepares a message for transmission by invoking all necessary plugins.

##### `async send(client: StreamWriter, message: MessageProtocol, collection: set = None, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Helper coroutine to send a message to a client. On error, it logs the exception
and removes the client from the given collection. If an auth plugin is provided,
it will be used to authorize the message in addition to any auth plugin that is
set on the server. If a cipher plugin is provided, it will be used to encrypt
the message in addition to any cipher plugin that is set on the server. If
use_auth is False, the auth plugin set on the server will not be used. If
use_cipher is False, the cipher plugin set on the server will not be used.

##### `async broadcast(message: MessageProtocol, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Send the message to all connected clients concurrently using asyncio.gather. If
an auth plugin is provided, it will be used to authorize the message in addition
to any auth plugin that is set on the server. If a cipher plugin is provided, it
will be used to encrypt the message in addition to any cipher plugin that is set
on the server. If use_auth is False, the auth plugin set on the server will not
be used. If use_cipher is False, the cipher plugin set on the server will not be
used.

##### `async notify(key: Hashable, message: MessageProtocol, use_auth: bool = True, use_cipher: bool = True, auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Send the message to all subscribed clients for the given key concurrently using
asyncio.gather. If an auth plugin is provided, it will be used to authorize the
message in addition to any auth plugin that is set on the server. If a cipher
plugin is provided, it will be used to encrypt the message in addition to any
cipher plugin that is set on the server. If use_auth is False, the auth plugin
set on the server will not be used. If use_cipher is False, the cipher plugin
set on the server will not be used.

##### `add_or_update_peer(peer_id: bytes, peer_data: bytes, addr: tuple) -> bool:`

Add or update a peer in the peer list. If the peer is the local peer, it will
not be added to the peer list. Returns True if a PEER_DISCOVERED message should
be sent (False if it is the local peer).

##### `get_peer(addr: tuple[str, int] | None = None, peer_id: bytes | None = None) -> netaio.common.Peer | None:`

Get a peer from the peer list if addr or peer_id is provided and if it exists.
Prefers peer_id if both are provided but will fall back to addr if the provided
peer_id is not found.

##### `remove_peer(writer: StreamWriter, peer_id: bytes):`

Remove a peer from the peer list and all related subscriptions.

##### `async manage_peers_automatically(app_id: bytes = b'netaio', auth_plugin: netaio.common.AuthPluginProtocol | None = None, cipher_plugin: netaio.common.CipherPluginProtocol | None = None):`

Begins automatic peer management. This registers 3 handlers: 1) for the
'ADVERTISE_PEER' message, which will add the peer to the peer list and send a
'PEER_DISCOVERED' message to reciprocate; 2) for the 'PEER_DISCOVERED' message
type which will add the peer to the peer list; and 3) for the 'DISCONNECT'
message which will remove the peer from the local peer list. Then, it will send
an 'ADVERTISE_PEER' message to each client that has already connected to it. For
new connections, the client is expected to introduce itself before the server
responds with its peer data; it will not send an 'ADVERTISE_PEER' message to
newly connected clients. Raises AssertionError if `local_peer` is not set or if
the message_type_class does not contain 'ADVERTISE_PEER', 'PEER_DISCOVERED', and
'DISCONNECT' message types.

##### `async stop_peer_management(app_id: bytes = b'netaio'):`

Stops automatic peer management by removing the handlers.

##### `set_logger(logger: Logger):`

Replace the current logger.

### `UDPNode`

UDP node class.

#### Annotations

- port: int
- interface: str
- multicast_group: str
- local_peer: Peer
- peers: dict[bytes, Peer]
- peer_addrs: dict[tuple[str, int], bytes]
- header_class: type[HeaderProtocol]
- message_type_class: type[IntEnum]
- auth_fields_class: type[AuthFieldsProtocol]
- body_class: type[BodyProtocol]
- message_class: type[MessageProtocol]
- handlers: dict[Hashable, tuple[UDPHandler, AuthPluginProtocol | None,
CipherPluginProtocol | None]]
- default_handler: UDPHandler
- extract_keys: Callable[[MessageProtocol], list[Hashable]]
- make_error: Callable[[str], MessageProtocol]
- subscriptions: dict[Hashable, set[tuple[str, int]]]
- logger: logging.Logger
- transport: asyncio.DatagramTransport
- auth_plugin: AuthPluginProtocol
- cipher_plugin: CipherPluginProtocol
- peer_plugin: PeerPluginProtocol
- handle_auth_error: AuthErrorHandler

#### Methods

##### `__init__(port: int = 8888, interface: str = '0.0.0.0', multicast_group: str = '224.0.0.1', local_peer: Peer = None, header_class: type[HeaderProtocol] = Header, message_type_class: type[IntEnum] = <enum 'MessageType'>, auth_fields_class: type[AuthFieldsProtocol] = AuthFields, body_class: type[BodyProtocol] = Body, message_class: type[MessageProtocol] = Message, default_handler: UDPHandler = <function not_found_handler at 0x79d6fbbc64d0>, extract_keys: Callable[[MessageProtocol], list[Hashable]] = <function keys_extractor at 0x79d6fbdda9e0>, make_error_response: Callable[[str], MessageProtocol] = <function make_error_response at 0x79d6fbbc48b0>, logger: logging.Logger = <Logger netaio.node (INFO)>, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None, peer_plugin: PeerPluginProtocol = None, auth_error_handler: AuthErrorHandler = <function auth_error_handler at 0x79d6fbbc4940>, ignore_own_ip: bool = True):`

Initialize the UDPNode. `port` is the port to listen on. `interface` is the
interface to listen on. `multicast_group` is the multicast group to join.
`local_peer` is the local peer information for this node. `header_class`,
`auth_fields_class`, `body_class`, and `message_class` will be used for sending
messages and parsing responses. `message_type_class` is the class to inject in
calls to the decode method of the header class. `default_handler` is the default
handler to use for messages that do not match any registered handler keys.
`extract_keys` is a function that extracts the keys from a message.
`make_error_response` is a function that makes an error response. If
`auth_plugin` is provided, it will be used to check the set the auth_fields of
every sent message and check authenticity/authorization of all received
messages. If `cipher_plugin` is provided, it will be used to encrypt and decrypt
all messages. If `peer_plugin` is provided, it will be used to encode and decode
peer data. `auth_error_handler` is a function that handles auth errors, i.e.
when an auth check fails for a received message. If it returns a message, that
message will be sent as a response to the sender of the message that failed the
auth check. The default handler returns the error message generated by the auth
plugin and should be replaced if you do not want to send error messages for
failed auth checks (e.g. if the auth plugin is an anti-spam plugin and messages
that fail the auth check should just be dropped). If `ignore_own_ip` is True,
messages from the local IP address will be ignored.

##### `connection_made(transport: asyncio.DatagramTransport):`

Called when a connection is made. The argument is the transport representing the
pipe connection. When the connection is closed, connection_lost() is called.
This is called when the UDPNode successfully joins the multicast group.

##### `datagram_received(data: bytes, addr: tuple[str, int]):`

Called when a datagram is received. The arguments are the data received and the
address of the sender. This method will parse the message and call the
appropriate handler, calling plugins as necessary.

##### `error_received(exc: Exception):`

Called when a send or receive operation raises an OSError. (Other than
BlockingIOError or InterruptedError.)

##### `connection_lost(_: Exception):`

Called when the connection is lost or closed. The argument is an exception
object or None (the latter meaning a regular EOF is received or the connection
was aborted or closed).

##### `add_handler(key: Hashable, handler: Callable[[Any, Any], Any], auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Register a handler for a specific key. The handler must accept a MessageProtocol
object as an argument and return a MessageProtocol or None. If an auth plugin is
provided, it will be used to check the message in addition to any auth plugin
that is set on the node. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the node.
These plugins will also be used for preparing any response message sent by the
handler.

##### `on(key: Hashable, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Decorator to register a handler for a specific key. The handler must accept a
MessageProtocol object as an argument and return a MessageProtocol or None. If
an auth plugin is provided, it will be used to check the message in addition to
any auth plugin that is set on the node. If a cipher plugin is provided, it will
be used to decrypt the message in addition to any cipher plugin that is set on
the node. These plugins will also be used for preparing any response message
sent by the handler.

##### `remove_handler(key: Hashable):`

Remove a handler for a specific key.

##### `subscribe(key: Hashable, addr: tuple[str, int]):`

Subscribe a peer to a specific key. The key must be a Hashable object.

##### `unsubscribe(key: Hashable, addr: tuple[str, int]):`

Unsubscribe a peer from a specific key. If no subscribers are left, the key will
be removed from the subscriptions dictionary.

##### `prepare_message(message: MessageProtocol, use_auth: bool = True, use_cipher: bool = True, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None, peer: Peer | None = None) -> MessageProtocol | None:`

Prepares a message for transmission by invoking all necessary plugins.

##### `async start():`

Start the UDPNode. When a datagram is received, the datagram_received method is
called.

##### `send(message: MessageProtocol, addr: tuple[str, int], use_auth: bool = True, use_cipher: bool = True, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Send a message to a given address (unicast or multicast). If an auth plugin is
provided, it will be used to authorize the message in addition to any auth
plugin that is set on the node. If a cipher plugin is provided, it will be used
to encrypt the message in addition to any cipher plugin that is set on the node.
If use_auth is False, the auth plugin set on the node will not be used. If
use_cipher is False, the cipher plugin set on the node will not be used.

##### `broadcast(message: MessageProtocol, use_auth: bool = True, use_cipher: bool = True, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Send the message to all known peers. If an auth plugin is provided, it will be
used to authorize the message in addition to any auth plugin that is set on the
node. If a cipher plugin is provided, it will be used to encrypt the message in
addition to any cipher plugin that is set on the node. If use_auth is False, the
auth plugin set on the node will not be used. If use_cipher is False, the cipher
plugin set on the node will not be used.

##### `multicast(message: MessageProtocol, port: int | None = None, use_auth: bool = True, use_cipher: bool = True, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Send the message to the multicast group. If an auth plugin is provided, it will
be used to authorize the message in addition to any auth plugin that is set on
the node. If a cipher plugin is provided, it will be used to encrypt the message
in addition to any cipher plugin that is set on the node. If use_auth is False,
the auth plugin set on the node will not be used. If use_cipher is False, the
cipher plugin set on the node will not be used.

##### `notify(key: Hashable, message: MessageProtocol, use_auth: bool = True, use_cipher: bool = True, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Send the message to all subscribed peers for the given key concurrently using
asyncio.gather. If an auth plugin is provided, it will be used to authorize the
message in addition to any auth plugin that is set on the node. If a cipher
plugin is provided, it will be used to encrypt the message in addition to any
cipher plugin that is set on the node. If use_auth is False, the auth plugin set
on the node will not be used. If use_cipher is False, the cipher plugin set on
the node will not be used.

##### `add_or_update_peer(peer_id: bytes, peer_data: bytes, addr: tuple[str, int]) -> bool:`

Add or update a peer in the peer list. If the peer is the local peer, it will
not be added to the peer list. Returns True if a PEER_DISCOVERED message should
be sent (False if it is the local peer).

##### `get_peer(addr: tuple[str, int] | None = None, peer_id: bytes | None = None) -> Peer | None:`

Get a peer from the peer list if addr or peer_id is provided and if it exists.
Prefers peer_id if both are provided but will fall back to addr if the provided
peer_id is not found.

##### `remove_peer(addr: tuple[str, int], peer_id: bytes):`

Remove a peer from the peer list and all related subscriptions.

##### `remove_timed_out_peers(timeout: int):`

Remove timed out peers from the peer list.

##### `async begin_peer_advertisement(every: int = 20, app_id: bytes = b'netaio', peer_timeout: int = 60, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Begin peer advertisement. This starts a task that will advertise the local peer
every `every` seconds to the multicast group, and it will use the `app_id` as a
URI to identify the application. The loop will drop any peers that have timed
out. Raises AssertionError if `local_peer` is not set or if the
message_type_class does not contain the 'ADVERTISE_PEER' message type.

##### `async stop_peer_advertisement(app_id: bytes = b'netaio'):`

Stop the peer advertisement task if it exists.

##### `async manage_peers_automatically(advertise_every: int = 20, app_id: bytes = b'netaio', peer_timeout: int = 60, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Begins automatic peer management. This starts a task that will advertise the
local peer every `advertise_every` seconds to the multicast group, and it will
use the `app_id` as a URI to identify the application. Also registers 3
handlers: 1) for the 'ADVERTISE_PEER' message type which will add the peer to
the peer list and respond with a 'PEER_DISCOVERED' message to reciprocate; 2)
for the 'PEER_DISCOVERED' message that will add the peer to the peer list; and
3) for the 'DISCONNECT' message which will remove the peer from the local peer
list. The loop will also drop any peers that have timed out. Raises
AssertionError if `local_peer` is not set or if the message_type_class does not
contain 'ADVERTISE_PEER', 'PEER_DISCOVERED', and 'DISCONNECT' message types.

##### `async stop_peer_management(app_id: bytes = b'netaio'):`

Stop automatic peer management by stopping peer advertisement and removing the
handlers.

##### `async stop():`

Stop the UDPNode.

##### `set_logger(logger: logging.Logger):`

Replace the current logger.

### `Header`

Default header class.

#### Annotations

- message_type: MessageType
- auth_length: int
- body_length: int
- checksum: int

#### Methods

##### `__init__(message_type: MessageType, auth_length: int, body_length: int, checksum: int):`

##### `@staticmethod header_length() -> int:`

Return the byte length of the header.

##### `@staticmethod struct_fstring() -> str:`

Return the struct format string for decoding the header.

##### `@classmethod decode(data: bytes, message_type_factory: Callable[[int], IntEnum] | None = None) -> Header:`

Decode the header from the data.

##### `encode() -> bytes:`

Encode the header into bytes.

### `AuthFields`

Default auth fields class.

#### Annotations

- fields: dict[str, bytes]

#### Methods

##### `__init__(fields: dict[str, bytes] = <factory>):`

##### `@classmethod decode(data: bytes) -> AuthFields:`

Decode the auth fields from bytes.

##### `encode() -> bytes:`

Encode the auth fields into bytes.

### `Body`

Default body class.

#### Annotations

- uri_length: int
- uri: bytes
- content: bytes

#### Methods

##### `__init__(uri_length: int, uri: bytes, content: bytes):`

##### `@classmethod decode(data: bytes) -> Body:`

Decode the body from bytes.

##### `encode() -> bytes:`

Encode the body into bytes.

##### `@classmethod prepare(content: bytes, uri: bytes = b'', overhead: int = 0) -> Body:`

Prepare a body from content and optional arguments. Raises ValueError if the
content + uri is too long. (Calculated by subtracting the header length,
overhead, and 104 from 2**16. The 104 value is for IP encapsulation and other
known sources of overhead.)

### `Message`

Default message class.

#### Annotations

- header: Header
- auth_data: AuthFields
- body: Body

#### Methods

##### `__init__(header: Header, auth_data: AuthFields, body: Body):`

##### `check() -> bool:`

Check if the message is valid.

##### `@classmethod decode(data: bytes, message_type_factory: Callable[[int], IntEnum] | None = None) -> Message:`

Decode the message from the data. Raises ValueError if the checksum does not
match.

##### `encode() -> bytes:`

Encode the message into bytes.

##### `copy() -> Message:`

Returns a copy of the message.

##### `@classmethod prepare(body: BodyProtocol, message_type: MessageType | IntEnum, auth_data: AuthFields | None = None) -> Message:`

Prepare a message from a body and optional arguments.

### `MessageType(IntEnum)`

Some default message types: REQUEST_URI, RESPOND_URI, CREATE_URI, UPDATE_URI,
DELETE_URI, SUBSCRIBE_URI, UNSUBSCRIBE_URI, PUBLISH_URI, NOTIFY_URI,
ADVERTISE_PEER, OK, CONFIRM_SUBSCRIBE, CONFIRM_UNSUBSCRIBE, PEER_DISCOVERED,
ERROR, AUTH_ERROR, NOT_FOUND, DISCONNECT.

### `HeaderProtocol(Protocol)`

Shows what a Header class should have and do.

#### Properties

- body_length: At a minimum, a Header must have body_length, auth_length,
message_type, and checksum properties.
- auth_length: At a minimum, a Header must have body_length, auth_length,
message_type, and checksum properties.
- message_type: At a minimum, a Header must have body_length, auth_length,
message_type, and checksum properties.
- checksum: At a minimum, a Header must have body_length, auth_length,
message_type, and checksum properties.

#### Methods

##### `@staticmethod header_length() -> int:`

Return the byte length of the header.

##### `@staticmethod struct_fstring() -> str:`

Return the struct format string for decoding the header.

##### `@classmethod decode(data: bytes) -> HeaderProtocol:`

Decode the header from the data.

##### `encode() -> bytes:`

Encode the header into a bytes object.

### `AuthFieldsProtocol(Protocol)`

Shows what an AuthFields class should have and do.

#### Properties

- fields: At a minimum, an AuthFields must have fields property.

#### Methods

##### `@classmethod decode(data: bytes) -> AuthFieldsProtocol:`

Decode the auth fields from the data.

##### `encode() -> bytes:`

Encode the auth fields into a bytes object.

### `BodyProtocol(Protocol)`

Shows what a Body class should have and do.

#### Properties

- content: At a minimum, a Body must have content, uri, and uri_length
properties.
- uri: At a minimum, a Body must have content, uri, and uri_length properties.
- uri_length: At a minimum, a Body must have content, uri, and uri_length
properties.

#### Methods

##### `@classmethod decode(data: bytes) -> BodyProtocol:`

Decode the body from the data.

##### `encode() -> bytes:`

Encode the body into a bytes object.

##### `@classmethod prepare(content: bytes, uri: bytes = b'', overhead: int = 0) -> BodyProtocol:`

Prepare a body from content and optional arguments.

### `MessageProtocol(Protocol)`

Shows what a Message class should have and do.

#### Properties

- header: A Message must have a header property.
- auth_data: A Message must have an auth_data property.
- body: A Message must have a body property.

#### Methods

##### `check() -> bool:`

Check if the message is valid.

##### `encode() -> bytes:`

Encode the message into a bytes object.

##### `copy() -> MessageProtocol:`

Returns a copy of the message.

##### `@classmethod prepare(body: BodyProtocol, message_type: MessageType, auth_data: AuthFieldsProtocol = None) -> MessageProtocol:`

Prepare a message from a body.

### `AuthPluginProtocol(Protocol)`

Shows what an auth plugin should do.

#### Methods

##### `make(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> None:`

Set auth_fields appropriate for a given body. Optional args peer and peer_plugin
will be provided if they are available. The local peer information will be
stored in node.local_peer if it exists. If peer, peer_plugin, or node.local_peer
are required for functionality but are not provided/set, this method should fail
gracefully: log an error message using node.logger (if provided) and return.

##### `check(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> bool:`

Check if the auth fields are valid for the given body. Optional args peer and
peer_plugin will be provided if they are available. The local peer information
will be stored in node.local_peer if it exists. If peer, peer_plugin, or
node.local_peer are required for functionality but are not provided, this method
should fail gracefully: log an error using node.logger (if provided) and return
False.

##### `error(message_class: type[MessageProtocol] = Message, message_type_class: type[IntEnum] = <enum 'MessageType'>, header_class: type[HeaderProtocol] = Header, auth_fields_class: type[AuthFieldsProtocol] = AuthFields, body_class: type[BodyProtocol] = Body) -> MessageProtocol:`

Make an error message.

##### `@staticmethod is_peer_specific() -> bool:`

A cipher plugin must report if it is a peer-specific plugin; i.e. whether or not
it requires peer information to function.

### `CipherPluginProtocol(Protocol)`

Shows what a cipher plugin should do.

#### Methods

##### `encrypt(message: MessageProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> MessageProtocol:`

Encrypt the message body, setting values in the header or auth_data as
necessary. Returns a new message with the encrypted body and updated auth_data.
Optional args peer and peer_plugin will be provided if they are available. The
local peer information will be stored in node.local_peer if it exists. If peer,
peer_plugin, or node.local_peer are required for functionality but are not
provided, or in the case of an encryption failure, this method should raise an
exception.

##### `decrypt(message: MessageProtocol, node: NetworkNodeProtocol | None = None, peer: Peer | None = None, peer_plugin: PeerPluginProtocol | None = None) -> MessageProtocol:`

Decrypt the message body, reading values from the auth_data as necessary.
Returns a new message with the decrypted body. May raise an exception if the
decryption fails. Optional args peer and peer_plugin will be provided if they
are available. The local peer information will be stored in node.local_peer if
it exists. If peer and peer_plugin are required for functionality but are not
provided, or in the case of a decryption failure, this method should raise an
exception.

##### `@staticmethod is_peer_specific() -> bool:`

A cipher plugin must report if it is a peer-specific plugin; i.e. whether or not
it requires peer information to function.

### `PeerPluginProtocol(Protocol)`

Shows what a peer plugin should do.

#### Methods

##### `validate(peer: Peer) -> bool:`

Validate a peer. Must return True if the peer is valid, False otherwise, and it
must not raise an exception.

##### `parse_data(peer: Peer) -> dict[str, Any] | NamedTuple:`

Parse a peer's data. Must return a dictionary or namedtuple.

##### `encode_data(peer_data: dict[str, Any] | NamedTuple, peer_id: bytes | None = None) -> bytes:`

Encode a peer's data. Implementation may reference or include the peer_id, but
it should gracefully handle an empty peer_id.

##### `pack(peer: Peer) -> bytes:`

Pack a peer into a bytes object. Does not have to include the addrs.

##### `unpack(data: bytes) -> Peer:`

Unpack a peer from a bytes object. Should set the addrs to an empty set if the
data does not contain any addresses.

### `NetworkNodeProtocol(Protocol)`

For type-hinting objects that handle networking.

#### Properties

- port: A class implementing this protocol must have a port property
representing either the port to listen on or the port to connect to.
- local_peer: A class implementing this protocol must have a local_peer property
containing the local peer data.
- header_class: A class implementing this protocol must have a header_class
property referencing the header class to use for parsing received messages.
- message_type_class: A class implementing this protocol must have a
message_type_class property referencing the message type class to use for
parsing received messages.
- auth_fields_class: A class implementing this protocol must have an
auth_fields_class property referencing the auth fields class to use for parsing
received messages.
- body_class: A class implementing this protocol must have a body_class property
referencing the body class to use for parsing received messages.
- message_class: A class implementing this protocol must have a message_class
property referencing the message class to use for parsing received messages.
- handlers: A class implementing this protocol must have a handlers property
referencing a dictionary of handler functions, keyed by a hashable object, that
will be called when a message with the corresponding key is received.
- default_handler: A class implementing this protocol must have a
default_handler property referencing the default handler to use for messages
that do not match any registered handler keys.
- extract_keys: A class implementing this protocol must have an extract_keys
property referencing a function that extracts the keys used for routing/choosing
responses from a message.
- make_error: A class implementing this protocol must have a make_error property
referencing a function that makes error messages.
- logger: A class implementing this protocol must have a logger property
referencing a logger for logging messages.
- auth_plugin: A class implementing this protocol must have an auth_plugin
property referencing an auth plugin for authenticating/authorizing messages.
- cipher_plugin: A class implementing this protocol must have a cipher_plugin
property referencing a cipher plugin for encrypting and decrypting messages.
- handle_auth_error: A class implementing this protocol must have a
handle_auth_error property referencing a function that is called when the auth
check fails for a received message. If the function returns a message, that
message will be sent as a response to the sender of the message that failed the
auth check.

#### Methods

##### `add_handler(key: Hashable, handler: Handler | UDPHandler, auth_plugin: AuthPluginProtocol | None = None, cipher_plugin: CipherPluginProtocol | None = None):`

Register a handler for a specific key. The handler must accept a MessageProtocol
object as an argument and return a MessageProtocol or None. If an auth plugin is
provided, it will be used to check the message in addition to any auth plugin
that is set on the node. If a cipher plugin is provided, it will be used to
decrypt the message in addition to any cipher plugin that is set on the node.
These plugins will also be used for preparing any response message sent by the
handler.

##### `on(key: Hashable, auth_plugin: AuthPluginProtocol = None, cipher_plugin: CipherPluginProtocol = None):`

Decorator to register a handler for a specific key. The handler must accept a
MessageProtocol object as an argument and return a MessageProtocol or None. If
an auth plugin is provided, it will be used to check the message in addition to
any auth plugin that is set on the node. If a cipher plugin is provided, it will
be used to decrypt the message in addition to any cipher plugin that is set on
the node. These plugins will also be used for preparing any response message
sent by the handler.

##### `remove_handler(key: Hashable):`

Remove a handler from the node.

##### `set_logger(logger: logging.Logger):`

Replace the current logger.

### `Peer`

Class for storing peer information.

#### Annotations

- addrs: set[tuple[str, int]]
- id: bytes | None
- data: bytes | None
- last_rx: int

#### Methods

##### `__init__(addrs: set[tuple[str, int]], id: bytes | None = None, data: bytes | None = None, last_rx: int = <factory>):`

##### `update(data: bytes | None = None):`

Update the peer data and last_rx time.

##### `timed_out(timeout: int = 60) -> bool:`

Check if the peer has timed out.

### `DefaultPeerPlugin`

Default peer plugin.

#### Methods

##### `__init__(config: dict = {}):`

Initialize the peer plugin. No configuration necessary.

##### `validate(peer: Peer) -> bool:`

Validate a peer. By default, accept all peers that have an id.

##### `parse_data(peer: Peer) -> dict[str, Any] | NamedTuple:`

Parse a peer's data. Must return a dictionary or namedtuple.

##### `encode_data(peer_data: dict[str, Any] | NamedTuple, peer_id: bytes | None = None) -> bytes:`

Encode a peer's data. Ignores peer_id.

##### `pack(peer: Peer) -> bytes:`

Pack a peer into a bytes object. Does not include addrs.

##### `unpack(data: bytes) -> Peer:`

Unpack a peer from a bytes object. Sets the addrs to an empty set.

### `HMACAuthPlugin`

HMAC auth plugin.

#### Annotations

- secret: <class 'bytes'>
- nonce_field: <class 'str'>
- ts_field: <class 'str'>
- hmac_field: <class 'str'>

#### Methods

##### `__init__(config: dict):`

Initialize the HMAC auth plugin with a config. The config must contain
{"secret": <str|bytes>}. It can contain {"hmac_field": <str>} to specify the
auth field name for the hmac; the default is "hmac". It can contain
{"nonce_field": <str>} to specify the auth field name for the nonce; the default
is "nonce". It can contain {"ts_field": <str>} to specify the auth field name
for the timestamp; the default is "ts".

##### `make(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None):`

If the nonce and ts fields are not set, generate them. If the nonce is not the
IV_SIZE, generate a new one. Then, create an hmac of the nonce, ts, and body and
store it in the auth_data field specified by the "hmac_field" config option; the
default is "hmac".

##### `check(auth_fields: AuthFieldsProtocol, body: BodyProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None) -> bool:`

Check if the auth fields are valid for the given body. Performs an hmac check on
the nonce, ts, and body. Returns False if any of the fields are missing or if
the hmac check fails.

##### `error(message_class: type = Message, message_type_class: type = <enum 'MessageType'>, header_class: type = Header, auth_fields_class: type = AuthFields, body_class: type = Body) -> MessageProtocol:`

Make an error message that says "HMAC auth failed".

##### `@staticmethod is_peer_specific() -> bool:`

Used for optimization. Returns `False`.

### `Sha256StreamCipherPlugin`

SHA-256 stream cipher plugin.

#### Annotations

- key: <class 'bytes'>
- iv_field: <class 'str'>
- encrypt_uri: <class 'bool'>

#### Methods

##### `__init__(config: dict):`

Initialize the cipher plugin with a config. The config must contain {"key":
<str|bytes>}. It can contain {"iv_field": <str>} to specify the auth field name
for the iv; the default is "iv". It can contain {"encrypt_uri": <bool>} to
specify whether to encrypt the uri; the default is True.

##### `encrypt(message: MessageProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None) -> MessageProtocol:`

Encrypt the message body, setting the self.iv_field in the auth_data. This will
overwrite any existing value in that auth_data field. If the self.encrypt_uri is
True, the uri will be encrypted as well as the content.

##### `decrypt(message: MessageProtocol, node: netaio.common.NetworkNodeProtocol | None = None, peer: netaio.common.Peer | None = None, peer_plugin: netaio.common.PeerPluginProtocol | None = None) -> MessageProtocol:`

Decrypt the message body, reading the self.iv_field from the auth_data. Returns
a new message with the decrypted body.

##### `@staticmethod is_peer_specific() -> bool:`

Used for optimization. Returns `False`.

## Functions

### `keys_extractor(message: MessageProtocol) -> list[Hashable]:`

Extract handler keys for a given message. Custom implementations should return
at least one key, and the more specific keys should be listed first. This is
used to determine which handler to call for a given message, and it returns two
keys: one that includes both the message type and the body uri, and one that is
just the message type.

### `make_error_response(msg: str, message_class: type[MessageProtocol] = Message, message_type_class: type[IntEnum] = <enum 'MessageType'>, body_class: type[BodyProtocol] = Body) -> MessageProtocol:`

Make an error response message.

### `version() -> str:`

Return the version of the netaio package.

## Values

- `Handler`: _CallableGenericAlias
- `UDPHandler`: _CallableGenericAlias
- `default_server_logger`: Logger
- `default_client_logger`: Logger
- `default_node_logger`: Logger

