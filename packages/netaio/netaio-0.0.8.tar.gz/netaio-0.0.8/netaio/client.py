from .common import (
    Header,
    AuthFields,
    Body,
    Message,
    MessageType,
    HeaderProtocol,
    AuthFieldsProtocol,
    BodyProtocol,
    MessageProtocol,
    AuthPluginProtocol,
    CipherPluginProtocol,
    PeerPluginProtocol,
    Peer,
    keys_extractor,
    auth_error_handler,
    Handler,
    AuthErrorHandler,
    DefaultPeerPlugin,
    default_client_logger
)
from enum import IntEnum
from typing import Callable, Coroutine, Hashable
import asyncio
import logging


class TCPClient:
    """TCP client class."""
    hosts: dict[tuple[str, int], tuple[asyncio.StreamReader, asyncio.StreamWriter]]
    default_host: tuple[str, int]
    port: int
    local_peer: Peer
    peers: dict[bytes, Peer]
    peer_addrs: dict[tuple[str, int], bytes]
    header_class: type[HeaderProtocol]
    message_type_class: type[IntEnum]
    auth_fields_class: type[AuthFieldsProtocol]
    body_class: type[BodyProtocol]
    message_class: type[MessageProtocol]
    handlers: dict[Hashable, tuple[Handler, AuthPluginProtocol|None, CipherPluginProtocol|None]]
    extract_keys: Callable[[MessageProtocol], list[Hashable]]
    logger: logging.Logger
    auth_plugin: AuthPluginProtocol
    cipher_plugin: CipherPluginProtocol
    peer_plugin: PeerPluginProtocol
    handle_auth_error: AuthErrorHandler

    def __init__(
            self, host: str = "127.0.0.1", port: int = 8888,
            local_peer: Peer = None,
            header_class: type[HeaderProtocol] = Header,
            message_type_class: type[IntEnum] = MessageType,
            auth_fields_class: type[AuthFieldsProtocol] = AuthFields,
            body_class: type[BodyProtocol] = Body,
            message_class: type[MessageProtocol] = Message,
            extract_keys: Callable[[MessageProtocol], list[Hashable]] = keys_extractor,
            logger: logging.Logger = default_client_logger,
            auth_plugin: AuthPluginProtocol = None,
            cipher_plugin: CipherPluginProtocol = None,
            peer_plugin: PeerPluginProtocol = None,
            auth_error_handler: AuthErrorHandler = auth_error_handler,
        ):
        """Initialize the TCPClient.
            `host` is the default host IPv4 address to connect to.
            `port` is the default port to connect to.
            `local_peer` is the local peer information for this client.
            `header_class`, `auth_fields_class`, `body_class`, and
            `message_class` will be used for sending messages and
            parsing responses.
            `message_type_class` is the class to inject in calls to the
            decode method of the header class.
            `extract_keys` is a function that extracts the keys from a
            message.
            If `auth_plugin` is provided, it will be used to check the
            authenticity/authorization of all received messages and set
            the auth_fields of every sent message.
            If `cipher_plugin` is provided, it will be used to encrypt
            and decrypt all messages.
            If `peer_plugin` is provided, it will be used to encode and
            decode peer data.
            `auth_error_handler` is a function that handles auth errors,
            i.e. when an auth check fails for a received message. If it
            returns a message, that message will be sent as a response
            to the sender of the message that failed the auth check. The
            default handler returns the error message generated by the
            auth plugin and should be replaced if you do not want to
            send error messages for failed auth checks (e.g. if the
            auth plugin is an anti-spam plugin and messages that fail
            the auth check should just be dropped).
        """
        self.hosts = {}
        self.default_host = (host, port)
        self.port = port
        self.local_peer = local_peer
        self.peers = {}
        self.peer_addrs = {}
        self.header_class = header_class
        self.message_type_class = message_type_class
        self.auth_fields_class = auth_fields_class
        self.body_class = body_class
        self.message_class = message_class
        self.handlers = {}
        self.extract_keys = extract_keys
        self.logger = logger
        self.auth_plugin = auth_plugin
        self.cipher_plugin = cipher_plugin
        self.peer_plugin = peer_plugin or DefaultPeerPlugin()
        self.handle_auth_error = auth_error_handler
        self._enable_automatic_peer_management = False
        self._disconnect_msg = None
        self._advertise_msg = None

    def add_handler(
            self, key: Hashable,
            handler: Handler,
            auth_plugin: AuthPluginProtocol = None,
            cipher_plugin: CipherPluginProtocol = None
        ):
        """Register a handler for a specific key. The handler must
            accept a MessageProtocol object as an argument and return
            MessageProtocol, None, or a Coroutine that resolves to
            MessageProtocol | None. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the client. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the client.
        """
        self.logger.debug("Adding handler for key=%s", key)
        self.handlers[key] = (handler, auth_plugin, cipher_plugin)

    def on(
            self, key: Hashable,
            auth_plugin: AuthPluginProtocol = None,
            cipher_plugin: CipherPluginProtocol = None
        ):
        """Decorator to register a handler for a specific key. The
            handler must accept a MessageProtocol object as an argument
            and return a MessageProtocol, None, or a Coroutine that
            resolves to a MessageProtocol or None. If an auth plugin is
            provided, it will be used to check the message in addition
            to any auth plugin that is set on the client. If a cipher
            plugin is provided, it will be used to decrypt the message
            in addition to any cipher plugin that is set on the
            client.
        """
        def decorator(func: Handler):
            self.add_handler(key, func, auth_plugin, cipher_plugin)
            return func
        return decorator

    def remove_handler(self, key: Hashable):
        """Remove a handler for a specific key."""
        self.logger.debug("Removing handler for key=%s", key)
        if key in self.handlers:
            del self.handlers[key]

    async def connect(self, host: str = None, port: int = None):
        """Connect to a server."""
        host = host or self.default_host[0]
        port = port or self.default_host[1]
        self.logger.info("Connecting to %s:%d", host, port)
        reader, writer = await asyncio.open_connection(host, port)
        self.hosts[(host, port)] = (reader, writer)
        if self._enable_automatic_peer_management and self._advertise_msg:
            await self.send(self._advertise_msg.copy(), (host, port))

    async def send(
            self, message: MessageProtocol, server: tuple[str, int] = None,
            use_auth: bool = True, use_cipher: bool = True,
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Send a message to the server. If use_auth is True and an auth
            plugin is set, it will be called to set the auth fields on
            the message. If an auth plugin is provided, it will be used
            to authorize the message in addition to any auth plugin that
            is set on the client. If a cipher plugin is provided, it
            will be used to encrypt the message in addition to any
            cipher plugin that is set on the client. If use_auth is
            False, the auth plugin set on the client will not be used.
            If use_cipher is False, the cipher plugin set on the
            client will not be used.
        """
        server = server or self.default_host
        peer_id = self.peer_addrs.get(server, None)
        peer = self.peers.get(peer_id, None)

        # inner cipher
        if cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.encrypt on message")
            try:
                message = cipher_plugin.encrypt(message, self, peer, self.peer_plugin)
            except Exception as e:
                self.logger.error("Error encrypting message", exc_info=True)
                return

        # inner auth
        if auth_plugin is not None:
            self.logger.debug("Calling auth_plugin.make on auth_data and body")
            auth_plugin.make(message.auth_data, message.body, self, peer, self.peer_plugin)

        # outer cipher
        if use_cipher and self.cipher_plugin is not None:
            self.logger.debug("Calling self.cipher_plugin.encrypt on message")
            try:
                message = self.cipher_plugin.encrypt(message, self, peer, self.peer_plugin)
            except Exception as e:
                self.logger.error("Error encrypting message", exc_info=True)
                return

        # outer auth
        if use_auth and self.auth_plugin is not None:
            self.logger.debug("Calling self.auth_plugin.make on auth_data and body")
            self.auth_plugin.make(message.auth_data, message.body, self, peer, self.peer_plugin)

        self.logger.debug("Sending message of type=%s to server...", message.header.message_type)
        _, writer = self.hosts[server]
        writer.write(message.encode())
        await writer.drain()
        self.logger.debug("Message sent to server")

    async def receive_once(
            self, server: tuple[str, int] = None, use_auth: bool = True,
            use_cipher: bool = True, auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ) -> MessageProtocol|None:
        """Receive a message from the server. If a handler was
            registered for the message key, the handler will be called
            with the message as an argument, and the result will be
            returned if it is not None; otherwise, the received message
            will be returned. If the message checksum fails, the message
            will be discarded and None will be returned. If an auth
            plugin is set, it will be checked before the message handler
            is called, and if the check fails, the message will be
            discarded and None will be returned. If use_auth is False,
            the auth plugin set on the client will not be used. If
            use_cipher is False, the cipher plugin set on the
            client will not be used. If an auth plugin is provided, it
            will be used to check the message in addition to any auth
            plugin that is set on the client. If a cipher plugin is
            provided, it will be used to decrypt the message in addition
            to any cipher plugin that is set on the client.
        """
        self.logger.debug("Receiving message from server...")
        server = server or self.default_host
        peer_id = self.peer_addrs.get(server, None)
        peer = self.peers.get(peer_id, None)
        reader, writer = self.hosts[server]
        data = await reader.readexactly(self.header_class.header_length())
        header: HeaderProtocol = self.header_class.decode(
            data,
            message_type_factory=self.message_type_class
        )
        self.logger.debug("Received message of type=%s from server", header.message_type)

        auth_bytes = await reader.readexactly(header.auth_length)
        auth: AuthFieldsProtocol = self.auth_fields_class.decode(auth_bytes)

        body_bytes = await reader.readexactly(header.body_length)
        body: BodyProtocol = self.body_class.decode(body_bytes)

        msg: MessageProtocol = self.message_class(
            header=header,
            auth_data=auth,
            body=body
        )

        if not msg.check():
            self.logger.warning("Message checksum failed")
            return None

        # outer auth
        if use_auth and self.auth_plugin is not None:
            self.logger.debug("Calling self.auth_plugin.check on auth and body")
            check = self.auth_plugin.check(msg.auth_data, msg.body, self, peer, self.peer_plugin)
            if not check:
                self.logger.warning("Message auth failed")
                return self.handle_auth_error(self, self.auth_plugin, msg)

        # outer cipher
        if use_cipher and self.cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.decrypt on message")
            try:
                msg = self.cipher_plugin.decrypt(msg, self, peer, self.peer_plugin)
            except Exception as e:
                self.logger.error("Error decrypting message; dropping", exc_info=True)
                return

        # inner auth
        if auth_plugin is not None:
            self.logger.debug("Calling auth_plugin.check on auth and body")
            check = auth_plugin.check(msg.auth_data, msg.body, self, peer, self.peer_plugin)
            if not check:
                self.logger.warning("Message auth failed")
                return self.handle_auth_error(self, auth_plugin, msg)

        # inner cipher
        if cipher_plugin is not None:
            self.logger.debug("Calling cipher_plugin.decrypt on message")
            try:
                msg = cipher_plugin.decrypt(msg, self, peer, self.peer_plugin)
            except Exception as e:
                self.logger.error("Error decrypting message; dropping", exc_info=True)
                return

        keys = self.extract_keys(msg)
        result = None

        self.logger.debug("Message received from server")
        for key in keys:
            if key in self.handlers:
                handler, auth_plugin, cipher_plugin = self.handlers[key]

                # inner auth
                if auth_plugin is not None:
                    self.logger.debug("Calling auth_plugin.check on auth and body")
                    check = auth_plugin.check(msg.auth_data, msg.body, self, peer, self.peer_plugin)
                    if not check:
                        self.logger.warning("Message auth failed")
                        return self.handle_auth_error(self, auth_plugin, msg)

                # inner cipher
                if cipher_plugin is not None:
                    self.logger.debug("Calling cipher_plugin.decrypt on message")
                    try:
                        msg = cipher_plugin.decrypt(msg, self, peer, self.peer_plugin)
                    except Exception as e:
                        self.logger.error("Error decrypting message; dropping", exc_info=True)
                        return

                self.logger.debug("Calling handler for key=%s", key)
                result = handler(msg, writer)
                if isinstance(result, Coroutine):
                    result = await result
                break

        if result is not None:
            return result

        return msg

    async def receive_loop(
            self, server: tuple[str, int] = None, use_auth: bool = True,
            use_cipher: bool = True, auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Receive messages from the server indefinitely. Use with
            asyncio.create_task() to run concurrently, then use
            task.cancel() to stop. If use_auth is False, the auth plugin
            set on the client will not be used. If use_cipher is
            False, the cipher plugin set on the client will not be
            used. If an auth plugin is provided, it will be used to
            check the message in addition to any auth plugin that is set
            on the client. If a cipher plugin is provided, it will be
            used to decrypt the message in addition to any cipher
            plugin that is set on the client.
        """
        server = server or self.default_host
        while True:
            try:
                await self.receive_once(server, use_auth, use_cipher, auth_plugin, cipher_plugin)
            except asyncio.CancelledError:
                self.logger.info("Receive loop cancelled")
                break
            except Exception as e:
                self.logger.error("Error in receive_loop", exc_info=True)
                break

    async def close(self, server: tuple[str, int] = None):
        """Close the connection to the server."""
        server = server or self.default_host
        self.logger.info("Closing connection to server...")
        _, writer = self.hosts[server]
        if self._enable_automatic_peer_management and self._disconnect_msg:
            await self.send(self._disconnect_msg.copy(), server)
        writer.close()
        await writer.wait_closed()
        self.logger.info("Connection to server closed")

    def add_or_update_peer(
            self, peer_id: bytes, peer_data: bytes, addr: tuple[str, int]
        ) -> bool:
        """Add or update a peer in the peer list. If the peer is the
            local peer, it will not be added to the peer list. Returns
            True if a PEER_DISCOVERED message should be sent (False if
            it is the local peer).
        """
        if peer_id == self.local_peer.id:
            self.logger.debug("Ignoring local peer.")
            return False
        if peer_id in self.peers:
            self.logger.debug(
                "Updating peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id].update(peer_data)
            self.peers[peer_id].addrs.add(addr)
        else:
            self.logger.debug(
                "Adding peer 0x%s at %s with data %s",
                peer_id.hex(), addr, peer_data.hex()
            )
            self.peers[peer_id] = Peer({addr}, peer_id, peer_data)
        self.peer_addrs[addr] = peer_id
        return True

    def get_peer(
            self, addr: tuple[str, int]|None = None, peer_id: bytes|None = None
        ) -> Peer|None:
        """Get a peer from the peer list if addr or peer_id is provided
            and if it exists. Prefers peer_id if both are provided but
            will fall back to addr if the provided peer_id is not found.
        """
        peer = None
        if peer_id is not None:
            peer = self.peers.get(peer_id, None)
        if addr is not None and peer is None:
            peer_id = self.peer_addrs.get(addr, None)
            peer = self.peers.get(peer_id, None)
        return peer

    def remove_peer(self, addr: tuple[str, int], peer_id: bytes):
        """Remove a peer from the peer list."""
        self.logger.debug(
            "Removing peer 0x%s at %s from peer list", peer_id.hex(), addr
        )
        if peer_id in self.peers:
            del self.peers[peer_id]
        if addr in self.peer_addrs:
            del self.peer_addrs[addr]

    async def manage_peers_automatically(
            self, app_id: bytes = b'netaio',
            auth_plugin: AuthPluginProtocol|None = None,
            cipher_plugin: CipherPluginProtocol|None = None
        ):
        """Begins automatic peer management: when the client connects to
            a server, it will send its local_peer data. This also
            registers 3 handlers: 1) for the 'ADVERTISE_PEER' message,
            which will add the peer to the peer list and send a
            'PEER_DISCOVERED' message to reciprocate; 2) for the
            'PEER_DISCOVERED' message type which will add the peer to
            the peer list; and 3) for the 'DISCONNECT' message which
            will remove the peer from the local peer list. Then, it will
            send an 'ADVERTISE_PEER' message to each server it has
            already connected to. Raises AssertionError if `local_peer`
            is not set or if the message_type_class does not contain
            'ADVERTISE_PEER', 'PEER_DISCOVERED', and 'DISCONNECT'
            message types.
        """
        # preconditions
        assert self.local_peer is not None
        assert hasattr(self.message_type_class, 'ADVERTISE_PEER')
        assert hasattr(self.message_type_class, 'PEER_DISCOVERED')
        assert hasattr(self.message_type_class, 'DISCONNECT')

        # set enable flag
        self._enable_automatic_peer_management = True

        # create the advertise message
        self._advertise_msg = self.message_class.prepare(
            self.body_class.prepare(
                self.peer_plugin.pack(self.local_peer),
                app_id
            ),
            self.message_type_class.ADVERTISE_PEER
        )

        # create the disconnect message
        self._disconnect_msg = self.message_class.prepare(
            self.body_class.prepare(
                self.peer_plugin.pack(self.local_peer),
                app_id
            ),
            self.message_type_class.DISCONNECT
        )

        if cipher_plugin is not None:
            self._advertise_msg = cipher_plugin.encrypt(
                self._advertise_msg, self, None, self.peer_plugin
            )
            self._disconnect_msg = cipher_plugin.encrypt(
                self._disconnect_msg, self, None, self.peer_plugin
            )

        if auth_plugin is not None:
            auth_plugin.make(
                self._advertise_msg.auth_data,
                self._advertise_msg.body,
                self, None, self.peer_plugin
            )
            auth_plugin.make(
                self._disconnect_msg.auth_data,
                self._disconnect_msg.body,
                self, None, self.peer_plugin
            )

        # create the handlers
        @self.on((self.message_type_class.ADVERTISE_PEER, app_id), auth_plugin, cipher_plugin)
        def handle_advertise_peer(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received ADVERTISE_PEER message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring ADVERTISE_PEER message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content)
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            if not self.add_or_update_peer(peer.id, peer.data, addr):
                return

            # prepare the response
            return self.message_class.prepare(
                self.body_class.prepare(
                    self.peer_plugin.pack(self.local_peer),
                    app_id
                ),
                self.message_type_class.PEER_DISCOVERED
            )

        @self.on((self.message_type_class.PEER_DISCOVERED, app_id), auth_plugin, cipher_plugin)
        def handle_peer_discovered(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received PEER_DISCOVERED message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring PEER_DISCOVERED message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content)
            except Exception as e:
                self.logger.error("Error unpacking peer data: %s", e)
                return

            self.add_or_update_peer(peer.id, peer.data, addr)

        @self.on((self.message_type_class.DISCONNECT, app_id), auth_plugin, cipher_plugin)
        def handle_disconnect(message: MessageProtocol, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info("peername")
            self.logger.debug("Received DISCONNECT message from %s", addr)

            if app_id != message.body.uri:
                self.logger.debug("Ignoring DISCONNECT message with mismatched app_id")
                return

            try:
                peer = self.peer_plugin.unpack(message.body.content)
            except Exception as e:
                self.logger.error("Error unpacking peer id: %s", e)
                return

            self.remove_peer(addr, peer.id)

        for addr in self.hosts:
            await self.send(self._advertise_msg.copy(), addr)

    async def stop_peer_management(self, app_id: bytes = b'netaio'):
        """Stops automatic peer management by disabling the feature,
            sending a DISCONNECT message, and removing the handlers.
        """
        self._enable_automatic_peer_management = False
        self.remove_handler((self.message_type_class.ADVERTISE_PEER, app_id))
        self.remove_handler((self.message_type_class.PEER_DISCOVERED, app_id))
        self.remove_handler((self.message_type_class.DISCONNECT, app_id))
        if self._disconnect_msg:
            for addr in self.peer_addrs:
                await self.send(self._disconnect_msg.copy(), addr)

    def set_logger(self, logger: logging.Logger):
        """Replace the current logger."""
        self.logger = logger
