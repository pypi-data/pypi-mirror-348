"use strict";(self.webpackChunk_jovyanai_labextension=self.webpackChunk_jovyanai_labextension||[]).push([[441],{1441:(e,s,t)=>{t.r(s),t.d(s,{JovyanClient:()=>i});var n=null;"undefined"!=typeof WebSocket?n=WebSocket:"undefined"!=typeof MozWebSocket?n=MozWebSocket:void 0!==t.g?n=t.g.WebSocket||t.g.MozWebSocket:"undefined"!=typeof window?n=window.WebSocket||window.MozWebSocket:"undefined"!=typeof self&&(n=self.WebSocket||self.MozWebSocket);var r=n,o=class{debug(e,...s){console.debug(`[DEBUG] ${e}`,...s)}info(e,...s){console.info(`[INFO] ${e}`,...s)}warn(e,...s){console.warn(`[WARN] ${e}`,...s)}error(e,...s){console.error(`[ERROR] ${e}`,...s)}},a=class{toolExecutions;executors;constructor(e=new Map){this.toolExecutions=new Map,this.executors=e}handleError(e,s,t){console.error(s),t({type:"agent:tool_use_result",payload:{toolCall:{result:s,toolCallId:e}}})}handleMessage(e,s){const t=e.payload.toolCall.toolCallId;if(this.toolExecutions.has(t)){const n=this.toolExecutions.get(t);if(!n)return void this.handleError(t,`Tool call ID ${t} not found in toolExecutions map.`,s);n.handleMessage(e,s)}else{if("agent:tool_use_complete"==e.type){const e=`Tool call ID ${t} not found in toolExecutions map but received complete message.`;return void this.handleError(t,e,s)}const n=e.payload.toolCall.toolName,r=this.executors.get(n);r?(this.toolExecutions.set(t,r),r.handleMessage(e,s)):this.handleError(t,`Tool executor for tool name ${n} not found.`,s)}}registerToolExecutor(e,s){this.executors.set(e,s)}},i=(new a,class{constructor(e,s,t,n){this.url=e,this.jwtToken=s,this.userId=t,this.logger=n||new o,this.currentToken=s}ws=null;sessionId=null;currentChatId=null;messageHandlers=new Map;chatHandlers=new Map;messageQueue=[];_isConnected=!1;_isAuthenticated=!1;currentToken=null;logger;get isConnected(){return this._isConnected}get isAuthenticated(){return this._isAuthenticated}async connect(){return new Promise(((e,s)=>{try{this.ws=new r(this.url),this.ws.onopen=async()=>{this.logger.info("Connected to Jovyan AI server"),this._isConnected=!0;try{await this.authenticate(),this.processMessageQueue(),e()}catch(e){this.logger.error("Authentication failed:",e),s(e)}},this.ws.onerror=e=>{this.logger.error("WebSocket error:",e),this._isConnected=!1,s(new Error("Connection failed"))},this.ws.onclose=()=>{this._isConnected=!1,this._isAuthenticated=!1},this.setupMessageHandler()}catch(e){s(e)}}))}setupMessageHandler(){this.ws&&(this.ws.onmessage=e=>{try{const s=JSON.parse(e.data.toString());if(s.action&&this.chatHandlers.has(s.action)){const e=this.chatHandlers.get(s.action);return void(e&&e(s))}const t=s,n=this.messageHandlers.get(t.type);n&&n(t)}catch(e){this.logger.error("Error handling message:",e)}})}async authenticate(){return new Promise(((e,s)=>{if(!this._isConnected||!this.ws)return void s(new Error("Not connected to server"));this.messageHandlers.set("auth:success",(s=>{if("auth:success"===s.type){const t=s;this._isAuthenticated=!0,this.userId=t.payload.userId,e()}})),this.messageHandlers.set("error",(e=>{"error"===e.type&&s(new Error(e.payload.message))}));const t={type:"auth",payload:{token:this.currentToken}};this.ws.send(JSON.stringify(t))}))}processMessageQueue(){for(;this.messageQueue.length>0&&this._isConnected&&this._isAuthenticated;){const e=this.messageQueue.shift();e&&this.send(e)}}send(e){this._isConnected&&this._isAuthenticated?this.ws&&this.ws.send(JSON.stringify(e)):this.messageQueue.push(e)}async startSession(){return new Promise(((e,s)=>{if(!this._isConnected||!this._isAuthenticated)return void s(new Error("Not connected or not authenticated"));const t={type:"session:start",payload:{userId:this.userId}};this.messageHandlers.set("session:started",(t=>{"session:started"===t.type&&(this.sessionId=t.payload.sessionId,this.sessionId?e(this.sessionId):s(new Error("Session ID is null")))})),this.send(t)}))}async generateCode(e){return console.warn("Warning: generateCode() is deprecated. Please use generateCodeStream() instead."),new Promise(((s,t)=>{if(!this._isConnected)return void t(new Error("Not connected to server"));const n={type:"cell:generate_code",payload:e};this.messageHandlers.set("cell:generated_code",(e=>{"cell:generated_code"===e.type&&s(e.payload.generatedCode)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&t(new Error(e.payload.message))})),this.send(n)}))}async generateCodeStream(e,s){if(!this._isConnected)try{await this.connect()}catch(e){return Promise.reject(e)}return new Promise(((t,n)=>{const r={type:"cell:generate_code",payload:{...e,stream:!0}};let o="";this.messageHandlers.set("cell:generated_code_chunk",(e=>{if("cell:generated_code_chunk"===e.type){const t=e.payload.content;o+=t,s(t)}})),this.messageHandlers.set("cell:generated_code_complete",(e=>{"cell:generated_code_complete"===e.type&&t()})),this.messageHandlers.set("error",(e=>{"error"===e.type&&n(new Error(e.payload.message))})),this.send(r)}))}async suggestNextAction(e){return new Promise(((s,t)=>{if(!this._isConnected)return void t(new Error("Not connected to server"));const n={type:"cell:next_action_suggestion",payload:e};this.messageHandlers.set("cell:next_action_response",(e=>{"cell:next_action_response"===e.type&&s(e.payload.nextAction)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&t(new Error(e.payload.message))})),this.send(n)}))}async sendUserMessage(e,s){return console.warn("Warning: sendUserMessage() is deprecated. Please use sendUserMessageStream() instead."),new Promise(((t,n)=>{if(!this._isConnected)return void n(new Error("Not connected to server"));const r={type:"agent:user_message",payload:{message:e,context:s}};this.messageHandlers.set("agent:agent_message",(e=>{"agent:agent_message"===e.type&&t(e.payload.message)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&n(new Error(e.payload.message))})),this.send(r)}))}async sendUserMessageStream(e,s,t){return this._isConnected?new Promise(((n,r)=>{const o={type:"agent:user_message",payload:{message:e,context:s,stream:!0}};let i="";s.tools||(s.tools=[]);const d=new a;s.tools.forEach((e=>{d.registerToolExecutor(e.name,e)})),this.messageHandlers.set("agent:agent_message_chunk",(e=>{if("agent:agent_message_chunk"===e.type){const s=e.payload.content;i+=s,t(s)}})),this.messageHandlers.set("agent:agent_message_complete",(e=>{"agent:agent_message_complete"===e.type&&n()})),this.messageHandlers.set("error",(e=>{"error"===e.type&&r(new Error(e.payload.message))})),this.messageHandlers.set("agent:tool_use_chunk",(e=>{"agent:tool_use_chunk"===e.type&&d.handleMessage(e,this.send.bind(this))})),this.messageHandlers.set("agent:tool_use_complete",(e=>{"agent:tool_use_complete"===e.type&&d.handleMessage(e,this.send.bind(this))})),this.send(o)})):Promise.reject(new Error("Not connected to server"))}async close(){if(this.ws)return new Promise((e=>{this.ws.onclose=()=>{this.ws=null,this._isConnected=!1,this._isAuthenticated=!1,this.messageHandlers.clear(),this.messageQueue=[],e()},this.ws.close()}))}_setConnected(e){this._isConnected=e}async createChat(e){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((s,t)=>{this.messageHandlers.set("chat:created",(e=>{const t=e.payload.chat;this.currentChatId=t.id,s(t)})),this.messageHandlers.set("chat:error",(e=>{t(new Error(e.payload.error))})),this.send({type:"chat:create",payload:{user_id:this.userId,title:e}})}))}async setCurrentChatId(e){this.currentChatId=e}async getMessages(e,s=100,t=0){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((n,r)=>{this.messageHandlers.set("chat:messages",(e=>{const s=e.payload;n(s.messages)})),this.messageHandlers.set("chat:error",(e=>{r(new Error(e.payload.error))})),this.send({type:"chat:get_messages",payload:{chat_id:e,limit:s,offset:t}})}))}async getChats(){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((e,s)=>{this.messageHandlers.set("chat:chats",(s=>{const t=s.payload;e(t.chats)})),this.messageHandlers.set("chat:error",(e=>{s(new Error(e.payload.error))})),this.send({type:"chat:get_chats",payload:{user_id:this.userId}})}))}async sendChatUserMessageStream(e,s,t){if(!this._isConnected)return Promise.reject(new Error("Not connected to server"));if(!this.currentChatId)return Promise.reject(new Error("No active chat"));const n=this.currentChatId;return new Promise(((r,o)=>{this.send({type:"chat:user_message",payload:{content:e,chat_id:n,role:"user",context:{currentNotebook:s.currentNotebook,selectedCells:s.selectedCells,attachedContexts:s.attachedContexts,tools:s.tools},stream:!0}}),this.messageHandlers.set("chat:started",(()=>{})),this.messageHandlers.set("chat:chunk",(e=>{const s=e.payload.content;t(s)})),this.messageHandlers.set("chat:completed",(()=>{r()})),this.messageHandlers.set("chat:error",(e=>{o(new Error(e.payload.error))}))}))}async generateChatTitle(e){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");const s=this.currentChatId;if(!s)throw new Error("No active chat selected to generate title for");return new Promise(((t,n)=>{this.messageHandlers.set("chat:title_generated",(e=>{if("chat:title_generated"===e.type){const s=e;this.messageHandlers.delete("chat:title_generated"),this.messageHandlers.delete("chat:error"),t(s.payload.title)}})),this.messageHandlers.set("chat:error",(e=>{"error"===e.type&&(this.messageHandlers.delete("chat:title_generated"),this.messageHandlers.delete("chat:error"),n(new Error(e.payload.error)))}));const r={type:"chat:generate_title",payload:{message:e,chat_id:s}};this.send(r)}))}async sendDocumentToIndex(e,s,t){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");if(!e&&!s)throw new Error("No file or link provided");return new Promise(((n,r)=>{let o=null;const a=()=>{this.messageHandlers.set("index:finished",(e=>{const s=e.payload;s&&"success"===s.status?n():r(new Error("Failed to index document")),this.messageHandlers.delete("index:finished"),this.messageHandlers.delete("index:error")})),this.messageHandlers.set("index:error",(e=>{const s=e.payload;r(new Error(s.error)),this.messageHandlers.delete("index:finished"),this.messageHandlers.delete("index:error")})),this.send({type:"index:document",payload:{file:o,link:s,name:t,user_id:this.userId}})};if(e){const s=new FileReader;s.onload=()=>{const e=s.result;o=e.split(",")[1],a()},s.onerror=()=>{r(new Error("Error reading file"))},s.readAsDataURL(e)}else a()}))}async getIndexDocumentNames(e){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((s,t)=>{this.messageHandlers.set("get_index_names:finished",(e=>{const n=e.payload;n&&"success"===n.status?s(n.names):t(new Error("Failed to get index names")),this.messageHandlers.delete("get_index_names:finished"),this.messageHandlers.delete("index:error")})),this.messageHandlers.set("index:error",(e=>{const s=e.payload;t(new Error(s.error)),this.messageHandlers.delete("get_index_names:finished"),this.messageHandlers.delete("index:error")})),this.send({type:"index:get_names",payload:{user_id:this.userId,type:e}})}))}async deleteIndexDocumentName(e,s){if(!this._isConnected||!this._isAuthenticated)throw new Error("Not connected or not authenticated");return new Promise(((t,n)=>{this.messageHandlers.set("delete_index_name:finished",(e=>{const s=e.payload;s&&"success"===s.status?t():n(new Error("Failed to delete index name")),this.messageHandlers.delete("delete_index_name:finished"),this.messageHandlers.delete("index:error")})),this.messageHandlers.set("index:error",(e=>{const s=e.payload;n(new Error(s.error)),this.messageHandlers.delete("delete_index_name:finished"),this.messageHandlers.delete("index:error")})),this.send({type:"index:delete_name",payload:{user_id:this.userId,name:e,type:s}})}))}})}}]);