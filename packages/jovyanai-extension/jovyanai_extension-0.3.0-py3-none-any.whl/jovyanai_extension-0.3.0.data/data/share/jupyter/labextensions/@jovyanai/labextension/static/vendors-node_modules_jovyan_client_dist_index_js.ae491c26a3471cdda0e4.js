"use strict";
(self["webpackChunk_jovyanai_labextension"] = self["webpackChunk_jovyanai_labextension"] || []).push([["vendors-node_modules_jovyan_client_dist_index_js"],{

/***/ "./node_modules/@jovyan/client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@jovyan/client/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JovyanClient: () => (/* binding */ JovyanClient)
/* harmony export */ });
// ../../node_modules/.pnpm/isomorphic-ws@5.0.0_ws@8.18.1/node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof __webpack_require__.g !== "undefined") {
  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// src/core/logger.ts
var DefaultLogger = class {
  debug(message, ...args) {
    if (true) {
      console.debug(`[DEBUG] ${message}`, ...args);
    }
  }
  info(message, ...args) {
    console.info(`[INFO] ${message}`, ...args);
  }
  warn(message, ...args) {
    console.warn(`[WARN] ${message}`, ...args);
  }
  error(message, ...args) {
    console.error(`[ERROR] ${message}`, ...args);
  }
};

// src/services/tool_use.ts
var ToolUseRouter = class {
  // Properties
  toolExecutions;
  executors;
  constructor(executors = /* @__PURE__ */ new Map()) {
    this.toolExecutions = /* @__PURE__ */ new Map();
    this.executors = executors;
  }
  handleError(toolCallId, error, resultCallback) {
    console.error(error);
    resultCallback({
      type: "agent:tool_use_result",
      payload: {
        toolCall: {
          result: error,
          toolCallId
        }
      }
    });
  }
  // Route a message to the appropriate tool executor
  handleMessage(message, resultCallback) {
    const toolCallId = message.payload.toolCall.toolCallId;
    if (this.toolExecutions.has(toolCallId)) {
      const toolExecutor = this.toolExecutions.get(toolCallId);
      if (toolExecutor) {
        toolExecutor.handleMessage(message, resultCallback);
      } else {
        this.handleError(
          toolCallId,
          `Tool call ID ${toolCallId} not found in toolExecutions map.`,
          resultCallback
        );
        return;
      }
    } else {
      if (message.type == "agent:tool_use_complete") {
        const err = `Tool call ID ${toolCallId} not found in toolExecutions map but received complete message.`;
        this.handleError(
          toolCallId,
          err,
          resultCallback
        );
        return;
      }
      const toolName = message.payload.toolCall.toolName;
      const toolExecutor = this.executors.get(toolName);
      if (toolExecutor) {
        this.toolExecutions.set(toolCallId, toolExecutor);
        toolExecutor.handleMessage(message, resultCallback);
      } else {
        this.handleError(
          toolCallId,
          `Tool executor for tool name ${toolName} not found.`,
          resultCallback
        );
      }
    }
  }
  // Register a tool executor for a specific tool
  registerToolExecutor(toolName, executor) {
    this.executors.set(toolName, executor);
  }
};
var toolUseRouter = new ToolUseRouter();

// src/core/client.ts
var JovyanClient = class {
  constructor(url, jwtToken, userId, logger) {
    this.url = url;
    this.jwtToken = jwtToken;
    this.userId = userId;
    this.logger = logger || new DefaultLogger();
    this.currentToken = jwtToken;
  }
  ws = null;
  sessionId = null;
  currentChatId = null;
  messageHandlers = /* @__PURE__ */ new Map();
  chatHandlers = /* @__PURE__ */ new Map();
  messageQueue = [];
  _isConnected = false;
  _isAuthenticated = false;
  currentToken = null;
  logger;
  get isConnected() {
    return this._isConnected;
  }
  get isAuthenticated() {
    return this._isAuthenticated;
  }
  async connect() {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new browser_default(this.url);
        this.ws.onopen = async () => {
          this.logger.info("Connected to Jovyan AI server");
          this._isConnected = true;
          try {
            await this.authenticate();
            this.processMessageQueue();
            resolve();
          } catch (error) {
            this.logger.error("Authentication failed:", error);
            reject(error);
          }
        };
        this.ws.onerror = (event) => {
          this.logger.error("WebSocket error:", event);
          this._isConnected = false;
          reject(new Error("Connection failed"));
        };
        this.ws.onclose = () => {
          this._isConnected = false;
          this._isAuthenticated = false;
        };
        this.setupMessageHandler();
      } catch (error) {
        reject(error);
      }
    });
  }
  setupMessageHandler() {
    if (!this.ws) return;
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data.toString());
        if (data.action && this.chatHandlers.has(data.action)) {
          const handler2 = this.chatHandlers.get(data.action);
          if (handler2) {
            handler2(data);
          }
          return;
        }
        const message = data;
        const handler = this.messageHandlers.get(message.type);
        if (handler) {
          handler(message);
        }
      } catch (error) {
        this.logger.error("Error handling message:", error);
      }
    };
  }
  async authenticate() {
    return new Promise((resolve, reject) => {
      if (!this._isConnected || !this.ws) {
        reject(new Error("Not connected to server"));
        return;
      }
      this.messageHandlers.set("auth:success", (message) => {
        if (message.type === "auth:success") {
          const authMessage2 = message;
          this._isAuthenticated = true;
          this.userId = authMessage2.payload.userId;
          resolve();
        }
      });
      this.messageHandlers.set("error", (message) => {
        if (message.type === "error") {
          reject(new Error(message.payload.message));
        }
      });
      const authMessage = {
        type: "auth",
        payload: {
          token: this.currentToken
        }
      };
      this.ws.send(JSON.stringify(authMessage));
    });
  }
  processMessageQueue() {
    while (this.messageQueue.length > 0 && this._isConnected && this._isAuthenticated) {
      const message = this.messageQueue.shift();
      if (message) {
        this.send(message);
      }
    }
  }
  send(message) {
    if (!this._isConnected || !this._isAuthenticated) {
      this.messageQueue.push(message);
      return;
    }
    if (this.ws) {
      this.ws.send(JSON.stringify(message));
    }
  }
  async startSession() {
    return new Promise((resolve, reject) => {
      if (!this._isConnected || !this._isAuthenticated) {
        reject(new Error("Not connected or not authenticated"));
        return;
      }
      const startMessage = {
        type: "session:start",
        payload: { userId: this.userId }
      };
      this.messageHandlers.set("session:started", (message) => {
        if (message.type === "session:started") {
          this.sessionId = message.payload.sessionId;
          if (this.sessionId) {
            resolve(this.sessionId);
          } else {
            reject(new Error("Session ID is null"));
          }
        }
      });
      this.send(startMessage);
    });
  }
  /**
   * @deprecated This method is deprecated. Please use generateCodeStream() instead.
   */
  async generateCode(params) {
    console.warn("Warning: generateCode() is deprecated. Please use generateCodeStream() instead.");
    return new Promise((resolve, reject) => {
      if (!this._isConnected) {
        reject(new Error("Not connected to server"));
        return;
      }
      const message = {
        type: "cell:generate_code",
        payload: params
      };
      this.messageHandlers.set("cell:generated_code", (message2) => {
        if (message2.type === "cell:generated_code") {
          resolve(message2.payload.generatedCode);
        }
      });
      this.messageHandlers.set("error", (message2) => {
        if (message2.type === "error") {
          reject(new Error(message2.payload.message));
        }
      });
      this.send(message);
    });
  }
  async generateCodeStream(params, onChunk) {
    if (!this._isConnected) {
      try {
        await this.connect();
      } catch (error) {
        return Promise.reject(error);
      }
    }
    return new Promise((resolve, reject) => {
      const message = {
        type: "cell:generate_code",
        payload: {
          ...params,
          stream: true
        }
      };
      let completeCode = "";
      this.messageHandlers.set("cell:generated_code_chunk", (message2) => {
        if (message2.type === "cell:generated_code_chunk") {
          const chunk = message2.payload.content;
          completeCode += chunk;
          onChunk(chunk);
        }
      });
      this.messageHandlers.set("cell:generated_code_complete", (message2) => {
        if (message2.type === "cell:generated_code_complete") {
          resolve();
        }
      });
      this.messageHandlers.set("error", (message2) => {
        if (message2.type === "error") {
          reject(new Error(message2.payload.message));
        }
      });
      this.send(message);
    });
  }
  async suggestNextAction(params) {
    return new Promise((resolve, reject) => {
      if (!this._isConnected) {
        reject(new Error("Not connected to server"));
        return;
      }
      const message = {
        type: "cell:next_action_suggestion",
        payload: params
      };
      this.messageHandlers.set("cell:next_action_response", (message2) => {
        if (message2.type === "cell:next_action_response") {
          resolve(message2.payload.nextAction);
        }
      });
      this.messageHandlers.set("error", (message2) => {
        if (message2.type === "error") {
          reject(new Error(message2.payload.message));
        }
      });
      this.send(message);
    });
  }
  /**
   * @deprecated This method is deprecated. Please use sendUserMessageStream() instead.
   */
  async sendUserMessage(message, context) {
    console.warn("Warning: sendUserMessage() is deprecated. Please use sendUserMessageStream() instead.");
    return new Promise((resolve, reject) => {
      if (!this._isConnected) {
        reject(new Error("Not connected to server"));
        return;
      }
      const userMessage = {
        type: "agent:user_message",
        payload: {
          message,
          context
        }
      };
      this.messageHandlers.set("agent:agent_message", (message2) => {
        if (message2.type === "agent:agent_message") {
          resolve(message2.payload.message);
        }
      });
      this.messageHandlers.set("error", (message2) => {
        if (message2.type === "error") {
          reject(new Error(message2.payload.message));
        }
      });
      this.send(userMessage);
    });
  }
  async sendUserMessageStream(message, context, onMsgChunk) {
    if (!this._isConnected) {
      return Promise.reject(new Error("Not connected to server"));
    }
    return new Promise((resolve, reject) => {
      const userMessage = {
        type: "agent:user_message",
        payload: {
          message,
          context,
          stream: true
        }
      };
      let completeMessage = "";
      if (!context.tools) {
        context.tools = [];
      }
      const toolRouter = new ToolUseRouter();
      context.tools.forEach((tool) => {
        toolRouter.registerToolExecutor(tool.name, tool);
      });
      this.messageHandlers.set("agent:agent_message_chunk", (message2) => {
        if (message2.type === "agent:agent_message_chunk") {
          const chunk = message2.payload.content;
          completeMessage += chunk;
          onMsgChunk(chunk);
        }
      });
      this.messageHandlers.set("agent:agent_message_complete", (message2) => {
        if (message2.type === "agent:agent_message_complete") {
          resolve();
        }
      });
      this.messageHandlers.set("error", (message2) => {
        if (message2.type === "error") {
          reject(new Error(message2.payload.message));
        }
      });
      this.messageHandlers.set(
        "agent:tool_use_chunk",
        (message2) => {
          if (message2.type === "agent:tool_use_chunk") {
            toolRouter.handleMessage(message2, this.send.bind(this));
          }
        }
      );
      this.messageHandlers.set("agent:tool_use_complete", (message2) => {
        if (message2.type === "agent:tool_use_complete") {
          toolRouter.handleMessage(message2, this.send.bind(this));
        }
      });
      this.send(userMessage);
    });
  }
  async close() {
    if (this.ws) {
      return new Promise((resolve) => {
        this.ws.onclose = () => {
          this.ws = null;
          this._isConnected = false;
          this._isAuthenticated = false;
          this.messageHandlers.clear();
          this.messageQueue = [];
          resolve();
        };
        this.ws.close();
      });
    }
  }
  // Method intended ONLY for testing purposes
  _setConnected(state) {
    this._isConnected = state;
  }
  async createChat(title) {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    return new Promise((resolve, reject) => {
      this.messageHandlers.set("chat:created", (message) => {
        const payload = message.payload;
        const chat = payload.chat;
        this.currentChatId = chat.id;
        resolve(chat);
      });
      this.messageHandlers.set("chat:error", (message) => {
        reject(new Error(message.payload.error));
      });
      this.send({
        type: "chat:create",
        payload: { user_id: this.userId, title }
      });
    });
  }
  async setCurrentChatId(id) {
    this.currentChatId = id;
  }
  async getMessages(chatId, limit = 100, offset = 0) {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    return new Promise((resolve, reject) => {
      this.messageHandlers.set("chat:messages", (message) => {
        const payload = message.payload;
        resolve(payload.messages);
      });
      this.messageHandlers.set("chat:error", (message) => {
        reject(new Error(message.payload.error));
      });
      this.send({
        type: "chat:get_messages",
        payload: { chat_id: chatId, limit, offset }
      });
    });
  }
  async getChats() {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    return new Promise((resolve, reject) => {
      this.messageHandlers.set("chat:chats", (message) => {
        const payload = message.payload;
        resolve(payload.chats);
      });
      this.messageHandlers.set("chat:error", (message) => {
        reject(new Error(message.payload.error));
      });
      this.send({
        type: "chat:get_chats",
        payload: { user_id: this.userId }
      });
    });
  }
  async sendChatUserMessageStream(message, context, onMsgChunk) {
    if (!this._isConnected) {
      return Promise.reject(new Error("Not connected to server"));
    }
    if (!this.currentChatId) {
      return Promise.reject(new Error("No active chat"));
    }
    const chatId = this.currentChatId;
    return new Promise((resolve, reject) => {
      this.send({
        type: "chat:user_message",
        payload: {
          content: message,
          chat_id: chatId,
          role: "user",
          context: {
            currentNotebook: context.currentNotebook,
            selectedCells: context.selectedCells,
            attachedContexts: context.attachedContexts,
            tools: context.tools
          },
          stream: true
        }
      });
      this.messageHandlers.set("chat:started", () => {
      });
      this.messageHandlers.set("chat:chunk", (msg) => {
        const chunk = msg.payload.content;
        onMsgChunk(chunk);
      });
      this.messageHandlers.set("chat:completed", () => {
        resolve();
      });
      this.messageHandlers.set("chat:error", (msg) => {
        reject(new Error(msg.payload.error));
      });
    });
  }
  async generateChatTitle(message) {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    const chatId = this.currentChatId;
    if (!chatId) {
      throw new Error("No active chat selected to generate title for");
    }
    return new Promise((resolve, reject) => {
      const titleGeneratedHandler = (msg) => {
        if (msg.type === "chat:title_generated") {
          const titleGeneratedMsg = msg;
          this.messageHandlers.delete("chat:title_generated");
          this.messageHandlers.delete("chat:error");
          resolve(titleGeneratedMsg.payload.title);
        }
      };
      this.messageHandlers.set("chat:title_generated", titleGeneratedHandler);
      const errorHandler = (msg) => {
        if (msg.type === "error") {
          this.messageHandlers.delete("chat:title_generated");
          this.messageHandlers.delete("chat:error");
          reject(new Error(msg.payload.error));
        }
      };
      this.messageHandlers.set("chat:error", errorHandler);
      const titleRequest = {
        type: "chat:generate_title",
        payload: {
          message,
          chat_id: chatId
          // Use the non-null chatId
        }
      };
      this.send(titleRequest);
    });
  }
  async sendDocumentToIndex(file, link, name) {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    if (!file && !link) {
      throw new Error("No file or link provided");
    }
    return new Promise((resolve, reject) => {
      let contentFile = null;
      const processAndSend = () => {
        this.messageHandlers.set("index:finished", (message) => {
          const payload = message.payload;
          if (payload && payload.status === "success") {
            resolve();
          } else {
            reject(new Error("Failed to index document"));
          }
          this.messageHandlers.delete("index:finished");
          this.messageHandlers.delete("index:error");
        });
        this.messageHandlers.set("index:error", (message) => {
          const payload = message.payload;
          reject(new Error(payload.error));
          this.messageHandlers.delete("index:finished");
          this.messageHandlers.delete("index:error");
        });
        this.send({
          type: "index:document",
          payload: {
            file: contentFile,
            link,
            name,
            user_id: this.userId
          }
        });
      };
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          const base64File = reader.result;
          contentFile = base64File.split(",")[1];
          processAndSend();
        };
        reader.onerror = () => {
          reject(new Error("Error reading file"));
        };
        reader.readAsDataURL(file);
      } else {
        processAndSend();
      }
    });
  }
  async getIndexDocumentNames(type) {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    return new Promise((resolve, reject) => {
      this.messageHandlers.set("get_index_names:finished", (message) => {
        const payload = message.payload;
        if (payload && payload.status === "success") {
          resolve(payload.names);
        } else {
          reject(new Error("Failed to get index names"));
        }
        this.messageHandlers.delete("get_index_names:finished");
        this.messageHandlers.delete("index:error");
      });
      this.messageHandlers.set("index:error", (message) => {
        const payload = message.payload;
        reject(new Error(payload.error));
        this.messageHandlers.delete("get_index_names:finished");
        this.messageHandlers.delete("index:error");
      });
      this.send({
        type: "index:get_names",
        payload: { user_id: this.userId, type }
      });
    });
  }
  async deleteIndexDocumentName(name, type) {
    if (!this._isConnected || !this._isAuthenticated) {
      throw new Error("Not connected or not authenticated");
    }
    return new Promise((resolve, reject) => {
      this.messageHandlers.set("delete_index_name:finished", (message) => {
        const payload = message.payload;
        if (payload && payload.status === "success") {
          resolve();
        } else {
          reject(new Error("Failed to delete index name"));
        }
        this.messageHandlers.delete("delete_index_name:finished");
        this.messageHandlers.delete("index:error");
      });
      this.messageHandlers.set("index:error", (message) => {
        const payload = message.payload;
        reject(new Error(payload.error));
        this.messageHandlers.delete("delete_index_name:finished");
        this.messageHandlers.delete("index:error");
      });
      this.send({
        type: "index:delete_name",
        payload: { user_id: this.userId, name, type }
      });
    });
  }
};



/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jovyan_client_dist_index_js.ae491c26a3471cdda0e4.js.map