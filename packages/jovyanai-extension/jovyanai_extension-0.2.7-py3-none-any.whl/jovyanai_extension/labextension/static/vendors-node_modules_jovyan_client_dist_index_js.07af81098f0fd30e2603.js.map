{"version":3,"file":"vendors-node_modules_jovyan_client_dist_index_js.07af81098f0fd30e2603.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE,gBAAgB,qBAAM;AACxB,OAAO,qBAAM,cAAc,qBAAM;AACjC,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,IAAI;AACZ,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AAGE","sources":["webpack://@jovyanai/labextension/./node_modules/@jovyan/client/dist/index.js"],"sourcesContent":["// ../../node_modules/.pnpm/isomorphic-ws@5.0.0_ws@8.18.1/node_modules/isomorphic-ws/browser.js\nvar ws = null;\nif (typeof WebSocket !== \"undefined\") {\n  ws = WebSocket;\n} else if (typeof MozWebSocket !== \"undefined\") {\n  ws = MozWebSocket;\n} else if (typeof global !== \"undefined\") {\n  ws = global.WebSocket || global.MozWebSocket;\n} else if (typeof window !== \"undefined\") {\n  ws = window.WebSocket || window.MozWebSocket;\n} else if (typeof self !== \"undefined\") {\n  ws = self.WebSocket || self.MozWebSocket;\n}\nvar browser_default = ws;\n\n// src/core/logger.ts\nvar DefaultLogger = class {\n  debug(message, ...args) {\n    if (true) {\n      console.debug(`[DEBUG] ${message}`, ...args);\n    }\n  }\n  info(message, ...args) {\n    console.info(`[INFO] ${message}`, ...args);\n  }\n  warn(message, ...args) {\n    console.warn(`[WARN] ${message}`, ...args);\n  }\n  error(message, ...args) {\n    console.error(`[ERROR] ${message}`, ...args);\n  }\n};\n\n// src/services/tool_use.ts\nvar ToolUseRouter = class {\n  // Properties\n  toolExecutions;\n  executors;\n  constructor(executors = /* @__PURE__ */ new Map()) {\n    this.toolExecutions = /* @__PURE__ */ new Map();\n    this.executors = executors;\n  }\n  handleError(toolCallId, error, resultCallback) {\n    console.error(error);\n    resultCallback({\n      type: \"agent:tool_use_result\",\n      payload: {\n        toolCall: {\n          result: error,\n          toolCallId\n        }\n      }\n    });\n  }\n  // Route a message to the appropriate tool executor\n  handleMessage(message, resultCallback) {\n    const toolCallId = message.payload.toolCall.toolCallId;\n    if (this.toolExecutions.has(toolCallId)) {\n      const toolExecutor = this.toolExecutions.get(toolCallId);\n      if (toolExecutor) {\n        toolExecutor.handleMessage(message, resultCallback);\n      } else {\n        this.handleError(\n          toolCallId,\n          `Tool call ID ${toolCallId} not found in toolExecutions map.`,\n          resultCallback\n        );\n        return;\n      }\n    } else {\n      if (message.type == \"agent:tool_use_complete\") {\n        const err = `Tool call ID ${toolCallId} not found in toolExecutions map but received complete message.`;\n        this.handleError(\n          toolCallId,\n          err,\n          resultCallback\n        );\n        return;\n      }\n      const toolName = message.payload.toolCall.toolName;\n      const toolExecutor = this.executors.get(toolName);\n      if (toolExecutor) {\n        this.toolExecutions.set(toolCallId, toolExecutor);\n        toolExecutor.handleMessage(message, resultCallback);\n      } else {\n        this.handleError(\n          toolCallId,\n          `Tool executor for tool name ${toolName} not found.`,\n          resultCallback\n        );\n      }\n    }\n  }\n  // Register a tool executor for a specific tool\n  registerToolExecutor(toolName, executor) {\n    this.executors.set(toolName, executor);\n  }\n};\nvar toolUseRouter = new ToolUseRouter();\n\n// src/core/client.ts\nvar JovyanClient = class {\n  constructor(url, jwtToken, userId, logger) {\n    this.url = url;\n    this.jwtToken = jwtToken;\n    this.userId = userId;\n    this.logger = logger || new DefaultLogger();\n    this.currentToken = jwtToken;\n  }\n  ws = null;\n  sessionId = null;\n  currentChatId = null;\n  messageHandlers = /* @__PURE__ */ new Map();\n  chatHandlers = /* @__PURE__ */ new Map();\n  messageQueue = [];\n  _isConnected = false;\n  _isAuthenticated = false;\n  currentToken = null;\n  logger;\n  get isConnected() {\n    return this._isConnected;\n  }\n  get isAuthenticated() {\n    return this._isAuthenticated;\n  }\n  async connect() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new browser_default(this.url);\n        this.ws.onopen = async () => {\n          this.logger.info(\"Connected to Jovyan AI server\");\n          this._isConnected = true;\n          try {\n            await this.authenticate();\n            this.processMessageQueue();\n            resolve();\n          } catch (error) {\n            this.logger.error(\"Authentication failed:\", error);\n            reject(error);\n          }\n        };\n        this.ws.onerror = (event) => {\n          this.logger.error(\"WebSocket error:\", event);\n          this._isConnected = false;\n          reject(new Error(\"Connection failed\"));\n        };\n        this.ws.onclose = () => {\n          this._isConnected = false;\n          this._isAuthenticated = false;\n        };\n        this.setupMessageHandler();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  setupMessageHandler() {\n    if (!this.ws) return;\n    this.ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data.toString());\n        if (data.action && this.chatHandlers.has(data.action)) {\n          const handler2 = this.chatHandlers.get(data.action);\n          if (handler2) {\n            handler2(data);\n          }\n          return;\n        }\n        const message = data;\n        const handler = this.messageHandlers.get(message.type);\n        if (handler) {\n          handler(message);\n        }\n      } catch (error) {\n        this.logger.error(\"Error handling message:\", error);\n      }\n    };\n  }\n  async authenticate() {\n    return new Promise((resolve, reject) => {\n      if (!this._isConnected || !this.ws) {\n        reject(new Error(\"Not connected to server\"));\n        return;\n      }\n      this.messageHandlers.set(\"auth:success\", (message) => {\n        if (message.type === \"auth:success\") {\n          const authMessage2 = message;\n          this._isAuthenticated = true;\n          this.userId = authMessage2.payload.userId;\n          resolve();\n        }\n      });\n      this.messageHandlers.set(\"error\", (message) => {\n        if (message.type === \"error\") {\n          reject(new Error(message.payload.message));\n        }\n      });\n      const authMessage = {\n        type: \"auth\",\n        payload: {\n          token: this.currentToken\n        }\n      };\n      this.ws.send(JSON.stringify(authMessage));\n    });\n  }\n  processMessageQueue() {\n    while (this.messageQueue.length > 0 && this._isConnected && this._isAuthenticated) {\n      const message = this.messageQueue.shift();\n      if (message) {\n        this.send(message);\n      }\n    }\n  }\n  send(message) {\n    if (!this._isConnected || !this._isAuthenticated) {\n      this.messageQueue.push(message);\n      return;\n    }\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n  async startSession() {\n    return new Promise((resolve, reject) => {\n      if (!this._isConnected || !this._isAuthenticated) {\n        reject(new Error(\"Not connected or not authenticated\"));\n        return;\n      }\n      const startMessage = {\n        type: \"session:start\",\n        payload: { userId: this.userId }\n      };\n      this.messageHandlers.set(\"session:started\", (message) => {\n        if (message.type === \"session:started\") {\n          this.sessionId = message.payload.sessionId;\n          if (this.sessionId) {\n            resolve(this.sessionId);\n          } else {\n            reject(new Error(\"Session ID is null\"));\n          }\n        }\n      });\n      this.send(startMessage);\n    });\n  }\n  /**\n   * @deprecated This method is deprecated. Please use generateCodeStream() instead.\n   */\n  async generateCode(params) {\n    console.warn(\"Warning: generateCode() is deprecated. Please use generateCodeStream() instead.\");\n    return new Promise((resolve, reject) => {\n      if (!this._isConnected) {\n        reject(new Error(\"Not connected to server\"));\n        return;\n      }\n      const message = {\n        type: \"cell:generate_code\",\n        payload: params\n      };\n      this.messageHandlers.set(\"cell:generated_code\", (message2) => {\n        if (message2.type === \"cell:generated_code\") {\n          resolve(message2.payload.generatedCode);\n        }\n      });\n      this.messageHandlers.set(\"error\", (message2) => {\n        if (message2.type === \"error\") {\n          reject(new Error(message2.payload.message));\n        }\n      });\n      this.send(message);\n    });\n  }\n  async generateCodeStream(params, onChunk) {\n    if (!this._isConnected) {\n      try {\n        await this.connect();\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const message = {\n        type: \"cell:generate_code\",\n        payload: {\n          ...params,\n          stream: true\n        }\n      };\n      let completeCode = \"\";\n      this.messageHandlers.set(\"cell:generated_code_chunk\", (message2) => {\n        if (message2.type === \"cell:generated_code_chunk\") {\n          const chunk = message2.payload.content;\n          completeCode += chunk;\n          onChunk(chunk);\n        }\n      });\n      this.messageHandlers.set(\"cell:generated_code_complete\", (message2) => {\n        if (message2.type === \"cell:generated_code_complete\") {\n          resolve();\n        }\n      });\n      this.messageHandlers.set(\"error\", (message2) => {\n        if (message2.type === \"error\") {\n          reject(new Error(message2.payload.message));\n        }\n      });\n      this.send(message);\n    });\n  }\n  async suggestNextAction(params) {\n    return new Promise((resolve, reject) => {\n      if (!this._isConnected) {\n        reject(new Error(\"Not connected to server\"));\n        return;\n      }\n      const message = {\n        type: \"cell:next_action_suggestion\",\n        payload: params\n      };\n      this.messageHandlers.set(\"cell:next_action_response\", (message2) => {\n        if (message2.type === \"cell:next_action_response\") {\n          resolve(message2.payload.nextAction);\n        }\n      });\n      this.messageHandlers.set(\"error\", (message2) => {\n        if (message2.type === \"error\") {\n          reject(new Error(message2.payload.message));\n        }\n      });\n      this.send(message);\n    });\n  }\n  /**\n   * @deprecated This method is deprecated. Please use sendUserMessageStream() instead.\n   */\n  async sendUserMessage(message, context) {\n    console.warn(\"Warning: sendUserMessage() is deprecated. Please use sendUserMessageStream() instead.\");\n    return new Promise((resolve, reject) => {\n      if (!this._isConnected) {\n        reject(new Error(\"Not connected to server\"));\n        return;\n      }\n      const userMessage = {\n        type: \"agent:user_message\",\n        payload: {\n          message,\n          context\n        }\n      };\n      this.messageHandlers.set(\"agent:agent_message\", (message2) => {\n        if (message2.type === \"agent:agent_message\") {\n          resolve(message2.payload.message);\n        }\n      });\n      this.messageHandlers.set(\"error\", (message2) => {\n        if (message2.type === \"error\") {\n          reject(new Error(message2.payload.message));\n        }\n      });\n      this.send(userMessage);\n    });\n  }\n  async sendUserMessageStream(message, context, onMsgChunk) {\n    if (!this._isConnected) {\n      return Promise.reject(new Error(\"Not connected to server\"));\n    }\n    return new Promise((resolve, reject) => {\n      const userMessage = {\n        type: \"agent:user_message\",\n        payload: {\n          message,\n          context,\n          stream: true\n        }\n      };\n      let completeMessage = \"\";\n      if (!context.tools) {\n        context.tools = [];\n      }\n      const toolRouter = new ToolUseRouter();\n      context.tools.forEach((tool) => {\n        toolRouter.registerToolExecutor(tool.name, tool);\n      });\n      this.messageHandlers.set(\"agent:agent_message_chunk\", (message2) => {\n        if (message2.type === \"agent:agent_message_chunk\") {\n          const chunk = message2.payload.content;\n          completeMessage += chunk;\n          onMsgChunk(chunk);\n        }\n      });\n      this.messageHandlers.set(\"agent:agent_message_complete\", (message2) => {\n        if (message2.type === \"agent:agent_message_complete\") {\n          resolve();\n        }\n      });\n      this.messageHandlers.set(\"error\", (message2) => {\n        if (message2.type === \"error\") {\n          reject(new Error(message2.payload.message));\n        }\n      });\n      this.messageHandlers.set(\n        \"agent:tool_use_chunk\",\n        (message2) => {\n          if (message2.type === \"agent:tool_use_chunk\") {\n            toolRouter.handleMessage(message2, this.send.bind(this));\n          }\n        }\n      );\n      this.messageHandlers.set(\"agent:tool_use_complete\", (message2) => {\n        if (message2.type === \"agent:tool_use_complete\") {\n          toolRouter.handleMessage(message2, this.send.bind(this));\n        }\n      });\n      this.send(userMessage);\n    });\n  }\n  async close() {\n    if (this.ws) {\n      return new Promise((resolve) => {\n        this.ws.onclose = () => {\n          this.ws = null;\n          this._isConnected = false;\n          this._isAuthenticated = false;\n          this.messageHandlers.clear();\n          this.messageQueue = [];\n          resolve();\n        };\n        this.ws.close();\n      });\n    }\n  }\n  // Method intended ONLY for testing purposes\n  _setConnected(state) {\n    this._isConnected = state;\n  }\n  async createChat(title) {\n    if (!this._isConnected || !this._isAuthenticated) {\n      throw new Error(\"Not connected or not authenticated\");\n    }\n    return new Promise((resolve, reject) => {\n      this.messageHandlers.set(\"chat:created\", (message) => {\n        const payload = message.payload;\n        const chat = payload.chat;\n        this.currentChatId = chat.id;\n        resolve(chat);\n      });\n      this.messageHandlers.set(\"chat:error\", (message) => {\n        reject(new Error(message.payload.error));\n      });\n      this.send({\n        type: \"chat:create\",\n        payload: { user_id: this.userId, title }\n      });\n    });\n  }\n  async setCurrentChatId(id) {\n    this.currentChatId = id;\n  }\n  async getMessages(chatId, limit = 100, offset = 0) {\n    if (!this._isConnected || !this._isAuthenticated) {\n      throw new Error(\"Not connected or not authenticated\");\n    }\n    return new Promise((resolve, reject) => {\n      this.messageHandlers.set(\"chat:messages\", (message) => {\n        const payload = message.payload;\n        resolve(payload.messages);\n      });\n      this.messageHandlers.set(\"chat:error\", (message) => {\n        reject(new Error(message.payload.error));\n      });\n      this.send({\n        type: \"chat:get_messages\",\n        payload: { chat_id: chatId, limit, offset }\n      });\n    });\n  }\n  async getChats() {\n    if (!this._isConnected || !this._isAuthenticated) {\n      throw new Error(\"Not connected or not authenticated\");\n    }\n    return new Promise((resolve, reject) => {\n      this.messageHandlers.set(\"chat:chats\", (message) => {\n        const payload = message.payload;\n        resolve(payload.chats);\n      });\n      this.messageHandlers.set(\"chat:error\", (message) => {\n        reject(new Error(message.payload.error));\n      });\n      this.send({\n        type: \"chat:get_chats\",\n        payload: { user_id: this.userId }\n      });\n    });\n  }\n  async sendChatUserMessageStream(message, context, onMsgChunk) {\n    if (!this._isConnected) {\n      return Promise.reject(new Error(\"Not connected to server\"));\n    }\n    if (!this.currentChatId) {\n      return Promise.reject(new Error(\"No active chat\"));\n    }\n    const chatId = this.currentChatId;\n    return new Promise((resolve, reject) => {\n      this.send({\n        type: \"chat:user_message\",\n        payload: {\n          content: message,\n          chat_id: chatId,\n          role: \"user\",\n          context: {\n            currentNotebook: context.currentNotebook,\n            selectedCells: context.selectedCells,\n            tools: context.tools\n          },\n          stream: true\n        }\n      });\n      this.messageHandlers.set(\"chat:started\", () => {\n      });\n      this.messageHandlers.set(\"chat:chunk\", (msg) => {\n        const chunk = msg.payload.content;\n        onMsgChunk(chunk);\n      });\n      this.messageHandlers.set(\"chat:completed\", () => {\n        resolve();\n      });\n      this.messageHandlers.set(\"chat:error\", (msg) => {\n        reject(new Error(msg.payload.error));\n      });\n    });\n  }\n  async generateChatTitle(message) {\n    if (!this._isConnected || !this._isAuthenticated) {\n      throw new Error(\"Not connected or not authenticated\");\n    }\n    const chatId = this.currentChatId;\n    if (!chatId) {\n      throw new Error(\"No active chat selected to generate title for\");\n    }\n    return new Promise((resolve, reject) => {\n      const titleGeneratedHandler = (msg) => {\n        if (msg.type === \"chat:title_generated\") {\n          const titleGeneratedMsg = msg;\n          this.messageHandlers.delete(\"chat:title_generated\");\n          this.messageHandlers.delete(\"chat:error\");\n          resolve(titleGeneratedMsg.payload.title);\n        }\n      };\n      this.messageHandlers.set(\"chat:title_generated\", titleGeneratedHandler);\n      const errorHandler = (msg) => {\n        if (msg.type === \"error\") {\n          this.messageHandlers.delete(\"chat:title_generated\");\n          this.messageHandlers.delete(\"chat:error\");\n          reject(new Error(msg.payload.error));\n        }\n      };\n      this.messageHandlers.set(\"chat:error\", errorHandler);\n      const titleRequest = {\n        type: \"chat:generate_title\",\n        payload: {\n          message,\n          chat_id: chatId\n          // Use the non-null chatId\n        }\n      };\n      this.send(titleRequest);\n    });\n  }\n};\nexport {\n  JovyanClient\n};\n"],"names":[],"sourceRoot":""}