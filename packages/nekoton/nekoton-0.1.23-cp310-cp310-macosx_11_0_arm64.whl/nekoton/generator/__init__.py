import json
import re
from typing import Optional, List, Dict

from nekoton import ContractAbi


def generate(name: str, abi: str) -> str:
    return GeneratorContext().generate(name, abi)


class InternalStruct:
    def __init__(self, name: str, decl: str):
        self.name = name
        self.decl = decl


class InternalFunction:
    def __init__(self, abi_name: str, inputs_ty: str, outputs_ty: str, struct: InternalStruct):
        self.abi_name = abi_name
        self.inputs_ty = inputs_ty
        self.outputs_ty = outputs_ty
        self.struct = struct


class MethodBuilder:
    def __init__(self, name: str, args: dict, res: Optional[str]) -> None:
        def optional_type(ty: Optional[str]) -> str:
            return "" if ty is None else f": {ty}"

        self.head = f"def {name}("
        self.head += ", ".join(f"{arg}{optional_type(ty)}" for arg, ty in args.items())
        if res is not None:
            self.head += f") -> {res}:"
        else:
            self.head += "):"
        self.body = None

    def with_body(self, body) -> 'MethodBuilder':
        self.body = body
        return self

    def generate(self, indent: int) -> str:
        result = f"{indent_text(self.head, indent)}\n"
        if self.body is None:
            result += indent_text("pass", indent + 1)
        else:
            result += indent_text(self.body, indent + 1)
        return result


class ClassBuilder:
    def __init__(self, name: str) -> None:
        self.head = f"class {name}"
        self.derive = []
        self.fields = []
        self.methods = []

    def with_base(self, base: str) -> 'ClassBuilder':
        self.derive.append(base)
        return self

    def with_field(self, name: str, ty: str) -> 'ClassBuilder':
        self.fields.append((name, ty))
        return self

    def with_method(self, method: MethodBuilder, attributes: List[str] = []) -> 'ClassBuilder':
        self.methods.append((method, attributes))
        return self

    def generate(self) -> str:
        derive = ",".join(self.derive)
        result = f"{self.head}({derive}):\n"

        for name, ty in self.fields:
            result += f"    {name}: {ty}\n"

        for method, attributes in self.methods:
            for attribute in attributes:
                result += f"    {attribute}\n"
            result += f"{method.generate(1)}\n\n"

        if not self.fields and not self.methods:
            result += "    pass"

        return result.strip() + "\n"


class ImportsBuilder:
    def __init__(self, name: str):
        self.name = name
        self.imports = set()

    def import_ty(self, ty: str) -> str:
        self.imports.add(ty)
        return privatize(ty)

    def generate(self) -> str:
        if not self.imports:
            return ""
        result = f"from {self.name} import "
        return result + ", ".join(f"{s} as {privatize(s)}" for s in self.imports)


class InvalidTypeError(ValueError):
    def __init__(self, ty: str):
        ValueError.__init__(self, "Invalid type: '%s'" % ty)


class GeneratorContext:
    _internal_structs: Dict[str, str] = {}
    _internal_structs_decl: str = ""
    _unknown_struct_count: int = 0

    _from_typing = ImportsBuilder("typing")
    _from_nekoton = ImportsBuilder("nekoton")

    def __init__(self):
        self.generated = ""

    def generate(self, name: str, abi: str) -> str:
        abi_class_decl = self.generate_abi_class(name, abi)

        return f'''"""
This file was auto generated by nekoton.
"""

{self._from_typing.generate()}
{self._from_nekoton.generate()}

{abi_class_decl}
'''

    def generate_abi_class(self, name: str, abi: str) -> str:
        ContractAbi(abi)
        parsed_abi = json.loads(abi)

        class_name = pascalize(name)
        functions = parsed_abi["functions"]

        abi_object = class_name.upper() + "_ABI"
        abi_object_decl = '%s = %s(r"""%s""")\n\n' % (
           abi_object, self._from_nekoton.import_ty("ContractAbi"), json.dumps(parsed_abi))

        result = ClassBuilder(class_name + "Abi")
        function_classes_decl = ""
        for function in functions:
            function_class = self.generate_function(class_name, function)
            function_classes_decl += f"{function_class.struct.decl}\n\n"

            member_name = depascalize(pascalize(function_class.abi_name))
            method = MethodBuilder(member_name, {}, function_class.struct.name).with_body(
                f'return {abi_object}.get_function("{function_class.abi_name}")'
            )
            result.with_method(method, ["@staticmethod"])
        class_decl = result.generate()

        return f"""
{abi_object_decl}

{self._internal_structs_decl}

{function_classes_decl}

{class_decl}
"""

    def generate_function(self, base_class: str, function: dict) -> InternalFunction:
        name = function["name"]
        inputs = function["inputs"]
        outputs = function["outputs"]

        name_struct = pascalize(name)
        inputs_ty = self.generate_tuple(inputs, name_struct + "Input", cache_signature=False)
        outputs_ty = self.generate_tuple(outputs, name_struct + "Output", cache_signature=False)

        function_ty = base_class + pascalize(name) + "Function"
        function_call_ty = function_ty + "Call"

        function_call_base_ty = self._from_nekoton.import_ty("FunctionCall")
        function_call_input_method = MethodBuilder("input", {"self": None}, inputs_ty).with_body(
            f"return {function_call_base_ty}.input"
        )
        function_call_output_method = MethodBuilder("output", {"self": None}, outputs_ty).with_body(
            f"return {function_call_base_ty}.output"
        )
        function_call = ClassBuilder(function_ty + "Call").with_base(function_call_base_ty)\
            .with_method(function_call_input_method, ['@property'])\
            .with_method(function_call_output_method, ['@property'])
        self._internal_structs_decl +=  f"{function_call.generate()}\n\n"

        function_abi_ty = self._from_nekoton.import_ty("FunctionAbi")
        function_with_args_ty = self._from_nekoton.import_ty("FunctionAbiWithArgs")

        with_args_method = MethodBuilder("with_args", {
            "self": None,
            "args": inputs_ty,
        }, function_with_args_ty).with_body(f"return {function_abi_ty}.with_args(self, args)")

        decode_transaction = MethodBuilder("decode_transaction", {
            "self": None,
            "transaction": self._from_nekoton.import_ty("Transaction")
        }, function_call_ty).with_body(f"return {function_abi_ty}.decode_transaction(transaction)")

        decode_input_method = MethodBuilder("decode_input", {
            "self": None,
            "message_body": self._from_nekoton.import_ty("Cell"),
            "internal": "bool",
            "allow_partial": f'{self._from_typing.import_ty("Optional")}[bool] = None',
        }, inputs_ty).with_body(
            f"return {function_abi_ty}.decode_input(self, message_body, internal, allow_partial)"
        )

        decode_output_method = MethodBuilder("decode_output", {
            "self": None,
            "message_body": self._from_nekoton.import_ty("Cell"),
            "allow_partial": f'{self._from_typing.import_ty("Optional")}[bool] = None',
        }, outputs_ty).with_body(
            f"return {function_abi_ty}.decode_output(self, message_body, allow_partial)"
        )

        result = ClassBuilder(function_ty).with_base(function_abi_ty)\
            .with_method(with_args_method)\
            .with_method(decode_input_method)\
            .with_method(decode_output_method)\
            .with_method(decode_transaction)\
            .generate()
        return InternalFunction(name, inputs_ty, outputs_ty, InternalStruct(function_ty, result))

    def generate_type(self, ty: str, components: Optional[List[dict]]) -> str:
        if ty == "":
            raise InvalidTypeError(ty)

        elif ty.endswith("]"):
            len_idx = ty.rfind('[')
            if len_idx == -1:
                raise InvalidTypeError(ty)
            value_ty = self.generate_type(ty[:len_idx], components)
            return "%s[%s]" % (self._from_typing.import_ty("List"), value_ty)

        elif ty == "tuple":
            if components is None:
                raise ValueError("Tuple description requires components")
            return self.generate_tuple(components, None, cache_signature=True)

        elif ty.startswith("optional("):
            if not ty.endswith(")"):
                raise InvalidTypeError(ty)
            value_ty = self.generate_type(ty[ty.find("(") + 1:-1], components)
            return "%s[%s]" % (self._from_typing.import_ty("Optional"), value_ty)

        elif ty.startswith("ref("):
            if not ty.endswith(")"):
                raise InvalidTypeError(ty)
            return self.generate_type(ty[ty.find("(") + 1:-1], components)

        elif ty.startswith("map("):
            if not ty.endswith(")"):
                raise InvalidTypeError(ty)

            key_ty_idx = ty.find("(") + 1
            delim_idx = ty.find(",")
            if delim_idx == -1:
                raise InvalidTypeError(ty)

            key_ty = self.generate_type(ty[key_ty_idx:delim_idx], None)
            value_ty = self.generate_type(ty[delim_idx + 1:-1], components)

            return "%s[%s, %s]" % (self._from_typing.import_ty("Dict"), key_ty, value_ty)

        elif ty == "bool":
            return ty

        elif ty.startswith("int") or ty.startswith("uint") or \
                ty.startswith("varint") or ty.startswith("varuint") or \
                ty.startswith("time") or ty.startswith("expire"):
            return "int | %s" % self._from_nekoton.import_ty("Tokens")

        elif ty == "cell":
            return self._from_nekoton.import_ty("Cell")

        elif ty == "address":
            return self._from_nekoton.import_ty("Address")

        elif ty == "token" or ty == "gram":
            return self._from_nekoton.import_ty("Tokens")

        elif ty == "string":
            return "str"

        elif ty == "bytes" or ty.startswith("fixedbytes"):
            return "bytes"

        elif ty == "pubkey":
            return self._from_nekoton.import_ty("PublicKey")

        else:
            raise InvalidTypeError(ty)

    def generate_tuple(self, components: List[dict], name: Optional[str], cache_signature: bool) -> str:
        type_signature = ""
        if cache_signature:
            type_signature = compute_tuple_signature(components)
            existing_structure = self._internal_structs.get(type_signature)
            if existing_structure is not None:
                return existing_structure

        is_unknown = name is None
        if is_unknown:
            name = "InternalStruct%d" % self._unknown_struct_count

        result = ClassBuilder(name).with_base(self._from_typing.import_ty("TypedDict"))
        for component in components:
            field_name = component["name"]
            field_ty = component["type"]
            field_components = component.get("components")
            result.with_field(field_name, self.generate_type(field_ty, field_components))

        if cache_signature:
            self._internal_structs[type_signature] = name

        self._internal_structs_decl += f"{result.generate()}\n\n"
        if is_unknown:
            self._unknown_struct_count += 1

        return name


def compute_type_signature(ty: str, components: Optional[List[dict]]) -> str:
    if "tuple" in ty:
        if components is None:
            raise ValueError("Tuple description requires components")
        inner = compute_tuple_signature(components)
        return ty.replace("tuple", inner)
    else:
        return ty


def compute_tuple_signature(components: List[dict]) -> str:
    result = "("
    for component in components:
        ty = component["type"]

        if result != "(":
            result += ","
        result += compute_type_signature(ty, component.get("components"))

    result += ")"
    return result


def pascalize(inp: str) -> str:
    s = re.sub(r"\s+", "", inp)
    if s.isupper() or s.isnumeric():
        return s

    s = PASCAL_RE.sub(lambda m: m.group(1)[0].upper() + m.group(1)[1:], s)
    if len(s) != 0 and not s[:2].isupper():
        s = s[0].lower() + s[1:]

    s = UNDERSCORE_RE.sub(lambda m: m.group(0)[-1].upper(), s)
    return s[0].upper() + s[1:] if len(s) != 0 else s


def depascalize(s: str) -> str:
    s = ACRONYM_RE.sub(lambda m: m.group(0).title(), s)
    return "_".join(s for s in SPLIT_RE.split(s) if s).lower()


def privatize(ty: str) -> str:
    return "_%s" % ty


def indent_text(text: str, level: int) -> str:
    indent = ' ' * (4 * level)
    lines = text.strip().split("\n")
    return "\n".join(f"{indent}{line}" for line in lines)


ACRONYM_RE = re.compile(r"([A-Z\d]+)(?=[A-Z\d]|$)")
PASCAL_RE = re.compile(r"([^\-_]+)")
SPLIT_RE = re.compile(r"([\-_]*[A-Z][^A-Z]*[\-_]*)")
UNDERSCORE_RE = re.compile(r"(?<=[^\-_])[\-_]+[^\-_]")
