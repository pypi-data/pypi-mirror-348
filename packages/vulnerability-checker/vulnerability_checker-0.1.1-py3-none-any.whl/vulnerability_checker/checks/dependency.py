"""
Проверка зависимостей на известные уязвимости.
"""

import os
import re
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple

from vulnerability_checker.checks.base import BaseCheck
from vulnerability_checker.models import CheckResult, CheckStatus, VulnerabilityIssue


class DependencyCheck(BaseCheck):
    """
    Проверка зависимостей на известные уязвимости.
    """
    
    name = "dependency-check"
    description = "Проверка зависимостей на известные уязвимости"
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.severity_map = {
            "high": "high",
            "medium": "medium",
            "low": "low",
        }
    
    def run(self, target_path: str, **kwargs) -> Tuple[CheckResult, List[VulnerabilityIssue]]:
        """
        Запуск проверки зависимостей.
        
        Args:
            target_path: Путь к директории или файлу для проверки
            **kwargs: Дополнительные параметры
            
        Returns:
            Tuple[CheckResult, List[VulnerabilityIssue]]: Результат проверки и список найденных уязвимостей
        """
        self.issues = []
        
        try:
            # Поиск файлов с зависимостями
            requirements_files = self._find_requirements_files(target_path)
            
            if not requirements_files:
                # Если файлы с зависимостями не найдены, проверяем установленные пакеты
                self._check_installed_packages()
            else:
                # Проверка каждого файла с зависимостями
                for req_file in requirements_files:
                    self._check_requirements_file(req_file)
            
            # Формирование результата
            status = CheckStatus.PASSED if not self.issues else CheckStatus.FAILED
            result = self.create_result(
                status=status,
                message=f"Найдено {len(self.issues)} уязвимостей в зависимостях" if self.issues else "Уязвимостей в зависимостях не обнаружено",
            )
            
            return result, self.issues
            
        except Exception as e:
            # В случае ошибки возвращаем статус ERROR
            result = self.create_result(
                status=CheckStatus.ERROR,
                message=f"Ошибка при проверке зависимостей: {str(e)}",
            )
            return result, self.issues
    
    def _find_requirements_files(self, target_path: str) -> List[str]:
        """
        Поиск файлов с зависимостями в директории.
        
        Args:
            target_path: Путь к директории
            
        Returns:
            List[str]: Список путей к файлам с зависимостями
        """
        requirements_files = []
        
        path = Path(target_path)
        if path.is_file():
            # Если target_path это файл, проверяем является ли он файлом с зависимостями
            if self._is_requirements_file(path.name) and not self.should_exclude_path(path):
                requirements_files.append(str(path))
            return requirements_files
        
        # Обход директории
        for root, dirs, files in os.walk(path):
            # Фильтруем директории, которые нужно исключить
            dirs[:] = [d for d in dirs if not self.should_exclude_path(os.path.join(root, d))]
            
            for file in files:
                file_path = os.path.join(root, file)
                if self._is_requirements_file(file) and not self.should_exclude_path(file_path):
                    requirements_files.append(file_path)
        
        return requirements_files
    
    def _is_requirements_file(self, filename: str) -> bool:
        """
        Проверка, является ли файл файлом с зависимостями.
        
        Args:
            filename: Имя файла
            
        Returns:
            bool: True, если файл с зависимостями
        """
        return (
            filename == "requirements.txt" or 
            filename.startswith("requirements") and filename.endswith(".txt") or
            filename == "Pipfile" or
            filename == "Pipfile.lock" or
            filename == "pyproject.toml" or
            filename == "setup.py"
        )
    
    def _check_requirements_file(self, requirements_file: str) -> None:
        """
        Проверка файла с зависимостями на уязвимости.
        
        Args:
            requirements_file: Путь к файлу с зависимостями
        """
        try:
            # Преобразование формата файла при необходимости
            if not requirements_file.endswith(".txt"):
                requirements_txt = self._convert_to_requirements_txt(requirements_file)
                if not requirements_txt:
                    return
            else:
                requirements_txt = requirements_file
            
            # Проверка зависимостей с помощью safety
            try:
                # Чтение содержимого файла с зависимостями
                with open(requirements_txt, 'r') as f:
                    requirements_content = f.read()
                
                # Используем новый интерфейс API для safety 3.x
                from safety.scan import scan as safety_scan
                result = safety_scan(
                    stdin=requirements_content,
                    full_report=True,
                    ignore_ids=self.config.get("ignore_vulns", []),
                    ignore_file=self.config.get("ignore_file"),
                )
                vulns = result.get("vulnerabilities", [])
            except Exception as e:
                print(f"Внимание: ошибка при проверке зависимостей: {str(e)}")
                vulns = []
            
            # Обработка результатов
            for vuln in vulns:
                package_name = vuln[0]
                affected_version = vuln[1]
                vulnerability_id = vuln[2]
                vulnerability_details = vuln[3]
                
                # Добавление уязвимости в список
                self.add_issue(
                    issue_type="Vulnerable Dependency",
                    severity="high",  # Обычно уязвимости в зависимостях считаются высокими по умолчанию
                    description=f"Уязвимость в зависимости: {package_name} {affected_version} - {vulnerability_details}",
                    file_path=requirements_file,
                    line_number=self._find_package_line(requirements_file, package_name),
                    code_snippet=f"{package_name}=={affected_version}",
                    confidence="HIGH",
                    cwe_id=None,
                    owasp_category="A9:2017-Using Components with Known Vulnerabilities",
                    remediation=f"Обновите пакет {package_name} до безопасной версии или замените его альтернативой.",
                )
                
        except Exception as e:
            # Пропускаем файлы с ошибками
            print(f"Ошибка при проверке {requirements_file}: {str(e)}")
    
    def _convert_to_requirements_txt(self, file_path: str) -> Optional[str]:
        """
        Конвертация других форматов файлов зависимостей в requirements.txt.
        
        Args:
            file_path: Путь к файлу с зависимостями
            
        Returns:
            Optional[str]: Путь к сгенерированному requirements.txt или None в случае ошибки
        """
        try:
            # Временный файл для requirements.txt
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".txt")
            temp_file.close()
            
            # Конвертация в зависимости от типа файла
            if file_path.endswith("setup.py"):
                subprocess.run(
                    ["pip", "install", "-e", os.path.dirname(file_path)],
                    check=True,
                    capture_output=True,
                )
                subprocess.run(
                    ["pip", "freeze", "-l"],
                    check=True,
                    stdout=open(temp_file.name, "w"),
                )
                
            elif file_path.endswith("Pipfile") or file_path.endswith("Pipfile.lock"):
                subprocess.run(
                    ["pipenv", "lock", "-r"],
                    check=True,
                    cwd=os.path.dirname(file_path),
                    stdout=open(temp_file.name, "w"),
                )
                
            elif file_path.endswith("pyproject.toml"):
                try:
                    if os.path.exists(os.path.join(os.path.dirname(file_path), "poetry.lock")):
                        try:
                            # Попытка использовать poetry export
                            result = subprocess.run(
                                ["poetry", "export", "-f", "requirements.txt"],
                                capture_output=True,
                                text=True,
                                cwd=os.path.dirname(file_path),
                                check=False,  # Не выбрасывать исключение при ошибке
                            )
                            
                            # Проверяем успешность выполнения
                            if result.returncode == 0:
                                with open(temp_file.name, "w") as f:
                                    f.write(result.stdout)
                            else:
                                # Если poetry export не сработал, переходим к парсингу файла
                                raise Exception(f"Poetry export failed: {result.stderr}")
                        except Exception as e:
                            print(f"Ошибка при использовании poetry export: {str(e)}. Используем ручной парсинг.")
                            # Переходим к ручному парсингу
                            raise Exception("Fallback to manual parsing")
                    else:
                        # Нет poetry.lock, используем ручной парсинг
                        raise Exception("No poetry.lock found")
                        
                except Exception:
                    # Используем ручной парсинг в случае любых проблем с poetry
                    print(f"Извлекаем зависимости из {file_path} вручную")
                    with open(file_path, "r") as f:
                        content = f.read()
                    
                    dependencies = []
                    # Проверяем разные форматы определения зависимостей в pyproject.toml
                    
                    # Формат 1: dependencies = [...]
                    array_pattern = r"dependencies\s*=\s*\[(.*?)\]"
                    array_match = re.search(array_pattern, content, re.DOTALL)
                    if array_match:
                        deps = array_match.group(1)
                        for dep in re.finditer(r'"(.*?)"', deps):
                            dependencies.append(dep.group(1))
                    
                    # Формат 2: [tool.poetry.dependencies] или [project.dependencies]
                    table_patterns = [
                        r"\[tool\.poetry\.dependencies\](.*?)(\[|\Z)",
                        r"\[project\.dependencies\](.*?)(\[|\Z)"
                    ]
                    
                    for pattern in table_patterns:
                        table_match = re.search(pattern, content, re.DOTALL)
                        if table_match:
                            section = table_match.group(1)
                            # Ищем зависимости в формате "package = "version"
                            for dep_match in re.finditer(r'([a-zA-Z0-9_-]+)\s*=\s*["\'](.*?)["\']', section):
                                package_name = dep_match.group(1)
                                if package_name != "python":  # Игнорируем требование к версии python
                                    dependencies.append(package_name)
                    
                    with open(temp_file.name, "w") as f:
                        for dep in dependencies:
                            f.write(f"{dep}\n")
            
            return temp_file.name
            
        except Exception as e:
            print(f"Ошибка при конвертации {file_path}: {str(e)}")
            return None
    
    def _check_installed_packages(self) -> None:
        """
        Проверка установленных пакетов на уязвимости.
        """
        try:
            # Создание временного файла с установленными пакетами
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".txt")
            temp_file.close()
            
            # Получение списка установленных пакетов
            subprocess.run(
                ["pip", "freeze"],
                check=True,
                stdout=open(temp_file.name, "w"),
            )
            
            # Проверка зависимостей
            self._check_requirements_file(temp_file.name)
            
            # Удаление временного файла
            os.unlink(temp_file.name)
            
        except Exception as e:
            print(f"Ошибка при проверке установленных пакетов: {str(e)}")
    
    def _find_package_line(self, file_path: str, package_name: str) -> int:
        """
        Поиск номера строки с пакетом в файле.
        
        Args:
            file_path: Путь к файлу
            package_name: Имя пакета
            
        Returns:
            int: Номер строки с пакетом или 1, если не найден
        """
        try:
            with open(file_path, "r") as f:
                lines = f.readlines()
                
            for i, line in enumerate(lines):
                if line.strip().startswith(package_name):
                    return i + 1
                
            return 1
            
        except Exception:
            return 1 