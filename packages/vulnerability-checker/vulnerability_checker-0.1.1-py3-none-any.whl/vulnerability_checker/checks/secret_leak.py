"""
Проверка на утечку секретов (API ключей, паролей и т.д.).
"""

import os
import re
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Set

from vulnerability_checker.checks.base import BaseCheck
from vulnerability_checker.models import CheckResult, CheckStatus, VulnerabilityIssue


class SecretLeakCheck(BaseCheck):
    """
    Проверка на утечку секретов (API ключей, паролей и т.д.).
    """
    
    name = "secret-leak"
    description = "Проверка на утечку секретов (API ключей, паролей и т.д.)"
    
    # Паттерны для поиска потенциальных секретов
    SECRET_PATTERNS = [
        # Приватные ключи
        (r"-----BEGIN( RSA)? PRIVATE KEY-----", "Private Key", "critical"),
        
        # Токены доступа
        (r"(access_token|access-token|api[_-]?key|api[_-]?secret|secret[_-]?key)\s*=\s*['\"]([A-Za-z0-9_\-\.]{20,})['\"]", "API Key/Token", "high"),
        
        # AWS ключи
        (r"AKIA[0-9A-Z]{16}", "AWS Access Key", "critical"),
        
        # GitHub токены
        (r"github_token\s*=\s*['\"]([A-Za-z0-9_\-\.]{36,})['\"]", "GitHub Token", "high"),
        
        # Firebase URL
        (r"https://[a-z0-9-]+\.firebaseio\.com", "Firebase URL", "medium"),
        
        # URL с логином/паролем
        (r"[a-zA-Z]{3,10}://[^/\s:@]+:[^/\s:@]+@[^/\s:@]+", "URL with credentials", "high"),
        
        # Пароли
        (r"password\s*=\s*['\"]([^'\"]{4,})['\"]", "Password", "high"),
        (r"passwd\s*=\s*['\"]([^'\"]{4,})['\"]", "Password", "high"),
        
        # Переменные с секретами
        (r"(secret|key|token|password|credential)\s*=\s*['\"]([^'\"]{4,})['\"]", "Secret Variable", "medium"),
    ]
    
    # Исключения (файлы, которые не нужно проверять)
    EXCLUDE_FILES = {
        "test_", "tests", "mock", ".git", "venv", ".venv", "env", "example", "sample",
    }
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
    
    def run(self, target_path: str, **kwargs) -> Tuple[CheckResult, List[VulnerabilityIssue]]:
        """
        Запуск проверки на утечку секретов.
        
        Args:
            target_path: Путь к директории или файлу для проверки
            **kwargs: Дополнительные параметры
            
        Returns:
            Tuple[CheckResult, List[VulnerabilityIssue]]: Результат проверки и список найденных уязвимостей
        """
        self.issues = []
        
        try:
            # Проверка файлов на наличие секретов
            path = Path(target_path)
            for file_path in self._find_files_to_check(path):
                self._check_file_for_secrets(file_path)
            
            # Формирование результата
            status = CheckStatus.PASSED if not self.issues else CheckStatus.FAILED
            result = self.create_result(
                status=status,
                message=f"Найдено {len(self.issues)} потенциальных утечек секретов" if self.issues else "Утечек секретов не обнаружено",
            )
            
            return result, self.issues
            
        except Exception as e:
            # В случае ошибки возвращаем статус ERROR
            result = self.create_result(
                status=CheckStatus.ERROR,
                message=f"Ошибка при проверке на утечку секретов: {str(e)}",
            )
            return result, self.issues
    
    def _find_files_to_check(self, path: Path) -> Set[Path]:
        """
        Поиск файлов для проверки на секреты.
        
        Args:
            path: Путь к директории или файлу
            
        Returns:
            Set[Path]: Множество путей к файлам
        """
        result = set()
        
        # Файлы, в которых могут быть хардкоженные секреты
        extensions = {".py", ".json", ".yaml", ".yml", ".ini", ".cfg", ".conf", ".env", ".properties", ".xml"}
        
        if path.is_file():
            if path.suffix in extensions and not self.should_exclude_path(path):
                result.add(path)
            return result
        
        # Обход директории
        for root, dirs, files in os.walk(path):
            # Фильтруем директории, которые нужно исключить
            dirs[:] = [d for d in dirs if not self.should_exclude_path(os.path.join(root, d))]
            
            for file in files:
                file_path = Path(root) / file
                if file_path.suffix in extensions and not self.should_exclude_path(file_path):
                    result.add(file_path)
        
        return result
    
    def _check_file_for_secrets(self, file_path: Path) -> None:
        """
        Проверка файла на наличие секретов.
        
        Args:
            file_path: Путь к файлу
        """
        try:
            # Игнорирование .env.example и подобных файлов
            if "example" in file_path.name or "sample" in file_path.name:
                return
                
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            
            lines = content.splitlines()
            
            # Проверка каждой строки на наличие секретов
            for i, line in enumerate(lines):
                for pattern, secret_type, severity in self.SECRET_PATTERNS:
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    for match in matches:
                        # Проверяем, не является ли это шаблоном переменной (например, ${SECRET_KEY})
                        if "${" in match.group(0) or "{{" in match.group(0):
                            continue
                        
                        # Проверяем, не является ли это явно тестовым/фиктивным значением
                        if any(x in match.group(0).lower() for x in ["example", "sample", "test", "dummy"]):
                            continue
                        
                        # Добавляем найденный секрет в список уязвимостей
                        self._add_secret_issue(file_path, i + 1, line, secret_type, severity)
                    
        except Exception as e:
            # Пропускаем файлы с ошибками
            print(f"Ошибка при проверке файла {file_path}: {str(e)}")
    
    def _add_secret_issue(self, file_path: Path, line_number: int, code_snippet: str, secret_type: str, severity: str) -> None:
        """
        Добавление найденного секрета в список уязвимостей.
        
        Args:
            file_path: Путь к файлу
            line_number: Номер строки
            code_snippet: Фрагмент кода
            secret_type: Тип секрета
            severity: Уровень серьезности
        """
        # Замена секрета для отображения (не показываем полностью)
        redacted_snippet = code_snippet
        
        # Простое маскирование строк в кавычках для отчета (не показываем секрет полностью)
        redacted_snippet = re.sub(
            r'(["\'])(?:(?=(\\?))\2.)*?\1',
            lambda m: m.group(0)[:4] + "*****" + m.group(0)[-1],
            redacted_snippet
        )
        
        self.add_issue(
            issue_type=f"Secret Leak: {secret_type}",
            severity=severity,
            description=f"Обнаружен потенциальный секрет типа {secret_type}",
            file_path=str(file_path),
            line_number=line_number,
            code_snippet=redacted_snippet.strip(),
            confidence="MEDIUM",
            cwe_id="CWE-798",
            owasp_category="A3:2017-Sensitive Data Exposure",
            remediation="Не храните секреты в коде. Используйте переменные окружения или защищенные хранилища секретов.",
        ) 