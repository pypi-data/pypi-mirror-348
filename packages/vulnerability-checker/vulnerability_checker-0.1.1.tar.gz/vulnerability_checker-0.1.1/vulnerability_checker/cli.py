#!/usr/bin/env python3
"""
CLI module for Vulnerability Checker.
"""

import argparse
import json
import sys
from pathlib import Path
from typing import List, Optional, Dict, Any

from rich.console import Console
from rich.table import Table

from vulnerability_checker.checker import VulnerabilityChecker
from vulnerability_checker.models import VulnerabilityReport, CheckStatus


def parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments.
    """
    parser = argparse.ArgumentParser(
        description="Check Python code for vulnerabilities."
    )
    parser.add_argument(
        "path",
        type=str,
        help="Path to directory or file for checking",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=str,
        help="Path to save the report in JSON format",
    )
    parser.add_argument(
        "--checks",
        type=str,
        help="Comma-separated list of checks (e.g.: sql-injection,xss,dependency-check)",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Detailed output",
    )
    parser.add_argument(
        "--exit-zero",
        action="store_true",
        help="Always return 0 exit code, even when vulnerabilities are found",
    )
    parser.add_argument(
        "--config",
        type=str,
        help="Path to configuration file",
    )
    
    return parser.parse_args()


def display_report(report: VulnerabilityReport, verbose: bool = False) -> None:
    """
    Отображение отчета в терминале.
    
    Args:
        report: Отчет о проверке
        verbose: Подробный вывод
    """
    console = Console()
    
    console.print(f"\n[bold]Vulnerability Checker Report[/bold]")
    console.print(f"Сканирование: {report.target_path}")
    console.print(f"Дата: {report.scan_date}")
    console.print(f"Найдено уязвимостей: [bold red]{report.total_issues}[/bold red]")
    
    if report.total_issues == 0:
        console.print("\n[bold green]Уязвимостей не обнаружено![/bold green]")
        return
    
    # Таблица с результатами
    table = Table(title="Обнаруженные уязвимости")
    table.add_column("Тип", style="cyan")
    table.add_column("Файл", style="blue")
    table.add_column("Строка", style="yellow")
    table.add_column("Уровень", style="red")
    table.add_column("Описание", style="white")
    
    for issue in report.issues:
        table.add_row(
            issue.issue_type,
            issue.file_path,
            str(issue.line_number),
            issue.severity.upper(),
            issue.description
        )
        
    console.print(table)
    
    # Таблица со статистикой
    stats_table = Table(title="Статистика по проверкам")
    stats_table.add_column("Проверка", style="cyan")
    stats_table.add_column("Статус", style="green")
    stats_table.add_column("Найдено проблем", style="red")
    
    for check, status in report.checks_status.items():
        status_color = "green" if status.status == CheckStatus.PASSED else "red"
        stats_table.add_row(
            check,
            f"[{status_color}]{status.status.value}[/{status_color}]",
            str(status.issues_count)
        )
    
    console.print(stats_table)


def save_json_report(report: VulnerabilityReport, output_path: str) -> None:
    """
    Сохранение отчета в JSON формате.
    
    Args:
        report: Отчет о проверке
        output_path: Путь для сохранения отчета
    """
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(report.to_dict(), f, ensure_ascii=False, indent=2)


def main() -> int:
    """
    Основная функция CLI.
    
    Returns:
        Код возврата (0 - успех, 1 - найдены уязвимости, 2 - пусть не существует)
    """
    args = parse_arguments()
    target_path = Path(args.path)
    
    if not target_path.exists():
        print(f"Ошибка: путь {args.path} не существует")
        return 2
    
    # Список проверок
    checks_list = None
    if args.checks:
        checks_list = args.checks.split(",")
    
    # Создание экземпляра проверки
    checker = VulnerabilityChecker(
        config_path=args.config,
    )
    
    # Запуск проверки
    report = checker.run(
        target_path=str(target_path),
        checks=checks_list,
        verbose=args.verbose,
    )
    
    # Отображение отчета
    display_report(report, args.verbose)
    
    # Сохранение отчета, если указан путь
    if args.output:
        save_json_report(report, args.output)
        print(f"\nОтчет сохранен в {args.output}")
    
    # Возвращаем код завершения
    if args.exit_zero:
        return 0
    
    return 1 if report.total_issues > 0 else 0


if __name__ == "__main__":
    sys.exit(main()) 