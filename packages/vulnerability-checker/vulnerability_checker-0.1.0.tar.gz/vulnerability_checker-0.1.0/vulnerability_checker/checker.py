"""
Основной класс проверки уязвимостей.
"""

import json
import logging
import time
from pathlib import Path
from typing import Dict, List, Optional, Any, Type

from vulnerability_checker.checks import AVAILABLE_CHECKS, BaseCheck
from vulnerability_checker.models import VulnerabilityReport, CheckResult, CheckStatus


class VulnerabilityChecker:
    """
    Основной класс для проверки уязвимостей в Python-коде.
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Инициализация чекера уязвимостей.
        
        Args:
            config_path: Путь к файлу конфигурации
        """
        self.logger = logging.getLogger(__name__)
        self.config = self._load_config(config_path) if config_path else {}
    
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """
        Загрузка конфигурации из файла.
        
        Args:
            config_path: Путь к файлу конфигурации
            
        Returns:
            Dict[str, Any]: Словарь с конфигурацией
        """
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Ошибка при загрузке конфигурации: {str(e)}")
            return {}
    
    def run(
        self,
        target_path: str,
        checks: Optional[List[str]] = None,
        verbose: bool = False,
    ) -> VulnerabilityReport:
        """
        Запуск проверки уязвимостей.
        
        Args:
            target_path: Путь к директории или файлу для проверки
            checks: Список проверок для запуска (если None, то запускаются все доступные)
            verbose: Подробный вывод
            
        Returns:
            VulnerabilityReport: Отчет о проверке
        """
        start_time = time.time()
        
        # Создание отчета
        report = VulnerabilityReport(target_path=target_path)
        
        # Определение списка проверок для запуска
        checks_to_run = self._get_checks_to_run(checks)
        
        if verbose:
            print(f"Запуск {len(checks_to_run)} проверок для {target_path}")
        
        # Запуск проверок
        for check_name, check_class in checks_to_run.items():
            try:
                # Инициализация проверки с конфигурацией
                check_config = self.config.get(check_name, {})
                check_instance = check_class(config=check_config)
                
                if verbose:
                    print(f"Запуск проверки: {check_name}")
                
                # Запуск проверки
                check_result, issues = check_instance.run(target_path, verbose=verbose)
                
                # Добавление результата проверки в отчет
                report.add_check_result(check_name, check_result)
                
                # Добавление найденных уязвимостей в отчет
                for issue in issues:
                    report.add_issue(issue)
                
                if verbose:
                    print(f"Проверка {check_name} завершена: {check_result.status.value}")
                    print(f"Найдено уязвимостей: {check_result.issues_count}")
                
            except Exception as e:
                # В случае ошибки, добавляем информацию об ошибке в отчет
                self.logger.error(f"Ошибка при выполнении проверки {check_name}: {str(e)}")
                error_result = CheckResult(
                    status=CheckStatus.ERROR,
                    issues_count=0,
                    message=f"Ошибка при выполнении проверки: {str(e)}",
                )
                report.add_check_result(check_name, error_result)
        
        # Обновление статистики сканирования
        report.scan_duration_seconds = time.time() - start_time
        
        return report
    
    def _get_checks_to_run(
        self, selected_checks: Optional[List[str]] = None
    ) -> Dict[str, Type[BaseCheck]]:
        """
        Получение списка проверок для запуска.
        
        Args:
            selected_checks: Список проверок для запуска (если None, то все доступные)
            
        Returns:
            Dict[str, Type[BaseCheck]]: Словарь с проверками для запуска
        """
        if selected_checks is None:
            # Если список не указан, возвращаем все доступные проверки
            return AVAILABLE_CHECKS
        
        # Фильтрация проверок по списку
        result = {}
        for check_name in selected_checks:
            if check_name in AVAILABLE_CHECKS:
                result[check_name] = AVAILABLE_CHECKS[check_name]
            else:
                self.logger.warning(f"Проверка {check_name} не найдена")
        
        return result 