"""
Проверка на уязвимости SQL-инъекций.
"""

import os
import re
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Set

import bandit
from bandit.core import manager

from vulnerability_checker.checks.base import BaseCheck
from vulnerability_checker.models import CheckResult, CheckStatus, VulnerabilityIssue


class SQLInjectionCheck(BaseCheck):
    """
    Проверка на уязвимости SQL-инъекций.
    """
    
    name = "sql-injection"
    description = "Проверка на уязвимости SQL-инъекций"
    
    # Паттерны для поиска потенциальных SQL-инъекций
    SQL_INJECTION_PATTERNS = [
        # Прямое использование строковой конкатенации в запросах
        r"execute\s*\(\s*['\"]SELECT .* WHERE .*\s*\+\s*",
        r"execute\s*\(\s*['\"]UPDATE .* SET .*\s*\+\s*",
        r"execute\s*\(\s*['\"]INSERT INTO .* VALUES .*\s*\+\s*",
        r"execute\s*\(\s*['\"]DELETE FROM .* WHERE .*\s*\+\s*",
        
        # Форматирование строк для запросов
        r"execute\s*\(\s*f['\"]SELECT .* WHERE .*\{.*\}",
        r"execute\s*\(\s*f['\"]UPDATE .* SET .*\{.*\}",
        r"execute\s*\(\s*f['\"]INSERT INTO .* VALUES .*\{.*\}",
        r"execute\s*\(\s*f['\"]DELETE FROM .* WHERE .*\{.*\}",
        
        # Использование % для форматирования
        r"execute\s*\(\s*['\"]SELECT .* WHERE .*['\"].*%.*\)",
        r"execute\s*\(\s*['\"]UPDATE .* SET .*['\"].*%.*\)",
        r"execute\s*\(\s*['\"]INSERT INTO .* VALUES .*['\"].*%.*\)",
        r"execute\s*\(\s*['\"]DELETE FROM .* WHERE .*['\"].*%.*\)",
        
        # Использование .format()
        r"execute\s*\(\s*['\"]SELECT .* WHERE .*['\"]\.format\(",
        r"execute\s*\(\s*['\"]UPDATE .* SET .*['\"]\.format\(",
        r"execute\s*\(\s*['\"]INSERT INTO .* VALUES .*['\"]\.format\(",
        r"execute\s*\(\s*['\"]DELETE FROM .* WHERE .*['\"]\.format\(",
    ]
    
    # Безопасные паттерны, которые можно использовать
    SAFE_PATTERNS = [
        r"execute\s*\(\s*['\"]SELECT .* WHERE .*\s*\%s",  # Использование параметризованных запросов
        r"execute_values\s*\(",  # psycopg2.extras.execute_values
        r"executemany\s*\(",  # executemany для множественных запросов
    ]
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.severity_map = {
            "HIGH": "high",
            "MEDIUM": "medium",
            "LOW": "low",
        }
    
    def run(self, target_path: str, **kwargs) -> Tuple[CheckResult, List[VulnerabilityIssue]]:
        """
        Запуск проверки на SQL-инъекции.
        
        Args:
            target_path: Путь к директории или файлу для проверки
            **kwargs: Дополнительные параметры
            
        Returns:
            Tuple[CheckResult, List[VulnerabilityIssue]]: Результат проверки и список найденных уязвимостей
        """
        self.issues = []
        
        try:
            # Проверка с использованием bandit для обнаружения SQL инъекций
            self._run_bandit_check(target_path)
            
            # Дополнительная проверка с использованием паттернов
            self._check_sql_patterns(target_path)
            
            # Формирование результата
            status = CheckStatus.PASSED if not self.issues else CheckStatus.FAILED
            result = self.create_result(
                status=status,
                message=f"Найдено {len(self.issues)} потенциальных SQL-инъекций" if self.issues else "SQL-инъекций не обнаружено",
            )
            
            return result, self.issues
            
        except Exception as e:
            # В случае ошибки возвращаем статус ERROR
            result = self.create_result(
                status=CheckStatus.ERROR,
                message=f"Ошибка при проверке на SQL-инъекции: {str(e)}",
            )
            return result, self.issues
    
    def _run_bandit_check(self, target_path: str) -> None:
        """
        Запуск проверки с использованием bandit.
        
        Args:
            target_path: Путь к директории или файлу для проверки
        """
        # Настройка bandit
        b_mgr = manager.BanditManager(
            config_file=None,
            agg_type="file",
            debug=False,
            verbose=False,
            quiet=True,
            profile=None,
        )
        
        # Запуск сканирования
        b_mgr.discover_files([target_path])
        b_mgr.run_tests()
        
        # Обработка результатов
        for fname, issues in b_mgr.results_by_filename.items():
            for issue in issues:
                # Фильтрация только SQL инъекций
                if "sql" in issue.test_id.lower() or "sql" in issue.test_name.lower():
                    self.add_issue(
                        issue_type="SQL Injection",
                        severity=self.severity_map.get(issue.severity, "medium"),
                        description=issue.test_text,
                        file_path=fname,
                        line_number=issue.line_number,
                        code_snippet=issue.raw_context,
                        confidence=issue.confidence,
                        cwe_id="CWE-89",
                        owasp_category="A1:2017-Injection",
                        remediation="Используйте параметризованные запросы или ORM вместо прямой конкатенации строк в SQL запросах.",
                    )
    
    def _check_sql_patterns(self, target_path: str) -> None:
        """
        Проверка файлов на наличие паттернов SQL-инъекций.
        
        Args:
            target_path: Путь к директории или файлу для проверки
        """
        path = Path(target_path)
        
        # Обход файлов
        for file_path in self._find_python_files(path):
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
                    
                # Компиляция паттернов
                sql_patterns = [re.compile(pattern) for pattern in self.SQL_INJECTION_PATTERNS]
                safe_patterns = [re.compile(pattern) for pattern in self.SAFE_PATTERNS]
                
                # Проверка по строкам для получения номера строки
                lines = content.splitlines()
                for i, line in enumerate(lines):
                    # Поиск потенциально опасных паттернов
                    for pattern in sql_patterns:
                        if pattern.search(line):
                            # Проверка, нет ли безопасных паттернов
                            is_safe = any(safe_pattern.search(line) for safe_pattern in safe_patterns)
                            if not is_safe:
                                self.add_issue(
                                    issue_type="SQL Injection",
                                    severity="high",
                                    description=f"Потенциальная SQL-инъекция: использование непараметризованного запроса",
                                    file_path=str(file_path),
                                    line_number=i + 1,
                                    code_snippet=line.strip(),
                                    confidence="MEDIUM",
                                    cwe_id="CWE-89",
                                    owasp_category="A1:2017-Injection",
                                    remediation="Используйте параметризованные запросы вместо конкатенации или форматирования строк.",
                                )
            except Exception as e:
                # Пропускаем файлы с ошибками
                continue
    
    def _find_python_files(self, path: Path) -> Set[Path]:
        """
        Поиск всех Python файлов в директории.
        
        Args:
            path: Путь к директории или файлу
            
        Returns:
            Set[Path]: Множество путей к Python файлам
        """
        results = set()
        
        if path.is_file() and path.suffix == ".py":
            if not self.should_exclude_path(path):
                results.add(path)
            return results
        
        for root, dirs, files in os.walk(path):
            # Фильтруем директории, которые нужно исключить
            dirs[:] = [d for d in dirs if not self.should_exclude_path(os.path.join(root, d))]
            
            for file in files:
                if file.endswith(".py"):
                    file_path = Path(root) / file
                    if not self.should_exclude_path(file_path):
                        results.add(file_path)
        
        return results 