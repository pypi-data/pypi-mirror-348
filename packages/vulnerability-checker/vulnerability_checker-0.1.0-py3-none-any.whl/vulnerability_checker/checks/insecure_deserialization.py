"""
Проверка на уязвимости небезопасной десериализации.
"""

import os
import re
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Set

from vulnerability_checker.checks.base import BaseCheck
from vulnerability_checker.models import CheckResult, CheckStatus, VulnerabilityIssue


class InsecureDeserializationCheck(BaseCheck):
    """
    Проверка на уязвимости небезопасной десериализации.
    """
    
    name = "insecure-deserialization"
    description = "Проверка на уязвимости небезопасной десериализации"
    
    # Паттерны небезопасной десериализации
    INSECURE_DESERIALIZATION_PATTERNS = [
        # pickle
        (r"pickle\.loads?\s*\(.*?\)", "Python pickle", "critical", "CWE-502", 
         "Функция pickle.loads может выполнить произвольный код при десериализации объектов. "
         "Используйте safer_pickle или JSON для обработки ненадежных данных."),
        
        # yaml.load без safe=True
        (r"yaml\.load\s*\((?!.*safe=True).*?\)", "YAML unsafe load", "high", "CWE-502",
         "Метод yaml.load без параметра safe=True может выполнить произвольный код. "
         "Используйте yaml.safe_load вместо этого."),
        
        # eval на входных данных
        (r"eval\s*\(.*(?:request|input|file|data|json|get|post).*\)", "Eval on input", "critical", "CWE-95",
         "Функция eval может выполнить произвольный код. Никогда не используйте eval для входных данных."),
        
        # Marshal
        (r"marshal\.loads?\s*\(.*?\)", "Python marshal", "high", "CWE-502",
         "Модуль marshal небезопасен для ненадежных данных, так как может выполнить произвольный код."),
        
        # shelve (использует pickle)
        (r"shelve\.open\s*\(.*?\)", "Python shelve", "medium", "CWE-502",
         "Модуль shelve использует pickle и небезопасен для ненадежных данных."),
        
        # jsonpickle
        (r"jsonpickle\.(?:decode|loads)\s*\(.*?\)", "jsonpickle decode", "medium", "CWE-502",
         "jsonpickle может выполнить произвольный код при десериализации объектов."),
        
        # dill
        (r"dill\.loads?\s*\(.*?\)", "Python dill", "high", "CWE-502",
         "Модуль dill небезопасен и может выполнить произвольный код при десериализации."),
        
        # pyyaml с конструкторами
        (r"yaml\..*?[Ll]oader.*?\)", "YAML with loader", "high", "CWE-502",
         "Loader в PyYAML может выполнить произвольный код. Используйте yaml.SafeLoader."),
        
        # subprocess с shell=True
        (r"subprocess\.(?:call|run|Popen)\s*\(.*?shell\s*=\s*True.*?\)", "subprocess with shell=True", "high", "CWE-78",
         "Использование subprocess с shell=True и входными данными может привести к инъекции команд."),
    ]
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
    
    def run(self, target_path: str, **kwargs) -> Tuple[CheckResult, List[VulnerabilityIssue]]:
        """
        Запуск проверки на небезопасную десериализацию.
        
        Args:
            target_path: Путь к директории или файлу для проверки
            **kwargs: Дополнительные параметры
            
        Returns:
            Tuple[CheckResult, List[VulnerabilityIssue]]: Результат проверки и список найденных уязвимостей
        """
        self.issues = []
        
        try:
            # Проверка файлов на небезопасную десериализацию
            path = Path(target_path)
            for file_path in self._find_python_files(path):
                self._check_file_for_insecure_deserialization(file_path)
            
            # Формирование результата
            status = CheckStatus.PASSED if not self.issues else CheckStatus.FAILED
            result = self.create_result(
                status=status,
                message=f"Найдено {len(self.issues)} потенциальных уязвимостей небезопасной десериализации" if self.issues else "Уязвимостей небезопасной десериализации не обнаружено",
            )
            
            return result, self.issues
            
        except Exception as e:
            # В случае ошибки возвращаем статус ERROR
            result = self.create_result(
                status=CheckStatus.ERROR,
                message=f"Ошибка при проверке на небезопасную десериализацию: {str(e)}",
            )
            return result, self.issues
    
    def _find_python_files(self, path: Path) -> Set[Path]:
        """
        Поиск Python файлов для проверки.
        
        Args:
            path: Путь к директории или файлу
            
        Returns:
            Set[Path]: Множество путей к файлам
        """
        result = set()
        
        if path.is_file() and path.suffix == ".py":
            # Проверка на исключения
            if not self.should_exclude_path(path):
                result.add(path)
            return result
        
        # Обход директории
        for root, dirs, files in os.walk(path):
            # Фильтруем директории, которые нужно исключить
            dirs[:] = [d for d in dirs if not self.should_exclude_path(os.path.join(root, d))]
            
            for file in files:
                if file.endswith(".py"):
                    file_path = Path(root) / file
                    if not self.should_exclude_path(file_path):
                        result.add(file_path)
        
        return result
    
    def _check_file_for_insecure_deserialization(self, file_path: Path) -> None:
        """
        Проверка файла на уязвимости небезопасной десериализации.
        
        Args:
            file_path: Путь к файлу
        """
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            
            lines = content.splitlines()
            
            # Компиляция регулярных выражений
            for i, line in enumerate(lines):
                for pattern_tuple in self.INSECURE_DESERIALIZATION_PATTERNS:
                    pattern, issue_type, severity, cwe_id, remediation = pattern_tuple
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        # Проверяем контекст для уменьшения ложных срабатываний
                        if self._is_likely_vulnerable_context(lines, i, match.group(0)):
                            # Добавляем уязвимость в список
                            self.add_issue(
                                issue_type=f"Insecure Deserialization: {issue_type}",
                                severity=severity,
                                description=f"Потенциальная уязвимость небезопасной десериализации: {issue_type}",
                                file_path=str(file_path),
                                line_number=i + 1,
                                code_snippet=line.strip(),
                                confidence="MEDIUM",
                                cwe_id=cwe_id,
                                owasp_category="A8:2017-Insecure Deserialization",
                                remediation=remediation,
                            )
        
        except Exception as e:
            # Пропускаем файлы с ошибками
            print(f"Ошибка при проверке файла {file_path}: {str(e)}")
    
    def _is_likely_vulnerable_context(self, lines: List[str], line_index: int, match_string: str) -> bool:
        """
        Проверка контекста для определения вероятности реальной уязвимости.
        
        Args:
            lines: Список строк файла
            line_index: Индекс текущей строки
            match_string: Найденное совпадение
            
        Returns:
            bool: True, если контекст указывает на вероятную уязвимость
        """
        # Получение нескольких строк до и после для анализа контекста
        start = max(0, line_index - 3)
        end = min(len(lines), line_index + 4)
        context = "\n".join(lines[start:end])
        
        # Признаки безопасного контекста
        safe_indicators = [
            "# nosec",
            "# noqa",
            "def test_",
            "class Test",
            "assert",
            "unittest",
            "pytest",
        ]
        
        # Проверка на признаки безопасного контекста
        for indicator in safe_indicators:
            if indicator in context:
                return False
        
        # Признаки уязвимого контекста (данные из ненадежных источников)
        vulnerable_indicators = [
            "request", "user", "input", "data", "file", "http", "response", "get", "post", "json"
        ]
        
        # Если это pickle, yaml без safe=True, eval - они всегда потенциально опасны
        if any(x in match_string.lower() for x in ["pickle", "yaml.load", "eval", "marshal"]):
            # Проверка наличия ненадежных источников данных рядом
            return any(indicator in context.lower() for indicator in vulnerable_indicators)
        
        return True 