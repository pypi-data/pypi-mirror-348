# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ProjectApplicationsArgs',
    'ProjectApplicationsArgsDict',
    'ProjectApplicationsOidcApplicationArgs',
    'ProjectApplicationsOidcApplicationArgsDict',
    'ProjectApplicationsSamlApplicationArgs',
    'ProjectApplicationsSamlApplicationArgsDict',
    'ProjectApplicationsSamlApplicationAttributeMappingArgs',
    'ProjectApplicationsSamlApplicationAttributeMappingArgsDict',
    'ProjectApplicationsSamlApplicationDynamicConfigurationArgs',
    'ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict',
    'ProjectApplicationsSamlApplicationManualConfigurationArgs',
    'ProjectApplicationsSamlApplicationManualConfigurationArgsDict',
    'ProjectAttributesArgs',
    'ProjectAttributesArgsDict',
    'ProjectAttributesTenantArgs',
    'ProjectAttributesTenantArgsDict',
    'ProjectAttributesTenantAuthorizationArgs',
    'ProjectAttributesTenantAuthorizationArgsDict',
    'ProjectAttributesUserArgs',
    'ProjectAttributesUserArgsDict',
    'ProjectAttributesUserWidgetAuthorizationArgs',
    'ProjectAttributesUserWidgetAuthorizationArgsDict',
    'ProjectAuthenticationArgs',
    'ProjectAuthenticationArgsDict',
    'ProjectAuthenticationEmbeddedLinkArgs',
    'ProjectAuthenticationEmbeddedLinkArgsDict',
    'ProjectAuthenticationEnchantedLinkArgs',
    'ProjectAuthenticationEnchantedLinkArgsDict',
    'ProjectAuthenticationEnchantedLinkEmailServiceArgs',
    'ProjectAuthenticationEnchantedLinkEmailServiceArgsDict',
    'ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs',
    'ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict',
    'ProjectAuthenticationMagicLinkArgs',
    'ProjectAuthenticationMagicLinkArgsDict',
    'ProjectAuthenticationMagicLinkEmailServiceArgs',
    'ProjectAuthenticationMagicLinkEmailServiceArgsDict',
    'ProjectAuthenticationMagicLinkEmailServiceTemplateArgs',
    'ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict',
    'ProjectAuthenticationMagicLinkTextServiceArgs',
    'ProjectAuthenticationMagicLinkTextServiceArgsDict',
    'ProjectAuthenticationMagicLinkTextServiceTemplateArgs',
    'ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict',
    'ProjectAuthenticationOauthArgs',
    'ProjectAuthenticationOauthArgsDict',
    'ProjectAuthenticationOauthCustomArgs',
    'ProjectAuthenticationOauthCustomArgsDict',
    'ProjectAuthenticationOauthCustomProviderTokenManagementArgs',
    'ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemArgs',
    'ProjectAuthenticationOauthSystemArgsDict',
    'ProjectAuthenticationOauthSystemAppleArgs',
    'ProjectAuthenticationOauthSystemAppleArgsDict',
    'ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemDiscordArgs',
    'ProjectAuthenticationOauthSystemDiscordArgsDict',
    'ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemFacebookArgs',
    'ProjectAuthenticationOauthSystemFacebookArgsDict',
    'ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemGithubArgs',
    'ProjectAuthenticationOauthSystemGithubArgsDict',
    'ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemGitlabArgs',
    'ProjectAuthenticationOauthSystemGitlabArgsDict',
    'ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemGoogleArgs',
    'ProjectAuthenticationOauthSystemGoogleArgsDict',
    'ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemLinkedinArgs',
    'ProjectAuthenticationOauthSystemLinkedinArgsDict',
    'ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemMicrosoftArgs',
    'ProjectAuthenticationOauthSystemMicrosoftArgsDict',
    'ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemSlackArgs',
    'ProjectAuthenticationOauthSystemSlackArgsDict',
    'ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict',
    'ProjectAuthenticationOtpArgs',
    'ProjectAuthenticationOtpArgsDict',
    'ProjectAuthenticationOtpEmailServiceArgs',
    'ProjectAuthenticationOtpEmailServiceArgsDict',
    'ProjectAuthenticationOtpEmailServiceTemplateArgs',
    'ProjectAuthenticationOtpEmailServiceTemplateArgsDict',
    'ProjectAuthenticationOtpTextServiceArgs',
    'ProjectAuthenticationOtpTextServiceArgsDict',
    'ProjectAuthenticationOtpTextServiceTemplateArgs',
    'ProjectAuthenticationOtpTextServiceTemplateArgsDict',
    'ProjectAuthenticationOtpVoiceServiceArgs',
    'ProjectAuthenticationOtpVoiceServiceArgsDict',
    'ProjectAuthenticationOtpVoiceServiceTemplateArgs',
    'ProjectAuthenticationOtpVoiceServiceTemplateArgsDict',
    'ProjectAuthenticationPasskeysArgs',
    'ProjectAuthenticationPasskeysArgsDict',
    'ProjectAuthenticationPasswordArgs',
    'ProjectAuthenticationPasswordArgsDict',
    'ProjectAuthenticationPasswordEmailServiceArgs',
    'ProjectAuthenticationPasswordEmailServiceArgsDict',
    'ProjectAuthenticationPasswordEmailServiceTemplateArgs',
    'ProjectAuthenticationPasswordEmailServiceTemplateArgsDict',
    'ProjectAuthenticationSsoArgs',
    'ProjectAuthenticationSsoArgsDict',
    'ProjectAuthenticationTotpArgs',
    'ProjectAuthenticationTotpArgsDict',
    'ProjectAuthorizationArgs',
    'ProjectAuthorizationArgsDict',
    'ProjectAuthorizationPermissionArgs',
    'ProjectAuthorizationPermissionArgsDict',
    'ProjectAuthorizationRoleArgs',
    'ProjectAuthorizationRoleArgsDict',
    'ProjectConnectorsArgs',
    'ProjectConnectorsArgsDict',
    'ProjectConnectorsAbuseipdbArgs',
    'ProjectConnectorsAbuseipdbArgsDict',
    'ProjectConnectorsAmplitudeArgs',
    'ProjectConnectorsAmplitudeArgsDict',
    'ProjectConnectorsAuditWebhookArgs',
    'ProjectConnectorsAuditWebhookArgsDict',
    'ProjectConnectorsAuditWebhookAuditFilterArgs',
    'ProjectConnectorsAuditWebhookAuditFilterArgsDict',
    'ProjectConnectorsAuditWebhookAuthenticationArgs',
    'ProjectConnectorsAuditWebhookAuthenticationArgsDict',
    'ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs',
    'ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict',
    'ProjectConnectorsAuditWebhookAuthenticationBasicArgs',
    'ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict',
    'ProjectConnectorsAwsS3Args',
    'ProjectConnectorsAwsS3ArgsDict',
    'ProjectConnectorsAwsS3AuditFilterArgs',
    'ProjectConnectorsAwsS3AuditFilterArgsDict',
    'ProjectConnectorsAwsTranslateArgs',
    'ProjectConnectorsAwsTranslateArgsDict',
    'ProjectConnectorsClearArgs',
    'ProjectConnectorsClearArgsDict',
    'ProjectConnectorsDatadogArgs',
    'ProjectConnectorsDatadogArgsDict',
    'ProjectConnectorsDatadogAuditFilterArgs',
    'ProjectConnectorsDatadogAuditFilterArgsDict',
    'ProjectConnectorsDevrevGrowArgs',
    'ProjectConnectorsDevrevGrowArgsDict',
    'ProjectConnectorsDoceboArgs',
    'ProjectConnectorsDoceboArgsDict',
    'ProjectConnectorsFingerprintArgs',
    'ProjectConnectorsFingerprintArgsDict',
    'ProjectConnectorsFingerprintDescopeArgs',
    'ProjectConnectorsFingerprintDescopeArgsDict',
    'ProjectConnectorsForterArgs',
    'ProjectConnectorsForterArgsDict',
    'ProjectConnectorsGenericSmsGatewayArgs',
    'ProjectConnectorsGenericSmsGatewayArgsDict',
    'ProjectConnectorsGenericSmsGatewayAuthenticationArgs',
    'ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict',
    'ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs',
    'ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict',
    'ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs',
    'ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict',
    'ProjectConnectorsGoogleCloudTranslationArgs',
    'ProjectConnectorsGoogleCloudTranslationArgsDict',
    'ProjectConnectorsHibpArgs',
    'ProjectConnectorsHibpArgsDict',
    'ProjectConnectorsHttpArgs',
    'ProjectConnectorsHttpArgsDict',
    'ProjectConnectorsHttpAuthenticationArgs',
    'ProjectConnectorsHttpAuthenticationArgsDict',
    'ProjectConnectorsHttpAuthenticationApiKeyArgs',
    'ProjectConnectorsHttpAuthenticationApiKeyArgsDict',
    'ProjectConnectorsHttpAuthenticationBasicArgs',
    'ProjectConnectorsHttpAuthenticationBasicArgsDict',
    'ProjectConnectorsHubspotArgs',
    'ProjectConnectorsHubspotArgsDict',
    'ProjectConnectorsIncodeArgs',
    'ProjectConnectorsIncodeArgsDict',
    'ProjectConnectorsIntercomArgs',
    'ProjectConnectorsIntercomArgsDict',
    'ProjectConnectorsLokaliseArgs',
    'ProjectConnectorsLokaliseArgsDict',
    'ProjectConnectorsMparticleArgs',
    'ProjectConnectorsMparticleArgsDict',
    'ProjectConnectorsNewrelicArgs',
    'ProjectConnectorsNewrelicArgsDict',
    'ProjectConnectorsNewrelicAuditFilterArgs',
    'ProjectConnectorsNewrelicAuditFilterArgsDict',
    'ProjectConnectorsRecaptchaArgs',
    'ProjectConnectorsRecaptchaArgsDict',
    'ProjectConnectorsRecaptchaEnterpriseArgs',
    'ProjectConnectorsRecaptchaEnterpriseArgsDict',
    'ProjectConnectorsRekognitionArgs',
    'ProjectConnectorsRekognitionArgsDict',
    'ProjectConnectorsSalesforceArgs',
    'ProjectConnectorsSalesforceArgsDict',
    'ProjectConnectorsSalesforceMarketingCloudArgs',
    'ProjectConnectorsSalesforceMarketingCloudArgsDict',
    'ProjectConnectorsSeArgs',
    'ProjectConnectorsSeArgsDict',
    'ProjectConnectorsSeSenderArgs',
    'ProjectConnectorsSeSenderArgsDict',
    'ProjectConnectorsSegmentArgs',
    'ProjectConnectorsSegmentArgsDict',
    'ProjectConnectorsSendgridArgs',
    'ProjectConnectorsSendgridArgsDict',
    'ProjectConnectorsSendgridAuthenticationArgs',
    'ProjectConnectorsSendgridAuthenticationArgsDict',
    'ProjectConnectorsSendgridSenderArgs',
    'ProjectConnectorsSendgridSenderArgsDict',
    'ProjectConnectorsSlackArgs',
    'ProjectConnectorsSlackArgsDict',
    'ProjectConnectorsSmartlingArgs',
    'ProjectConnectorsSmartlingArgsDict',
    'ProjectConnectorsSmtpArgs',
    'ProjectConnectorsSmtpArgsDict',
    'ProjectConnectorsSmtpAuthenticationArgs',
    'ProjectConnectorsSmtpAuthenticationArgsDict',
    'ProjectConnectorsSmtpSenderArgs',
    'ProjectConnectorsSmtpSenderArgsDict',
    'ProjectConnectorsSmtpServerArgs',
    'ProjectConnectorsSmtpServerArgsDict',
    'ProjectConnectorsSnArgs',
    'ProjectConnectorsSnArgsDict',
    'ProjectConnectorsSumologicArgs',
    'ProjectConnectorsSumologicArgsDict',
    'ProjectConnectorsSumologicAuditFilterArgs',
    'ProjectConnectorsSumologicAuditFilterArgsDict',
    'ProjectConnectorsTelesignArgs',
    'ProjectConnectorsTelesignArgsDict',
    'ProjectConnectorsTraceableArgs',
    'ProjectConnectorsTraceableArgsDict',
    'ProjectConnectorsTwilioCoreArgs',
    'ProjectConnectorsTwilioCoreArgsDict',
    'ProjectConnectorsTwilioCoreAuthenticationArgs',
    'ProjectConnectorsTwilioCoreAuthenticationArgsDict',
    'ProjectConnectorsTwilioCoreSendersArgs',
    'ProjectConnectorsTwilioCoreSendersArgsDict',
    'ProjectConnectorsTwilioCoreSendersSmsArgs',
    'ProjectConnectorsTwilioCoreSendersSmsArgsDict',
    'ProjectConnectorsTwilioCoreSendersVoiceArgs',
    'ProjectConnectorsTwilioCoreSendersVoiceArgsDict',
    'ProjectConnectorsTwilioVerifyArgs',
    'ProjectConnectorsTwilioVerifyArgsDict',
    'ProjectConnectorsTwilioVerifyAuthenticationArgs',
    'ProjectConnectorsTwilioVerifyAuthenticationArgsDict',
    'ProjectFlowsArgs',
    'ProjectFlowsArgsDict',
    'ProjectInviteSettingsArgs',
    'ProjectInviteSettingsArgsDict',
    'ProjectJwtTemplatesArgs',
    'ProjectJwtTemplatesArgsDict',
    'ProjectJwtTemplatesAccessKeyTemplateArgs',
    'ProjectJwtTemplatesAccessKeyTemplateArgsDict',
    'ProjectJwtTemplatesUserTemplateArgs',
    'ProjectJwtTemplatesUserTemplateArgsDict',
    'ProjectProjectSettingsArgs',
    'ProjectProjectSettingsArgsDict',
    'ProjectStylesArgs',
    'ProjectStylesArgsDict',
]

MYPY = False

if not MYPY:
    class ProjectApplicationsArgsDict(TypedDict):
        oidc_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgsDict']]]]
        """
        Applications using OpenID Connect (OIDC) for authentication.
        """
        saml_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgsDict']]]]
        """
        Applications using SAML for authentication.
        """
elif False:
    ProjectApplicationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsArgs:
    def __init__(__self__, *,
                 oidc_applications: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]]] = None,
                 saml_applications: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]] oidc_applications: Applications using OpenID Connect (OIDC) for authentication.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]] saml_applications: Applications using SAML for authentication.
        """
        if oidc_applications is not None:
            pulumi.set(__self__, "oidc_applications", oidc_applications)
        if saml_applications is not None:
            pulumi.set(__self__, "saml_applications", saml_applications)

    @property
    @pulumi.getter(name="oidcApplications")
    def oidc_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]]]:
        """
        Applications using OpenID Connect (OIDC) for authentication.
        """
        return pulumi.get(self, "oidc_applications")

    @oidc_applications.setter
    def oidc_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]]]):
        pulumi.set(self, "oidc_applications", value)

    @property
    @pulumi.getter(name="samlApplications")
    def saml_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]]]:
        """
        Applications using SAML for authentication.
        """
        return pulumi.get(self, "saml_applications")

    @saml_applications.setter
    def saml_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]]]):
        pulumi.set(self, "saml_applications", value)


if not MYPY:
    class ProjectApplicationsOidcApplicationArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A name for the OIDC application.
        """
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of supported claims. e.g. `sub`, `email`, `exp`.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description for the OIDC application.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the application should be enabled or disabled.
        """
        force_authentication: NotRequired[pulumi.Input[builtins.bool]]
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional identifier for the OIDC application.
        """
        login_page_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        A logo for the OIDC application. Should be a hosted image URL.
        """
elif False:
    ProjectApplicationsOidcApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsOidcApplicationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 force_authentication: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 login_page_url: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A name for the OIDC application.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] claims: A list of supported claims. e.g. `sub`, `email`, `exp`.
        :param pulumi.Input[builtins.str] description: A description for the OIDC application.
        :param pulumi.Input[builtins.bool] disabled: Whether the application should be enabled or disabled.
        :param pulumi.Input[builtins.bool] force_authentication: This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        :param pulumi.Input[builtins.str] id: An optional identifier for the OIDC application.
        :param pulumi.Input[builtins.str] login_page_url: The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param pulumi.Input[builtins.str] logo: A logo for the OIDC application. Should be a hosted image URL.
        """
        pulumi.set(__self__, "name", name)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if force_authentication is not None:
            pulumi.set(__self__, "force_authentication", force_authentication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if login_page_url is not None:
            pulumi.set(__self__, "login_page_url", login_page_url)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A name for the OIDC application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of supported claims. e.g. `sub`, `email`, `exp`.
        """
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claims", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description for the OIDC application.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the application should be enabled or disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="forceAuthentication")
    def force_authentication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        return pulumi.get(self, "force_authentication")

    @force_authentication.setter
    def force_authentication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_authentication", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional identifier for the OIDC application.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="loginPageUrl")
    def login_page_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "login_page_url")

    @login_page_url.setter
    def login_page_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "login_page_url", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A logo for the OIDC application. Should be a hosted image URL.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A name for the SAML application.
        """
        acs_allowed_callback_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        """
        attribute_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgsDict']]]]
        """
        The `AttributeMapping` object. Read the description below.
        """
        default_relay_state: NotRequired[pulumi.Input[builtins.str]]
        """
        The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description for the SAML application.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the application should be enabled or disabled.
        """
        dynamic_configuration: NotRequired[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict']]
        """
        The `DynamicConfiguration` object. Read the description below.
        """
        force_authentication: NotRequired[pulumi.Input[builtins.bool]]
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional identifier for the SAML application.
        """
        login_page_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        A logo for the SAML application. Should be a hosted image URL.
        """
        manual_configuration: NotRequired[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgsDict']]
        """
        The `ManualConfiguration` object. Read the description below.
        """
        subject_name_id_format: NotRequired[pulumi.Input[builtins.str]]
        """
        The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        subject_name_id_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
elif False:
    ProjectApplicationsSamlApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 acs_allowed_callback_urls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dynamic_configuration: Optional[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs']] = None,
                 force_authentication: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 login_page_url: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 manual_configuration: Optional[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs']] = None,
                 subject_name_id_format: Optional[pulumi.Input[builtins.str]] = None,
                 subject_name_id_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A name for the SAML application.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] acs_allowed_callback_urls: A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]] attribute_mappings: The `AttributeMapping` object. Read the description below.
        :param pulumi.Input[builtins.str] default_relay_state: The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        :param pulumi.Input[builtins.str] description: A description for the SAML application.
        :param pulumi.Input[builtins.bool] disabled: Whether the application should be enabled or disabled.
        :param pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs'] dynamic_configuration: The `DynamicConfiguration` object. Read the description below.
        :param pulumi.Input[builtins.bool] force_authentication: This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        :param pulumi.Input[builtins.str] id: An optional identifier for the SAML application.
        :param pulumi.Input[builtins.str] login_page_url: The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param pulumi.Input[builtins.str] logo: A logo for the SAML application. Should be a hosted image URL.
        :param pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs'] manual_configuration: The `ManualConfiguration` object. Read the description below.
        :param pulumi.Input[builtins.str] subject_name_id_format: The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param pulumi.Input[builtins.str] subject_name_id_type: The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        pulumi.set(__self__, "name", name)
        if acs_allowed_callback_urls is not None:
            pulumi.set(__self__, "acs_allowed_callback_urls", acs_allowed_callback_urls)
        if attribute_mappings is not None:
            pulumi.set(__self__, "attribute_mappings", attribute_mappings)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dynamic_configuration is not None:
            pulumi.set(__self__, "dynamic_configuration", dynamic_configuration)
        if force_authentication is not None:
            pulumi.set(__self__, "force_authentication", force_authentication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if login_page_url is not None:
            pulumi.set(__self__, "login_page_url", login_page_url)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manual_configuration is not None:
            pulumi.set(__self__, "manual_configuration", manual_configuration)
        if subject_name_id_format is not None:
            pulumi.set(__self__, "subject_name_id_format", subject_name_id_format)
        if subject_name_id_type is not None:
            pulumi.set(__self__, "subject_name_id_type", subject_name_id_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A name for the SAML application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="acsAllowedCallbackUrls")
    def acs_allowed_callback_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        """
        return pulumi.get(self, "acs_allowed_callback_urls")

    @acs_allowed_callback_urls.setter
    def acs_allowed_callback_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "acs_allowed_callback_urls", value)

    @property
    @pulumi.getter(name="attributeMappings")
    def attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]]]:
        """
        The `AttributeMapping` object. Read the description below.
        """
        return pulumi.get(self, "attribute_mappings")

    @attribute_mappings.setter
    def attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]]]):
        pulumi.set(self, "attribute_mappings", value)

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_relay_state", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description for the SAML application.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the application should be enabled or disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="dynamicConfiguration")
    def dynamic_configuration(self) -> Optional[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs']]:
        """
        The `DynamicConfiguration` object. Read the description below.
        """
        return pulumi.get(self, "dynamic_configuration")

    @dynamic_configuration.setter
    def dynamic_configuration(self, value: Optional[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs']]):
        pulumi.set(self, "dynamic_configuration", value)

    @property
    @pulumi.getter(name="forceAuthentication")
    def force_authentication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        return pulumi.get(self, "force_authentication")

    @force_authentication.setter
    def force_authentication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_authentication", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional identifier for the SAML application.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="loginPageUrl")
    def login_page_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "login_page_url")

    @login_page_url.setter
    def login_page_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "login_page_url", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A logo for the SAML application. Should be a hosted image URL.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="manualConfiguration")
    def manual_configuration(self) -> Optional[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs']]:
        """
        The `ManualConfiguration` object. Read the description below.
        """
        return pulumi.get(self, "manual_configuration")

    @manual_configuration.setter
    def manual_configuration(self, value: Optional[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs']]):
        pulumi.set(self, "manual_configuration", value)

    @property
    @pulumi.getter(name="subjectNameIdFormat")
    def subject_name_id_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "subject_name_id_format")

    @subject_name_id_format.setter
    def subject_name_id_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject_name_id_format", value)

    @property
    @pulumi.getter(name="subjectNameIdType")
    def subject_name_id_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "subject_name_id_type")

    @subject_name_id_type.setter
    def subject_name_id_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject_name_id_type", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationAttributeMappingArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the attribute.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the attribute.
        """
elif False:
    ProjectApplicationsSamlApplicationAttributeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationAttributeMappingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: The name of the attribute.
        :param pulumi.Input[builtins.str] value: The value of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict(TypedDict):
        metadata_url: pulumi.Input[builtins.str]
        """
        The metadata URL when retrieving the connection details dynamically.
        """
elif False:
    ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationDynamicConfigurationArgs:
    def __init__(__self__, *,
                 metadata_url: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] metadata_url: The metadata URL when retrieving the connection details dynamically.
        """
        pulumi.set(__self__, "metadata_url", metadata_url)

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> pulumi.Input[builtins.str]:
        """
        The metadata URL when retrieving the connection details dynamically.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metadata_url", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationManualConfigurationArgsDict(TypedDict):
        acs_url: pulumi.Input[builtins.str]
        """
        Enter the `ACS URL` from the SP.
        """
        certificate: pulumi.Input[builtins.str]
        """
        Enter the `Certificate` from the SP.
        """
        entity_id: pulumi.Input[builtins.str]
        """
        Enter the `Entity Id` from the SP.
        """
elif False:
    ProjectApplicationsSamlApplicationManualConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationManualConfigurationArgs:
    def __init__(__self__, *,
                 acs_url: pulumi.Input[builtins.str],
                 certificate: pulumi.Input[builtins.str],
                 entity_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] acs_url: Enter the `ACS URL` from the SP.
        :param pulumi.Input[builtins.str] certificate: Enter the `Certificate` from the SP.
        :param pulumi.Input[builtins.str] entity_id: Enter the `Entity Id` from the SP.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "entity_id", entity_id)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> pulumi.Input[builtins.str]:
        """
        Enter the `ACS URL` from the SP.
        """
        return pulumi.get(self, "acs_url")

    @acs_url.setter
    def acs_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "acs_url", value)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[builtins.str]:
        """
        Enter the `Certificate` from the SP.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[builtins.str]:
        """
        Enter the `Entity Id` from the SP.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "entity_id", value)


if not MYPY:
    class ProjectAttributesArgsDict(TypedDict):
        tenants: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgsDict']]]]
        """
        A list of `TenantAttribute`. Read the description below.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgsDict']]]]
        """
        A list of `UserAttribute`. Read the description below.
        """
elif False:
    ProjectAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesArgs:
    def __init__(__self__, *,
                 tenants: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]] tenants: A list of `TenantAttribute`. Read the description below.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]] users: A list of `UserAttribute`. Read the description below.
        """
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]]]:
        """
        A list of `TenantAttribute`. Read the description below.
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]]]):
        pulumi.set(self, "tenants", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]]]:
        """
        A list of `UserAttribute`. Read the description below.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class ProjectAttributesTenantArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the attribute.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        authorization: NotRequired[pulumi.Input['ProjectAttributesTenantAuthorizationArgsDict']]
        select_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When the attribute type is "multiselect". A list of options to chose from.
        """
elif False:
    ProjectAttributesTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesTenantArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 authorization: Optional[pulumi.Input['ProjectAttributesTenantAuthorizationArgs']] = None,
                 select_options: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the attribute.
        :param pulumi.Input[builtins.str] type: The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] select_options: When the attribute type is "multiselect". A list of options to chose from.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if select_options is not None:
            pulumi.set(__self__, "select_options", select_options)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ProjectAttributesTenantAuthorizationArgs']]:
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ProjectAttributesTenantAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="selectOptions")
    def select_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When the attribute type is "multiselect". A list of options to chose from.
        """
        return pulumi.get(self, "select_options")

    @select_options.setter
    def select_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "select_options", value)


if not MYPY:
    class ProjectAttributesTenantAuthorizationArgsDict(TypedDict):
        view_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    ProjectAttributesTenantAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesTenantAuthorizationArgs:
    def __init__(__self__, *,
                 view_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if view_permissions is not None:
            pulumi.set(__self__, "view_permissions", view_permissions)

    @property
    @pulumi.getter(name="viewPermissions")
    def view_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "view_permissions")

    @view_permissions.setter
    def view_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "view_permissions", value)


if not MYPY:
    class ProjectAttributesUserArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the attribute.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        select_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When the attribute type is "multiselect". A list of options to chose from.
        """
        widget_authorization: NotRequired[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgsDict']]
        """
        The `UserAttributeWidgetAuthorization` object. Read the description below.
        """
elif False:
    ProjectAttributesUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 select_options: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 widget_authorization: Optional[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the attribute.
        :param pulumi.Input[builtins.str] type: The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] select_options: When the attribute type is "multiselect". A list of options to chose from.
        :param pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs'] widget_authorization: The `UserAttributeWidgetAuthorization` object. Read the description below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if select_options is not None:
            pulumi.set(__self__, "select_options", select_options)
        if widget_authorization is not None:
            pulumi.set(__self__, "widget_authorization", widget_authorization)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="selectOptions")
    def select_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When the attribute type is "multiselect". A list of options to chose from.
        """
        return pulumi.get(self, "select_options")

    @select_options.setter
    def select_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "select_options", value)

    @property
    @pulumi.getter(name="widgetAuthorization")
    def widget_authorization(self) -> Optional[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs']]:
        """
        The `UserAttributeWidgetAuthorization` object. Read the description below.
        """
        return pulumi.get(self, "widget_authorization")

    @widget_authorization.setter
    def widget_authorization(self, value: Optional[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs']]):
        pulumi.set(self, "widget_authorization", value)


if not MYPY:
    class ProjectAttributesUserWidgetAuthorizationArgsDict(TypedDict):
        edit_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of permissions by name to set editing permissions to the attribute in widgets. e.g "SSO Admin".
        """
        view_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of permissions by name to set viewing permissions to the attribute in widgets. e.g "SSO Admin".
        """
elif False:
    ProjectAttributesUserWidgetAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesUserWidgetAuthorizationArgs:
    def __init__(__self__, *,
                 edit_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 view_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] edit_permissions: A list of permissions by name to set editing permissions to the attribute in widgets. e.g "SSO Admin".
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] view_permissions: A list of permissions by name to set viewing permissions to the attribute in widgets. e.g "SSO Admin".
        """
        if edit_permissions is not None:
            pulumi.set(__self__, "edit_permissions", edit_permissions)
        if view_permissions is not None:
            pulumi.set(__self__, "view_permissions", view_permissions)

    @property
    @pulumi.getter(name="editPermissions")
    def edit_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of permissions by name to set editing permissions to the attribute in widgets. e.g "SSO Admin".
        """
        return pulumi.get(self, "edit_permissions")

    @edit_permissions.setter
    def edit_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "edit_permissions", value)

    @property
    @pulumi.getter(name="viewPermissions")
    def view_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of permissions by name to set viewing permissions to the attribute in widgets. e.g "SSO Admin".
        """
        return pulumi.get(self, "view_permissions")

    @view_permissions.setter
    def view_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "view_permissions", value)


if not MYPY:
    class ProjectAuthenticationArgsDict(TypedDict):
        embedded_link: NotRequired[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgsDict']]
        """
        Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        """
        enchanted_link: NotRequired[pulumi.Input['ProjectAuthenticationEnchantedLinkArgsDict']]
        """
        An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        """
        magic_link: NotRequired[pulumi.Input['ProjectAuthenticationMagicLinkArgsDict']]
        """
        An authentication method where a user receives a unique link via email to log in.
        """
        oauth: NotRequired[pulumi.Input['ProjectAuthenticationOauthArgsDict']]
        """
        Authentication using Open Authorization, which allows users to authenticate with various external services.
        """
        otp: NotRequired[pulumi.Input['ProjectAuthenticationOtpArgsDict']]
        """
        A dynamically generated set of numbers, granting the user one-time access.
        """
        passkeys: NotRequired[pulumi.Input['ProjectAuthenticationPasskeysArgsDict']]
        """
        Device-based passwordless authentication, using fingerprint, face scan, and more.
        """
        password: NotRequired[pulumi.Input['ProjectAuthenticationPasswordArgsDict']]
        """
        The classic username and password combination used for authentication.
        """
        sso: NotRequired[pulumi.Input['ProjectAuthenticationSsoArgsDict']]
        """
        Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        """
        totp: NotRequired[pulumi.Input['ProjectAuthenticationTotpArgsDict']]
        """
        A one-time code generated for the user using a shared secret and time.
        """
elif False:
    ProjectAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationArgs:
    def __init__(__self__, *,
                 embedded_link: Optional[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs']] = None,
                 enchanted_link: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkArgs']] = None,
                 magic_link: Optional[pulumi.Input['ProjectAuthenticationMagicLinkArgs']] = None,
                 oauth: Optional[pulumi.Input['ProjectAuthenticationOauthArgs']] = None,
                 otp: Optional[pulumi.Input['ProjectAuthenticationOtpArgs']] = None,
                 passkeys: Optional[pulumi.Input['ProjectAuthenticationPasskeysArgs']] = None,
                 password: Optional[pulumi.Input['ProjectAuthenticationPasswordArgs']] = None,
                 sso: Optional[pulumi.Input['ProjectAuthenticationSsoArgs']] = None,
                 totp: Optional[pulumi.Input['ProjectAuthenticationTotpArgs']] = None):
        """
        :param pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs'] embedded_link: Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        :param pulumi.Input['ProjectAuthenticationEnchantedLinkArgs'] enchanted_link: An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        :param pulumi.Input['ProjectAuthenticationMagicLinkArgs'] magic_link: An authentication method where a user receives a unique link via email to log in.
        :param pulumi.Input['ProjectAuthenticationOauthArgs'] oauth: Authentication using Open Authorization, which allows users to authenticate with various external services.
        :param pulumi.Input['ProjectAuthenticationOtpArgs'] otp: A dynamically generated set of numbers, granting the user one-time access.
        :param pulumi.Input['ProjectAuthenticationPasskeysArgs'] passkeys: Device-based passwordless authentication, using fingerprint, face scan, and more.
        :param pulumi.Input['ProjectAuthenticationPasswordArgs'] password: The classic username and password combination used for authentication.
        :param pulumi.Input['ProjectAuthenticationSsoArgs'] sso: Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        :param pulumi.Input['ProjectAuthenticationTotpArgs'] totp: A one-time code generated for the user using a shared secret and time.
        """
        if embedded_link is not None:
            pulumi.set(__self__, "embedded_link", embedded_link)
        if enchanted_link is not None:
            pulumi.set(__self__, "enchanted_link", enchanted_link)
        if magic_link is not None:
            pulumi.set(__self__, "magic_link", magic_link)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)
        if otp is not None:
            pulumi.set(__self__, "otp", otp)
        if passkeys is not None:
            pulumi.set(__self__, "passkeys", passkeys)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if sso is not None:
            pulumi.set(__self__, "sso", sso)
        if totp is not None:
            pulumi.set(__self__, "totp", totp)

    @property
    @pulumi.getter(name="embeddedLink")
    def embedded_link(self) -> Optional[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs']]:
        """
        Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        """
        return pulumi.get(self, "embedded_link")

    @embedded_link.setter
    def embedded_link(self, value: Optional[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs']]):
        pulumi.set(self, "embedded_link", value)

    @property
    @pulumi.getter(name="enchantedLink")
    def enchanted_link(self) -> Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkArgs']]:
        """
        An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        """
        return pulumi.get(self, "enchanted_link")

    @enchanted_link.setter
    def enchanted_link(self, value: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkArgs']]):
        pulumi.set(self, "enchanted_link", value)

    @property
    @pulumi.getter(name="magicLink")
    def magic_link(self) -> Optional[pulumi.Input['ProjectAuthenticationMagicLinkArgs']]:
        """
        An authentication method where a user receives a unique link via email to log in.
        """
        return pulumi.get(self, "magic_link")

    @magic_link.setter
    def magic_link(self, value: Optional[pulumi.Input['ProjectAuthenticationMagicLinkArgs']]):
        pulumi.set(self, "magic_link", value)

    @property
    @pulumi.getter
    def oauth(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthArgs']]:
        """
        Authentication using Open Authorization, which allows users to authenticate with various external services.
        """
        return pulumi.get(self, "oauth")

    @oauth.setter
    def oauth(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthArgs']]):
        pulumi.set(self, "oauth", value)

    @property
    @pulumi.getter
    def otp(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpArgs']]:
        """
        A dynamically generated set of numbers, granting the user one-time access.
        """
        return pulumi.get(self, "otp")

    @otp.setter
    def otp(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpArgs']]):
        pulumi.set(self, "otp", value)

    @property
    @pulumi.getter
    def passkeys(self) -> Optional[pulumi.Input['ProjectAuthenticationPasskeysArgs']]:
        """
        Device-based passwordless authentication, using fingerprint, face scan, and more.
        """
        return pulumi.get(self, "passkeys")

    @passkeys.setter
    def passkeys(self, value: Optional[pulumi.Input['ProjectAuthenticationPasskeysArgs']]):
        pulumi.set(self, "passkeys", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['ProjectAuthenticationPasswordArgs']]:
        """
        The classic username and password combination used for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['ProjectAuthenticationPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def sso(self) -> Optional[pulumi.Input['ProjectAuthenticationSsoArgs']]:
        """
        Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        """
        return pulumi.get(self, "sso")

    @sso.setter
    def sso(self, value: Optional[pulumi.Input['ProjectAuthenticationSsoArgs']]):
        pulumi.set(self, "sso", value)

    @property
    @pulumi.getter
    def totp(self) -> Optional[pulumi.Input['ProjectAuthenticationTotpArgs']]:
        """
        A one-time code generated for the user using a shared secret and time.
        """
        return pulumi.get(self, "totp")

    @totp.setter
    def totp(self, value: Optional[pulumi.Input['ProjectAuthenticationTotpArgs']]):
        pulumi.set(self, "totp", value)


if not MYPY:
    class ProjectAuthenticationEmbeddedLinkArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        expiration_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The amount of time that the embedded link will be valid for.
        """
elif False:
    ProjectAuthenticationEmbeddedLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEmbeddedLinkArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 expiration_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] expiration_time: The amount of time that the embedded link will be valid for.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The amount of time that the embedded link will be valid for.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expiration_time", value)


if not MYPY:
    class ProjectAuthenticationEnchantedLinkArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgsDict']]
        """
        Settings related to sending emails as part of the enchanted link authentication.
        """
        expiration_time: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL to redirect users to after they log in using the enchanted link.
        """
elif False:
    ProjectAuthenticationEnchantedLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEnchantedLinkArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs']] = None,
                 expiration_time: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs'] email_service: Settings related to sending emails as part of the enchanted link authentication.
        :param pulumi.Input[builtins.str] redirect_url: The URL to redirect users to after they log in using the enchanted link.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs']]:
        """
        Settings related to sending emails as part of the enchanted link authentication.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL to redirect users to after they log in using the enchanted link.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationEnchantedLinkEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationEnchantedLinkEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEnchantedLinkEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        subject: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        html_body: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[builtins.str]]
        use_plain_text_body: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgsDict']]
        """
        Settings related to sending emails as part of the magic link authentication.
        """
        expiration_time: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL to redirect users to after they log in using the magic link.
        """
        text_service: NotRequired[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgsDict']]
        """
        Settings related to sending SMS messages as part of the magic link authentication.
        """
elif False:
    ProjectAuthenticationMagicLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs']] = None,
                 expiration_time: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None,
                 text_service: Optional[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs'] email_service: Settings related to sending emails as part of the magic link authentication.
        :param pulumi.Input[builtins.str] redirect_url: The URL to redirect users to after they log in using the magic link.
        :param pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs'] text_service: Settings related to sending SMS messages as part of the magic link authentication.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if text_service is not None:
            pulumi.set(__self__, "text_service", text_service)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs']]:
        """
        Settings related to sending emails as part of the magic link authentication.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL to redirect users to after they log in using the magic link.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter(name="textService")
    def text_service(self) -> Optional[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs']]:
        """
        Settings related to sending SMS messages as part of the magic link authentication.
        """
        return pulumi.get(self, "text_service")

    @text_service.setter
    def text_service(self, value: Optional[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs']]):
        pulumi.set(self, "text_service", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationMagicLinkEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        subject: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        html_body: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[builtins.str]]
        use_plain_text_body: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkTextServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationMagicLinkTextServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkTextServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict(TypedDict):
        body: pulumi.Input[builtins.str]
        name: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkTextServiceTemplateArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthenticationOauthArgsDict(TypedDict):
        custom: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgsDict']]]]
        """
        Custom OAuth providers configured for this project.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        system: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemArgsDict']]
        """
        Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
elif False:
    ProjectAuthenticationOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthArgs:
    def __init__(__self__, *,
                 custom: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 system: Optional[pulumi.Input['ProjectAuthenticationOauthSystemArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]] custom: Custom OAuth providers configured for this project.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationOauthSystemArgs'] system: Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if system is not None:
            pulumi.set(__self__, "system", system)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]]]:
        """
        Custom OAuth providers configured for this project.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]]]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def system(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemArgs']]:
        """
        Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
        return pulumi.get(self, "system")

    @system.setter
    def system(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemArgs']]):
        pulumi.set(self, "system", value)


if not MYPY:
    class ProjectAuthenticationOauthCustomArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthCustomArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthCustomProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemArgsDict(TypedDict):
        apple: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgsDict']]
        """
        Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        """
        discord: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgsDict']]
        """
        Discord's OAuth provider, allowing users to authenticate with their Discord account.
        """
        facebook: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgsDict']]
        """
        Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        """
        github: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgsDict']]
        """
        GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        """
        gitlab: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgsDict']]
        """
        GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        """
        google: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgsDict']]
        """
        Google's OAuth provider, allowing users to authenticate with their Google account.
        """
        linkedin: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgsDict']]
        """
        LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        """
        microsoft: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgsDict']]
        """
        Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        """
        slack: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgsDict']]
        """
        Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
elif False:
    ProjectAuthenticationOauthSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs']] = None,
                 discord: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs']] = None,
                 facebook: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs']] = None,
                 github: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs']] = None,
                 google: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs']] = None,
                 linkedin: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs']] = None,
                 microsoft: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs']] = None,
                 slack: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs']] = None):
        """
        :param pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs'] apple: Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs'] discord: Discord's OAuth provider, allowing users to authenticate with their Discord account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs'] facebook: Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs'] github: GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs'] gitlab: GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs'] google: Google's OAuth provider, allowing users to authenticate with their Google account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs'] linkedin: LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs'] microsoft: Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs'] slack: Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if discord is not None:
            pulumi.set(__self__, "discord", discord)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if linkedin is not None:
            pulumi.set(__self__, "linkedin", linkedin)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)

    @property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs']]:
        """
        Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        """
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs']]):
        pulumi.set(self, "apple", value)

    @property
    @pulumi.getter
    def discord(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs']]:
        """
        Discord's OAuth provider, allowing users to authenticate with their Discord account.
        """
        return pulumi.get(self, "discord")

    @discord.setter
    def discord(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs']]):
        pulumi.set(self, "discord", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs']]:
        """
        Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs']]:
        """
        GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs']]:
        """
        GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs']]:
        """
        Google's OAuth provider, allowing users to authenticate with their Google account.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def linkedin(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs']]:
        """
        LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        """
        return pulumi.get(self, "linkedin")

    @linkedin.setter
    def linkedin(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs']]):
        pulumi.set(self, "linkedin", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs']]:
        """
        Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs']]:
        """
        Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs']]):
        pulumi.set(self, "slack", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemAppleArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemAppleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemAppleArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemDiscordArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemDiscordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemDiscordArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemFacebookArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemFacebookArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGithubArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGithubArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGitlabArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGitlabArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGoogleArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGoogleArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemLinkedinArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemLinkedinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemLinkedinArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemMicrosoftArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemMicrosoftArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemSlackArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        jwks_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict']]
        """
        Settings related to token management for the OAuth provider.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        user_info_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemSlackArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 merge_user_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs'] provider_token_management: Settings related to token management for the OAuth provider.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs']]:
        """
        Settings related to token management for the OAuth provider.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict(TypedDict):
        callback_domain: NotRequired[pulumi.Input[builtins.str]]
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs:
    def __init__(__self__, *,
                 callback_domain: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None):
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationOtpArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        domain: NotRequired[pulumi.Input[builtins.str]]
        """
        The domain to embed in OTP messages.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgsDict']]
        """
        Settings related to sending emails with OTP codes.
        """
        expiration_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The amount of time that an OTP code will be valid for.
        """
        text_service: NotRequired[pulumi.Input['ProjectAuthenticationOtpTextServiceArgsDict']]
        """
        Settings related to sending SMS messages with OTP codes.
        """
        voice_service: NotRequired[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgsDict']]
        """
        Settings related to voice calls with OTP codes.
        """
elif False:
    ProjectAuthenticationOtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 domain: Optional[pulumi.Input[builtins.str]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs']] = None,
                 expiration_time: Optional[pulumi.Input[builtins.str]] = None,
                 text_service: Optional[pulumi.Input['ProjectAuthenticationOtpTextServiceArgs']] = None,
                 voice_service: Optional[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] domain: The domain to embed in OTP messages.
        :param pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs'] email_service: Settings related to sending emails with OTP codes.
        :param pulumi.Input[builtins.str] expiration_time: The amount of time that an OTP code will be valid for.
        :param pulumi.Input['ProjectAuthenticationOtpTextServiceArgs'] text_service: Settings related to sending SMS messages with OTP codes.
        :param pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs'] voice_service: Settings related to voice calls with OTP codes.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if text_service is not None:
            pulumi.set(__self__, "text_service", text_service)
        if voice_service is not None:
            pulumi.set(__self__, "voice_service", voice_service)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The domain to embed in OTP messages.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs']]:
        """
        Settings related to sending emails with OTP codes.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The amount of time that an OTP code will be valid for.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="textService")
    def text_service(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpTextServiceArgs']]:
        """
        Settings related to sending SMS messages with OTP codes.
        """
        return pulumi.get(self, "text_service")

    @text_service.setter
    def text_service(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpTextServiceArgs']]):
        pulumi.set(self, "text_service", value)

    @property
    @pulumi.getter(name="voiceService")
    def voice_service(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs']]:
        """
        Settings related to voice calls with OTP codes.
        """
        return pulumi.get(self, "voice_service")

    @voice_service.setter
    def voice_service(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs']]):
        pulumi.set(self, "voice_service", value)


if not MYPY:
    class ProjectAuthenticationOtpEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationOtpEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationOtpEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        subject: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        html_body: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[builtins.str]]
        use_plain_text_body: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectAuthenticationOtpEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationOtpTextServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationOtpTextServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpTextServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationOtpTextServiceTemplateArgsDict(TypedDict):
        body: pulumi.Input[builtins.str]
        name: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOtpTextServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpTextServiceTemplateArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthenticationOtpVoiceServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationOtpVoiceServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpVoiceServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationOtpVoiceServiceTemplateArgsDict(TypedDict):
        body: pulumi.Input[builtins.str]
        name: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthenticationOtpVoiceServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpVoiceServiceTemplateArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthenticationPasskeysArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        top_level_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        Passkeys will be usable in the following domain and all its subdomains.
        """
elif False:
    ProjectAuthenticationPasskeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasskeysArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 top_level_domain: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.str] top_level_domain: Passkeys will be usable in the following domain and all its subdomains.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if top_level_domain is not None:
            pulumi.set(__self__, "top_level_domain", top_level_domain)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="topLevelDomain")
    def top_level_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Passkeys will be usable in the following domain and all its subdomains.
        """
        return pulumi.get(self, "top_level_domain")

    @top_level_domain.setter
    def top_level_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "top_level_domain", value)


if not MYPY:
    class ProjectAuthenticationPasswordArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgsDict']]
        """
        Settings related to sending password reset emails as part of the password feature.
        """
        expiration: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether users are required to change their password periodically.
        """
        expiration_weeks: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of weeks after which a user's password expires and they need to replace it.
        """
        lock: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the user account should be locked after a specified number of failed login attempts.
        """
        lock_attempts: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of failed login attempts allowed before an account is locked.
        """
        lowercase: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether passwords must contain at least one lowercase letter.
        """
        min_length: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum length of the password that users are required to use. The maximum length is always `64`.
        """
        non_alphanumeric: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        """
        number: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether passwords must contain at least one number.
        """
        reuse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to forbid password reuse when users change their password.
        """
        reuse_amount: NotRequired[pulumi.Input[builtins.int]]
        uppercase: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether passwords must contain at least one uppercase letter.
        """
elif False:
    ProjectAuthenticationPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasswordArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs']] = None,
                 expiration: Optional[pulumi.Input[builtins.bool]] = None,
                 expiration_weeks: Optional[pulumi.Input[builtins.int]] = None,
                 lock: Optional[pulumi.Input[builtins.bool]] = None,
                 lock_attempts: Optional[pulumi.Input[builtins.int]] = None,
                 lowercase: Optional[pulumi.Input[builtins.bool]] = None,
                 min_length: Optional[pulumi.Input[builtins.int]] = None,
                 non_alphanumeric: Optional[pulumi.Input[builtins.bool]] = None,
                 number: Optional[pulumi.Input[builtins.bool]] = None,
                 reuse: Optional[pulumi.Input[builtins.bool]] = None,
                 reuse_amount: Optional[pulumi.Input[builtins.int]] = None,
                 uppercase: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs'] email_service: Settings related to sending password reset emails as part of the password feature.
        :param pulumi.Input[builtins.bool] expiration: Whether users are required to change their password periodically.
        :param pulumi.Input[builtins.int] expiration_weeks: The number of weeks after which a user's password expires and they need to replace it.
        :param pulumi.Input[builtins.bool] lock: Whether the user account should be locked after a specified number of failed login attempts.
        :param pulumi.Input[builtins.int] lock_attempts: The number of failed login attempts allowed before an account is locked.
        :param pulumi.Input[builtins.bool] lowercase: Whether passwords must contain at least one lowercase letter.
        :param pulumi.Input[builtins.int] min_length: The minimum length of the password that users are required to use. The maximum length is always `64`.
        :param pulumi.Input[builtins.bool] non_alphanumeric: Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        :param pulumi.Input[builtins.bool] number: Whether passwords must contain at least one number.
        :param pulumi.Input[builtins.bool] reuse: Whether to forbid password reuse when users change their password.
        :param pulumi.Input[builtins.bool] uppercase: Whether passwords must contain at least one uppercase letter.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if expiration_weeks is not None:
            pulumi.set(__self__, "expiration_weeks", expiration_weeks)
        if lock is not None:
            pulumi.set(__self__, "lock", lock)
        if lock_attempts is not None:
            pulumi.set(__self__, "lock_attempts", lock_attempts)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if non_alphanumeric is not None:
            pulumi.set(__self__, "non_alphanumeric", non_alphanumeric)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if reuse is not None:
            pulumi.set(__self__, "reuse", reuse)
        if reuse_amount is not None:
            pulumi.set(__self__, "reuse_amount", reuse_amount)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs']]:
        """
        Settings related to sending password reset emails as part of the password feature.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether users are required to change their password periodically.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter(name="expirationWeeks")
    def expiration_weeks(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of weeks after which a user's password expires and they need to replace it.
        """
        return pulumi.get(self, "expiration_weeks")

    @expiration_weeks.setter
    def expiration_weeks(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expiration_weeks", value)

    @property
    @pulumi.getter
    def lock(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the user account should be locked after a specified number of failed login attempts.
        """
        return pulumi.get(self, "lock")

    @lock.setter
    def lock(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "lock", value)

    @property
    @pulumi.getter(name="lockAttempts")
    def lock_attempts(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of failed login attempts allowed before an account is locked.
        """
        return pulumi.get(self, "lock_attempts")

    @lock_attempts.setter
    def lock_attempts(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "lock_attempts", value)

    @property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether passwords must contain at least one lowercase letter.
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "lowercase", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum length of the password that users are required to use. The maximum length is always `64`.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="nonAlphanumeric")
    def non_alphanumeric(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        """
        return pulumi.get(self, "non_alphanumeric")

    @non_alphanumeric.setter
    def non_alphanumeric(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "non_alphanumeric", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether passwords must contain at least one number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def reuse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to forbid password reuse when users change their password.
        """
        return pulumi.get(self, "reuse")

    @reuse.setter
    def reuse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "reuse", value)

    @property
    @pulumi.getter(name="reuseAmount")
    def reuse_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "reuse_amount")

    @reuse_amount.setter
    def reuse_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "reuse_amount", value)

    @property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether passwords must contain at least one uppercase letter.
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "uppercase", value)


if not MYPY:
    class ProjectAuthenticationPasswordEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgsDict']]]]
elif False:
    ProjectAuthenticationPasswordEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasswordEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]]] = None):
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]]]:
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationPasswordEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        subject: pulumi.Input[builtins.str]
        active: NotRequired[pulumi.Input[builtins.bool]]
        html_body: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[builtins.str]]
        use_plain_text_body: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectAuthenticationPasswordEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasswordEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationSsoArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        merge_users: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through SSO authentication.
        """
elif False:
    ProjectAuthenticationSsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationSsoArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 merge_users: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[builtins.bool] merge_users: Whether to merge existing user accounts with new ones created through SSO authentication.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if merge_users is not None:
            pulumi.set(__self__, "merge_users", merge_users)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="mergeUsers")
    def merge_users(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through SSO authentication.
        """
        return pulumi.get(self, "merge_users")

    @merge_users.setter
    def merge_users(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "merge_users", value)


if not MYPY:
    class ProjectAuthenticationTotpArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
elif False:
    ProjectAuthenticationTotpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationTotpArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class ProjectAuthorizationArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgsDict']]]]
        """
        A list of `Permission` objects.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgsDict']]]]
        """
        A list of `Role` objects.
        """
elif False:
    ProjectAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthorizationArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]] permissions: A list of `Permission` objects.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]] roles: A list of `Role` objects.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]]]:
        """
        A list of `Permission` objects.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]]]:
        """
        A list of `Role` objects.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class ProjectAuthorizationPermissionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A name for the permission.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description for the permission.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectAuthorizationPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthorizationPermissionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A name for the permission.
        :param pulumi.Input[builtins.str] description: A description for the permission.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A name for the permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description for the permission.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthorizationRoleArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A name for the role.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description for the role.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of permissions by name to be included in the role.
        """
elif False:
    ProjectAuthorizationRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthorizationRoleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] name: A name for the role.
        :param pulumi.Input[builtins.str] description: A description for the role.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] permissions: A list of permissions by name to be included in the role.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A name for the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description for the role.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of permissions by name to be included in the role.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class ProjectConnectorsArgsDict(TypedDict):
        abuseipdbs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgsDict']]]]
        """
        AbuseIPDB provides an API to identify if an IP address has been associated with malicious activities online.
        """
        amplitudes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgsDict']]]]
        """
        Amplitude, an analytics product that allows you to collects events from web and mobile apps, unify those and use those to better understand your customers needs.
        """
        audit_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgsDict']]]]
        aws_s3s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3ArgsDict']]]]
        aws_translates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgsDict']]]]
        clears: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsClearArgsDict']]]]
        """
        An identity verification platform that allow customers to digitally verify their identity from anywhere.
        """
        datadogs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgsDict']]]]
        """
        Datadog, an observability service for cloud-scale applications, providing monitoring of servers, databases, tools, and services, through a SaaS-based data analytics platform.
        """
        devrev_grows: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgsDict']]]]
        docebos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgsDict']]]]
        """
        Docebo is a cloud-based Learning Management System (LMS) designed to increase performance and learning engagement.
        """
        fingerprint_descopes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgsDict']]]]
        fingerprints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgsDict']]]]
        """
        Use the Fingerprint (formerly FingerprintJS) connector to add device intelligence and prevent fraud.
        """
        forters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgsDict']]]]
        """
        Use the Forter connector for account fraud prevention.
        """
        generic_sms_gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgsDict']]]]
        google_cloud_translations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgsDict']]]]
        hibps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgsDict']]]]
        """
        API to check if password appeared previously exposed in data breaches.
        """
        https: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgsDict']]]]
        """
        A general purpose HTTP client
        """
        hubspots: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgsDict']]]]
        """
        HubSpot is a CRM platform with software, integrations, and resources needed to connect marketing, sales, content management, and customer service.
        """
        incodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgsDict']]]]
        """
        Use the Incode connection to run identity verification processes like document checks or facial recognition.
        """
        intercoms: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgsDict']]]]
        """
        Intercom is a Conversational Relationship Platform (CRP).
        """
        lokalises: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgsDict']]]]
        """
        Localize the language of your login and user journey screens with the Lokalise connector.
        """
        mparticles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgsDict']]]]
        """
        Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        """
        newrelics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgsDict']]]]
        """
        Use this connector to send audit events and troubleshooting logs to New Relic.
        """
        recaptcha_enterprises: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgsDict']]]]
        recaptchas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgsDict']]]]
        """
        reCAPTCHA is a free google service that protects your site from spam and abuse. It uses advanced risk analysis techniques to tell humans and bots apart.
        """
        rekognitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgsDict']]]]
        """
        AWS Rekognition, cloud-based AI service that offers computer vision capabilities for analyzing and processing images. Useful for registration and verification processes, and can be used to detect fraud and prevent identity theft.
        """
        salesforce_marketing_clouds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgsDict']]]]
        salesforces: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgsDict']]]]
        """
        Salesforce is a leading cloud-based Customer Relationship Management (CRM) platform that helps businesses streamline their sales, service, and marketing operations.
        """
        segments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgsDict']]]]
        """
        Segment, an analytics product that allows you to collects events from web and mobile apps, unify those and use those to better understand your customers needs.
        """
        sendgrids: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgsDict']]]]
        ses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgsDict']]]]
        slacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgsDict']]]]
        """
        Send updates to your team on Slack.
        """
        smartlings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgsDict']]]]
        """
        Localize the language of your login and user journey screens with the Smartling connector.
        """
        smtps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgsDict']]]]
        sns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgsDict']]]]
        sumologics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgsDict']]]]
        """
        Sumo Logic, fast troubleshooting and investigation with AI/ML-powered log analytics
        """
        telesigns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgsDict']]]]
        """
        Telesign Phone number intelligence API provides risk score for phone numbers.
        """
        traceables: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgsDict']]]]
        """
        API security for a cloud-first, API-driven world.
        """
        twilio_cores: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgsDict']]]]
        twilio_verifies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgsDict']]]]
elif False:
    ProjectConnectorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsArgs:
    def __init__(__self__, *,
                 abuseipdbs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]]] = None,
                 amplitudes: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]]] = None,
                 audit_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]]] = None,
                 aws_s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]]] = None,
                 aws_translates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]]] = None,
                 clears: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsClearArgs']]]] = None,
                 datadogs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]]] = None,
                 devrev_grows: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]]] = None,
                 docebos: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]]] = None,
                 fingerprint_descopes: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]]] = None,
                 fingerprints: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]]] = None,
                 forters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]]] = None,
                 generic_sms_gateways: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]]] = None,
                 google_cloud_translations: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]]] = None,
                 hibps: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]]] = None,
                 https: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]]] = None,
                 hubspots: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]]] = None,
                 incodes: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]]] = None,
                 intercoms: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]]] = None,
                 lokalises: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]]] = None,
                 mparticles: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]]] = None,
                 newrelics: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]]] = None,
                 recaptcha_enterprises: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]]] = None,
                 recaptchas: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]]] = None,
                 rekognitions: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]]] = None,
                 salesforce_marketing_clouds: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]]] = None,
                 salesforces: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]]] = None,
                 segments: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]]] = None,
                 sendgrids: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]]] = None,
                 ses: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]]] = None,
                 slacks: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]]] = None,
                 smartlings: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]]] = None,
                 smtps: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]]] = None,
                 sns: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]]] = None,
                 sumologics: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]]] = None,
                 telesigns: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]]] = None,
                 traceables: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]]] = None,
                 twilio_cores: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]]] = None,
                 twilio_verifies: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]] abuseipdbs: AbuseIPDB provides an API to identify if an IP address has been associated with malicious activities online.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]] amplitudes: Amplitude, an analytics product that allows you to collects events from web and mobile apps, unify those and use those to better understand your customers needs.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsClearArgs']]] clears: An identity verification platform that allow customers to digitally verify their identity from anywhere.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]] datadogs: Datadog, an observability service for cloud-scale applications, providing monitoring of servers, databases, tools, and services, through a SaaS-based data analytics platform.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]] docebos: Docebo is a cloud-based Learning Management System (LMS) designed to increase performance and learning engagement.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]] fingerprints: Use the Fingerprint (formerly FingerprintJS) connector to add device intelligence and prevent fraud.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]] forters: Use the Forter connector for account fraud prevention.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]] hibps: API to check if password appeared previously exposed in data breaches.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]] https: A general purpose HTTP client
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]] hubspots: HubSpot is a CRM platform with software, integrations, and resources needed to connect marketing, sales, content management, and customer service.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]] incodes: Use the Incode connection to run identity verification processes like document checks or facial recognition.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]] intercoms: Intercom is a Conversational Relationship Platform (CRP).
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]] lokalises: Localize the language of your login and user journey screens with the Lokalise connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]] mparticles: Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]] newrelics: Use this connector to send audit events and troubleshooting logs to New Relic.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]] recaptchas: reCAPTCHA is a free google service that protects your site from spam and abuse. It uses advanced risk analysis techniques to tell humans and bots apart.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]] rekognitions: AWS Rekognition, cloud-based AI service that offers computer vision capabilities for analyzing and processing images. Useful for registration and verification processes, and can be used to detect fraud and prevent identity theft.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]] salesforces: Salesforce is a leading cloud-based Customer Relationship Management (CRM) platform that helps businesses streamline their sales, service, and marketing operations.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]] segments: Segment, an analytics product that allows you to collects events from web and mobile apps, unify those and use those to better understand your customers needs.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]] slacks: Send updates to your team on Slack.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]] smartlings: Localize the language of your login and user journey screens with the Smartling connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]] sumologics: Sumo Logic, fast troubleshooting and investigation with AI/ML-powered log analytics
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]] telesigns: Telesign Phone number intelligence API provides risk score for phone numbers.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]] traceables: API security for a cloud-first, API-driven world.
        """
        if abuseipdbs is not None:
            pulumi.set(__self__, "abuseipdbs", abuseipdbs)
        if amplitudes is not None:
            pulumi.set(__self__, "amplitudes", amplitudes)
        if audit_webhooks is not None:
            pulumi.set(__self__, "audit_webhooks", audit_webhooks)
        if aws_s3s is not None:
            pulumi.set(__self__, "aws_s3s", aws_s3s)
        if aws_translates is not None:
            pulumi.set(__self__, "aws_translates", aws_translates)
        if clears is not None:
            pulumi.set(__self__, "clears", clears)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if devrev_grows is not None:
            pulumi.set(__self__, "devrev_grows", devrev_grows)
        if docebos is not None:
            pulumi.set(__self__, "docebos", docebos)
        if fingerprint_descopes is not None:
            pulumi.set(__self__, "fingerprint_descopes", fingerprint_descopes)
        if fingerprints is not None:
            pulumi.set(__self__, "fingerprints", fingerprints)
        if forters is not None:
            pulumi.set(__self__, "forters", forters)
        if generic_sms_gateways is not None:
            pulumi.set(__self__, "generic_sms_gateways", generic_sms_gateways)
        if google_cloud_translations is not None:
            pulumi.set(__self__, "google_cloud_translations", google_cloud_translations)
        if hibps is not None:
            pulumi.set(__self__, "hibps", hibps)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if hubspots is not None:
            pulumi.set(__self__, "hubspots", hubspots)
        if incodes is not None:
            pulumi.set(__self__, "incodes", incodes)
        if intercoms is not None:
            pulumi.set(__self__, "intercoms", intercoms)
        if lokalises is not None:
            pulumi.set(__self__, "lokalises", lokalises)
        if mparticles is not None:
            pulumi.set(__self__, "mparticles", mparticles)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if recaptcha_enterprises is not None:
            pulumi.set(__self__, "recaptcha_enterprises", recaptcha_enterprises)
        if recaptchas is not None:
            pulumi.set(__self__, "recaptchas", recaptchas)
        if rekognitions is not None:
            pulumi.set(__self__, "rekognitions", rekognitions)
        if salesforce_marketing_clouds is not None:
            pulumi.set(__self__, "salesforce_marketing_clouds", salesforce_marketing_clouds)
        if salesforces is not None:
            pulumi.set(__self__, "salesforces", salesforces)
        if segments is not None:
            pulumi.set(__self__, "segments", segments)
        if sendgrids is not None:
            pulumi.set(__self__, "sendgrids", sendgrids)
        if ses is not None:
            pulumi.set(__self__, "ses", ses)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)
        if smartlings is not None:
            pulumi.set(__self__, "smartlings", smartlings)
        if smtps is not None:
            pulumi.set(__self__, "smtps", smtps)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if telesigns is not None:
            pulumi.set(__self__, "telesigns", telesigns)
        if traceables is not None:
            pulumi.set(__self__, "traceables", traceables)
        if twilio_cores is not None:
            pulumi.set(__self__, "twilio_cores", twilio_cores)
        if twilio_verifies is not None:
            pulumi.set(__self__, "twilio_verifies", twilio_verifies)

    @property
    @pulumi.getter
    def abuseipdbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]]]:
        """
        AbuseIPDB provides an API to identify if an IP address has been associated with malicious activities online.
        """
        return pulumi.get(self, "abuseipdbs")

    @abuseipdbs.setter
    def abuseipdbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]]]):
        pulumi.set(self, "abuseipdbs", value)

    @property
    @pulumi.getter
    def amplitudes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]]]:
        """
        Amplitude, an analytics product that allows you to collects events from web and mobile apps, unify those and use those to better understand your customers needs.
        """
        return pulumi.get(self, "amplitudes")

    @amplitudes.setter
    def amplitudes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]]]):
        pulumi.set(self, "amplitudes", value)

    @property
    @pulumi.getter(name="auditWebhooks")
    def audit_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]]]:
        return pulumi.get(self, "audit_webhooks")

    @audit_webhooks.setter
    def audit_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]]]):
        pulumi.set(self, "audit_webhooks", value)

    @property
    @pulumi.getter(name="awsS3s")
    def aws_s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]]]:
        return pulumi.get(self, "aws_s3s")

    @aws_s3s.setter
    def aws_s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]]]):
        pulumi.set(self, "aws_s3s", value)

    @property
    @pulumi.getter(name="awsTranslates")
    def aws_translates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]]]:
        return pulumi.get(self, "aws_translates")

    @aws_translates.setter
    def aws_translates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]]]):
        pulumi.set(self, "aws_translates", value)

    @property
    @pulumi.getter
    def clears(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsClearArgs']]]]:
        """
        An identity verification platform that allow customers to digitally verify their identity from anywhere.
        """
        return pulumi.get(self, "clears")

    @clears.setter
    def clears(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsClearArgs']]]]):
        pulumi.set(self, "clears", value)

    @property
    @pulumi.getter
    def datadogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]]]:
        """
        Datadog, an observability service for cloud-scale applications, providing monitoring of servers, databases, tools, and services, through a SaaS-based data analytics platform.
        """
        return pulumi.get(self, "datadogs")

    @datadogs.setter
    def datadogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]]]):
        pulumi.set(self, "datadogs", value)

    @property
    @pulumi.getter(name="devrevGrows")
    def devrev_grows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]]]:
        return pulumi.get(self, "devrev_grows")

    @devrev_grows.setter
    def devrev_grows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]]]):
        pulumi.set(self, "devrev_grows", value)

    @property
    @pulumi.getter
    def docebos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]]]:
        """
        Docebo is a cloud-based Learning Management System (LMS) designed to increase performance and learning engagement.
        """
        return pulumi.get(self, "docebos")

    @docebos.setter
    def docebos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]]]):
        pulumi.set(self, "docebos", value)

    @property
    @pulumi.getter(name="fingerprintDescopes")
    def fingerprint_descopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]]]:
        return pulumi.get(self, "fingerprint_descopes")

    @fingerprint_descopes.setter
    def fingerprint_descopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]]]):
        pulumi.set(self, "fingerprint_descopes", value)

    @property
    @pulumi.getter
    def fingerprints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]]]:
        """
        Use the Fingerprint (formerly FingerprintJS) connector to add device intelligence and prevent fraud.
        """
        return pulumi.get(self, "fingerprints")

    @fingerprints.setter
    def fingerprints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]]]):
        pulumi.set(self, "fingerprints", value)

    @property
    @pulumi.getter
    def forters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]]]:
        """
        Use the Forter connector for account fraud prevention.
        """
        return pulumi.get(self, "forters")

    @forters.setter
    def forters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]]]):
        pulumi.set(self, "forters", value)

    @property
    @pulumi.getter(name="genericSmsGateways")
    def generic_sms_gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]]]:
        return pulumi.get(self, "generic_sms_gateways")

    @generic_sms_gateways.setter
    def generic_sms_gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]]]):
        pulumi.set(self, "generic_sms_gateways", value)

    @property
    @pulumi.getter(name="googleCloudTranslations")
    def google_cloud_translations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]]]:
        return pulumi.get(self, "google_cloud_translations")

    @google_cloud_translations.setter
    def google_cloud_translations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]]]):
        pulumi.set(self, "google_cloud_translations", value)

    @property
    @pulumi.getter
    def hibps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]]]:
        """
        API to check if password appeared previously exposed in data breaches.
        """
        return pulumi.get(self, "hibps")

    @hibps.setter
    def hibps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]]]):
        pulumi.set(self, "hibps", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]]]:
        """
        A general purpose HTTP client
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]]]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter
    def hubspots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]]]:
        """
        HubSpot is a CRM platform with software, integrations, and resources needed to connect marketing, sales, content management, and customer service.
        """
        return pulumi.get(self, "hubspots")

    @hubspots.setter
    def hubspots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]]]):
        pulumi.set(self, "hubspots", value)

    @property
    @pulumi.getter
    def incodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]]]:
        """
        Use the Incode connection to run identity verification processes like document checks or facial recognition.
        """
        return pulumi.get(self, "incodes")

    @incodes.setter
    def incodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]]]):
        pulumi.set(self, "incodes", value)

    @property
    @pulumi.getter
    def intercoms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]]]:
        """
        Intercom is a Conversational Relationship Platform (CRP).
        """
        return pulumi.get(self, "intercoms")

    @intercoms.setter
    def intercoms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]]]):
        pulumi.set(self, "intercoms", value)

    @property
    @pulumi.getter
    def lokalises(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]]]:
        """
        Localize the language of your login and user journey screens with the Lokalise connector.
        """
        return pulumi.get(self, "lokalises")

    @lokalises.setter
    def lokalises(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]]]):
        pulumi.set(self, "lokalises", value)

    @property
    @pulumi.getter
    def mparticles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]]]:
        """
        Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        """
        return pulumi.get(self, "mparticles")

    @mparticles.setter
    def mparticles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]]]):
        pulumi.set(self, "mparticles", value)

    @property
    @pulumi.getter
    def newrelics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]]]:
        """
        Use this connector to send audit events and troubleshooting logs to New Relic.
        """
        return pulumi.get(self, "newrelics")

    @newrelics.setter
    def newrelics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]]]):
        pulumi.set(self, "newrelics", value)

    @property
    @pulumi.getter(name="recaptchaEnterprises")
    def recaptcha_enterprises(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]]]:
        return pulumi.get(self, "recaptcha_enterprises")

    @recaptcha_enterprises.setter
    def recaptcha_enterprises(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]]]):
        pulumi.set(self, "recaptcha_enterprises", value)

    @property
    @pulumi.getter
    def recaptchas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]]]:
        """
        reCAPTCHA is a free google service that protects your site from spam and abuse. It uses advanced risk analysis techniques to tell humans and bots apart.
        """
        return pulumi.get(self, "recaptchas")

    @recaptchas.setter
    def recaptchas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]]]):
        pulumi.set(self, "recaptchas", value)

    @property
    @pulumi.getter
    def rekognitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]]]:
        """
        AWS Rekognition, cloud-based AI service that offers computer vision capabilities for analyzing and processing images. Useful for registration and verification processes, and can be used to detect fraud and prevent identity theft.
        """
        return pulumi.get(self, "rekognitions")

    @rekognitions.setter
    def rekognitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]]]):
        pulumi.set(self, "rekognitions", value)

    @property
    @pulumi.getter(name="salesforceMarketingClouds")
    def salesforce_marketing_clouds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]]]:
        return pulumi.get(self, "salesforce_marketing_clouds")

    @salesforce_marketing_clouds.setter
    def salesforce_marketing_clouds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]]]):
        pulumi.set(self, "salesforce_marketing_clouds", value)

    @property
    @pulumi.getter
    def salesforces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]]]:
        """
        Salesforce is a leading cloud-based Customer Relationship Management (CRM) platform that helps businesses streamline their sales, service, and marketing operations.
        """
        return pulumi.get(self, "salesforces")

    @salesforces.setter
    def salesforces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]]]):
        pulumi.set(self, "salesforces", value)

    @property
    @pulumi.getter
    def segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]]]:
        """
        Segment, an analytics product that allows you to collects events from web and mobile apps, unify those and use those to better understand your customers needs.
        """
        return pulumi.get(self, "segments")

    @segments.setter
    def segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]]]):
        pulumi.set(self, "segments", value)

    @property
    @pulumi.getter
    def sendgrids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]]]:
        return pulumi.get(self, "sendgrids")

    @sendgrids.setter
    def sendgrids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]]]):
        pulumi.set(self, "sendgrids", value)

    @property
    @pulumi.getter
    def ses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]]]:
        return pulumi.get(self, "ses")

    @ses.setter
    def ses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]]]):
        pulumi.set(self, "ses", value)

    @property
    @pulumi.getter
    def slacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]]]:
        """
        Send updates to your team on Slack.
        """
        return pulumi.get(self, "slacks")

    @slacks.setter
    def slacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]]]):
        pulumi.set(self, "slacks", value)

    @property
    @pulumi.getter
    def smartlings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]]]:
        """
        Localize the language of your login and user journey screens with the Smartling connector.
        """
        return pulumi.get(self, "smartlings")

    @smartlings.setter
    def smartlings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]]]):
        pulumi.set(self, "smartlings", value)

    @property
    @pulumi.getter
    def smtps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]]]:
        return pulumi.get(self, "smtps")

    @smtps.setter
    def smtps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]]]):
        pulumi.set(self, "smtps", value)

    @property
    @pulumi.getter
    def sns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]]]:
        return pulumi.get(self, "sns")

    @sns.setter
    def sns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]]]):
        pulumi.set(self, "sns", value)

    @property
    @pulumi.getter
    def sumologics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]]]:
        """
        Sumo Logic, fast troubleshooting and investigation with AI/ML-powered log analytics
        """
        return pulumi.get(self, "sumologics")

    @sumologics.setter
    def sumologics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]]]):
        pulumi.set(self, "sumologics", value)

    @property
    @pulumi.getter
    def telesigns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]]]:
        """
        Telesign Phone number intelligence API provides risk score for phone numbers.
        """
        return pulumi.get(self, "telesigns")

    @telesigns.setter
    def telesigns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]]]):
        pulumi.set(self, "telesigns", value)

    @property
    @pulumi.getter
    def traceables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]]]:
        """
        API security for a cloud-first, API-driven world.
        """
        return pulumi.get(self, "traceables")

    @traceables.setter
    def traceables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]]]):
        pulumi.set(self, "traceables", value)

    @property
    @pulumi.getter(name="twilioCores")
    def twilio_cores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]]]:
        return pulumi.get(self, "twilio_cores")

    @twilio_cores.setter
    def twilio_cores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]]]):
        pulumi.set(self, "twilio_cores", value)

    @property
    @pulumi.getter(name="twilioVerifies")
    def twilio_verifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]]]:
        return pulumi.get(self, "twilio_verifies")

    @twilio_verifies.setter
    def twilio_verifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]]]):
        pulumi.set(self, "twilio_verifies", value)


if not MYPY:
    class ProjectConnectorsAbuseipdbArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        The unique AbuseIPDB API key.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsAbuseipdbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAbuseipdbArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: The unique AbuseIPDB API key.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        The unique AbuseIPDB API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsAmplitudeArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        The Amplitude API Key generated for the Descope service.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        server_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        """
        server_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
elif False:
    ProjectConnectorsAmplitudeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAmplitudeArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 server_url: Optional[pulumi.Input[builtins.str]] = None,
                 server_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: The Amplitude API Key generated for the Descope service.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] server_url: The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        :param pulumi.Input[builtins.str] server_zone: `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if server_zone is not None:
            pulumi.set(__self__, "server_zone", server_zone)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        The Amplitude API Key generated for the Descope service.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_url", value)

    @property
    @pulumi.getter(name="serverZone")
    def server_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
        return pulumi.get(self, "server_zone")

    @server_zone.setter
    def server_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_zone", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookArgsDict(TypedDict):
        base_url: pulumi.Input[builtins.str]
        """
        The base URL to fetch
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        insecure: NotRequired[pulumi.Input[builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
elif False:
    ProjectConnectorsAuditWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]]] = None,
                 authentication: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 insecure: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] base_url: The base URL to fetch
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[builtins.bool] insecure: Will ignore certificate errors raised by the client
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "name", name)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[builtins.str]:
        """
        The base URL to fetch
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "insecure", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        operator: pulumi.Input[builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    ProjectConnectorsAuditWebhookAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 operator: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict']]
        basic: NotRequired[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict']]
        bearer_token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsAuditWebhookAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[builtins.str]] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs']]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs']]:
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        token: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 token: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        username: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsAwsS3ArgsDict(TypedDict):
        access_key_id: pulumi.Input[builtins.str]
        """
        The unique AWS access key ID.
        """
        bucket: pulumi.Input[builtins.str]
        """
        The AWS S3 bucket. This bucket should already exist for the connector to work.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[builtins.str]
        """
        The AWS S3 region, e.g. `us-east-1`.
        """
        secret_access_key: pulumi.Input[builtins.str]
        """
        The secret AWS access key.
        """
        audit_enabled: NotRequired[pulumi.Input[builtins.bool]]
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgsDict']]]]
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        troubleshoot_log_enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectConnectorsAwsS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAwsS3Args:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[builtins.str],
                 bucket: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 secret_access_key: pulumi.Input[builtins.str],
                 audit_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] access_key_id: The unique AWS access key ID.
        :param pulumi.Input[builtins.str] bucket: The AWS S3 bucket. This bucket should already exist for the connector to work.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] region: The AWS S3 region, e.g. `us-east-1`.
        :param pulumi.Input[builtins.str] secret_access_key: The secret AWS access key.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[builtins.str]:
        """
        The unique AWS access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[builtins.str]:
        """
        The AWS S3 bucket. This bucket should already exist for the connector to work.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The AWS S3 region, e.g. `us-east-1`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[builtins.str]:
        """
        The secret AWS access key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]]]:
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsAwsS3AuditFilterArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        operator: pulumi.Input[builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    ProjectConnectorsAwsS3AuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAwsS3AuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 operator: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsAwsTranslateArgsDict(TypedDict):
        access_key_id: pulumi.Input[builtins.str]
        """
        AWS access key ID.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[builtins.str]
        """
        The AWS region to which this client will send requests. (e.g. us-east-1.)
        """
        secret_access_key: pulumi.Input[builtins.str]
        """
        AWS secret access key.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        session_token: NotRequired[pulumi.Input[builtins.str]]
        """
        (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
elif False:
    ProjectConnectorsAwsTranslateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAwsTranslateArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 secret_access_key: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 session_token: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_key_id: AWS access key ID.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] region: The AWS region to which this client will send requests. (e.g. us-east-1.)
        :param pulumi.Input[builtins.str] secret_access_key: AWS secret access key.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] session_token: (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[builtins.str]:
        """
        AWS access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The AWS region to which this client will send requests. (e.g. us-east-1.)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[builtins.str]:
        """
        AWS secret access key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_token", value)


if not MYPY:
    class ProjectConnectorsClearArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        Your CLEAR API key.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[builtins.str]
        """
        Your CLEAR project ID.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsClearArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsClearArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 project_id: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: Your CLEAR API key.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] project_id: Your CLEAR project ID.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        Your CLEAR API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[builtins.str]:
        """
        Your CLEAR project ID.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        The unique Datadog organization key.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        audit_enabled: NotRequired[pulumi.Input[builtins.bool]]
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgsDict']]]]
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        site: NotRequired[pulumi.Input[builtins.str]]
        """
        The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        """
        troubleshoot_log_enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectConnectorsDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 audit_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 site: Optional[pulumi.Input[builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: The unique Datadog organization key.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] site: The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        The unique Datadog organization key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]]]:
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "site", value)

    @property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsDatadogAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        operator: pulumi.Input[builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    ProjectConnectorsDatadogAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDatadogAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 operator: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsDevrevGrowArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        Authentication to DevRev APIs requires a personal access token (PAT).
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsDevrevGrowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDevrevGrowArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: Authentication to DevRev APIs requires a personal access token (PAT).
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        Authentication to DevRev APIs requires a personal access token (PAT).
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsDoceboArgsDict(TypedDict):
        base_url: pulumi.Input[builtins.str]
        """
        The Docebo api base url.
        """
        client_id: pulumi.Input[builtins.str]
        """
        The Docebo OAuth 2.0 app client ID.
        """
        client_secret: pulumi.Input[builtins.str]
        """
        The Docebo OAuth 2.0 app client secret.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        password: pulumi.Input[builtins.str]
        """
        The Docebo user's password.
        """
        username: pulumi.Input[builtins.str]
        """
        The Docebo username.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsDoceboArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDoceboArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[builtins.str],
                 client_id: pulumi.Input[builtins.str],
                 client_secret: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_url: The Docebo api base url.
        :param pulumi.Input[builtins.str] client_id: The Docebo OAuth 2.0 app client ID.
        :param pulumi.Input[builtins.str] client_secret: The Docebo OAuth 2.0 app client secret.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] password: The Docebo user's password.
        :param pulumi.Input[builtins.str] username: The Docebo username.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[builtins.str]:
        """
        The Docebo api base url.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        """
        The Docebo OAuth 2.0 app client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[builtins.str]:
        """
        The Docebo OAuth 2.0 app client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        """
        The Docebo user's password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        The Docebo username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsFingerprintArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        public_api_key: pulumi.Input[builtins.str]
        """
        The Fingerprint public API key.
        """
        secret_api_key: pulumi.Input[builtins.str]
        """
        The Fingerprint secret API key.
        """
        cloudflare_endpoint_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The Cloudflare integration Endpoint URL.
        """
        cloudflare_script_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The Cloudflare integration Script URL.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        use_cloudflare_integration: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
elif False:
    ProjectConnectorsFingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsFingerprintArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 public_api_key: pulumi.Input[builtins.str],
                 secret_api_key: pulumi.Input[builtins.str],
                 cloudflare_endpoint_url: Optional[pulumi.Input[builtins.str]] = None,
                 cloudflare_script_url: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 use_cloudflare_integration: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] public_api_key: The Fingerprint public API key.
        :param pulumi.Input[builtins.str] secret_api_key: The Fingerprint secret API key.
        :param pulumi.Input[builtins.str] cloudflare_endpoint_url: The Cloudflare integration Endpoint URL.
        :param pulumi.Input[builtins.str] cloudflare_script_url: The Cloudflare integration Script URL.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.bool] use_cloudflare_integration: Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        pulumi.set(__self__, "secret_api_key", secret_api_key)
        if cloudflare_endpoint_url is not None:
            pulumi.set(__self__, "cloudflare_endpoint_url", cloudflare_endpoint_url)
        if cloudflare_script_url is not None:
            pulumi.set(__self__, "cloudflare_script_url", cloudflare_script_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_cloudflare_integration is not None:
            pulumi.set(__self__, "use_cloudflare_integration", use_cloudflare_integration)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> pulumi.Input[builtins.str]:
        """
        The Fingerprint public API key.
        """
        return pulumi.get(self, "public_api_key")

    @public_api_key.setter
    def public_api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "public_api_key", value)

    @property
    @pulumi.getter(name="secretApiKey")
    def secret_api_key(self) -> pulumi.Input[builtins.str]:
        """
        The Fingerprint secret API key.
        """
        return pulumi.get(self, "secret_api_key")

    @secret_api_key.setter
    def secret_api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_api_key", value)

    @property
    @pulumi.getter(name="cloudflareEndpointUrl")
    def cloudflare_endpoint_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Cloudflare integration Endpoint URL.
        """
        return pulumi.get(self, "cloudflare_endpoint_url")

    @cloudflare_endpoint_url.setter
    def cloudflare_endpoint_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cloudflare_endpoint_url", value)

    @property
    @pulumi.getter(name="cloudflareScriptUrl")
    def cloudflare_script_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Cloudflare integration Script URL.
        """
        return pulumi.get(self, "cloudflare_script_url")

    @cloudflare_script_url.setter
    def cloudflare_script_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cloudflare_script_url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="useCloudflareIntegration")
    def use_cloudflare_integration(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
        return pulumi.get(self, "use_cloudflare_integration")

    @use_cloudflare_integration.setter
    def use_cloudflare_integration(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_cloudflare_integration", value)


if not MYPY:
    class ProjectConnectorsFingerprintDescopeArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        custom_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        The custom domain to fetch
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsFingerprintDescopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsFingerprintDescopeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 custom_domain: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] custom_domain: The custom domain to fetch
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The custom domain to fetch
        """
        return pulumi.get(self, "custom_domain")

    @custom_domain.setter
    def custom_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_domain", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsForterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[builtins.str]
        """
        The Forter secret key.
        """
        site_id: pulumi.Input[builtins.str]
        """
        The Forter site ID.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        override_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Override the user IP address.
        """
        override_user_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Override the user email.
        """
        overrides: NotRequired[pulumi.Input[builtins.bool]]
        """
        Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
elif False:
    ProjectConnectorsForterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsForterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 secret_key: pulumi.Input[builtins.str],
                 site_id: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 override_ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 override_user_email: Optional[pulumi.Input[builtins.str]] = None,
                 overrides: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] secret_key: The Forter secret key.
        :param pulumi.Input[builtins.str] site_id: The Forter site ID.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] override_ip_address: Override the user IP address.
        :param pulumi.Input[builtins.str] override_user_email: Override the user email.
        :param pulumi.Input[builtins.bool] overrides: Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_id", site_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_ip_address is not None:
            pulumi.set(__self__, "override_ip_address", override_ip_address)
        if override_user_email is not None:
            pulumi.set(__self__, "override_user_email", override_user_email)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[builtins.str]:
        """
        The Forter secret key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> pulumi.Input[builtins.str]:
        """
        The Forter site ID.
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="overrideIpAddress")
    def override_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Override the user IP address.
        """
        return pulumi.get(self, "override_ip_address")

    @override_ip_address.setter
    def override_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "override_ip_address", value)

    @property
    @pulumi.getter(name="overrideUserEmail")
    def override_user_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Override the user email.
        """
        return pulumi.get(self, "override_user_email")

    @override_user_email.setter
    def override_user_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "override_user_email", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "overrides", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        post_url: pulumi.Input[builtins.str]
        """
        The URL of the post message request
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        insecure: NotRequired[pulumi.Input[builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
        sender: NotRequired[pulumi.Input[builtins.str]]
        """
        The sender number
        """
        use_static_ips: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsGenericSmsGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 post_url: pulumi.Input[builtins.str],
                 authentication: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 insecure: Optional[pulumi.Input[builtins.bool]] = None,
                 sender: Optional[pulumi.Input[builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] post_url: The URL of the post message request
        :param pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[builtins.bool] insecure: Will ignore certificate errors raised by the client
        :param pulumi.Input[builtins.str] sender: The sender number
        :param pulumi.Input[builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "post_url", post_url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="postUrl")
    def post_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the post message request
        """
        return pulumi.get(self, "post_url")

    @post_url.setter
    def post_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "post_url", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def sender(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The sender number
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sender", value)

    @property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict']]
        basic: NotRequired[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict']]
        bearer_token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[builtins.str]] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs']]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs']]:
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        token: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 token: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        username: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsGoogleCloudTranslationArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[builtins.str]
        """
        The Google Cloud project ID where the Google Cloud Translation is managed.
        """
        service_account_json: pulumi.Input[builtins.str]
        """
        Service Account JSON associated with the current project.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsGoogleCloudTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGoogleCloudTranslationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 project_id: pulumi.Input[builtins.str],
                 service_account_json: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] project_id: The Google Cloud project ID where the Google Cloud Translation is managed.
        :param pulumi.Input[builtins.str] service_account_json: Service Account JSON associated with the current project.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account_json", service_account_json)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[builtins.str]:
        """
        The Google Cloud project ID where the Google Cloud Translation is managed.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="serviceAccountJson")
    def service_account_json(self) -> pulumi.Input[builtins.str]:
        """
        Service Account JSON associated with the current project.
        """
        return pulumi.get(self, "service_account_json")

    @service_account_json.setter
    def service_account_json(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_json", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsHibpArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsHibpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHibpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsHttpArgsDict(TypedDict):
        base_url: pulumi.Input[builtins.str]
        """
        The base URL to fetch
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsHttpAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        include_headers_in_context: NotRequired[pulumi.Input[builtins.bool]]
        """
        The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        """
        insecure: NotRequired[pulumi.Input[builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
        use_static_ips: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 authentication: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 include_headers_in_context: Optional[pulumi.Input[builtins.bool]] = None,
                 insecure: Optional[pulumi.Input[builtins.bool]] = None,
                 use_static_ips: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] base_url: The base URL to fetch
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsHttpAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[builtins.bool] include_headers_in_context: The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        :param pulumi.Input[builtins.bool] insecure: Will ignore certificate errors raised by the client
        :param pulumi.Input[builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_headers_in_context is not None:
            pulumi.set(__self__, "include_headers_in_context", include_headers_in_context)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[builtins.str]:
        """
        The base URL to fetch
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="includeHeadersInContext")
    def include_headers_in_context(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        """
        return pulumi.get(self, "include_headers_in_context")

    @include_headers_in_context.setter
    def include_headers_in_context(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_headers_in_context", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsHttpAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgsDict']]
        basic: NotRequired[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgsDict']]
        bearer_token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsHttpAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[builtins.str]] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs']]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs']]:
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsHttpAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        token: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsHttpAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 token: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsHttpAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        username: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsHttpAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsHubspotArgsDict(TypedDict):
        access_token: pulumi.Input[builtins.str]
        """
        The HubSpot private API access token generated for the Descope service.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        base_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsHubspotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHubspotArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 base_url: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] access_token: The HubSpot private API access token generated for the Descope service.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] base_url: The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "name", name)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[builtins.str]:
        """
        The HubSpot private API access token generated for the Descope service.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsIncodeArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        Your InCode API key.
        """
        api_url: pulumi.Input[builtins.str]
        """
        The base URL of the Incode API
        """
        flow_id: pulumi.Input[builtins.str]
        """
        Your wanted InCode's flow ID.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsIncodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsIncodeArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 api_url: pulumi.Input[builtins.str],
                 flow_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: Your InCode API key.
        :param pulumi.Input[builtins.str] api_url: The base URL of the Incode API
        :param pulumi.Input[builtins.str] flow_id: Your wanted InCode's flow ID.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        Your InCode API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> pulumi.Input[builtins.str]:
        """
        The base URL of the Incode API
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> pulumi.Input[builtins.str]:
        """
        Your wanted InCode's flow ID.
        """
        return pulumi.get(self, "flow_id")

    @flow_id.setter
    def flow_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flow_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsIntercomArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        token: pulumi.Input[builtins.str]
        """
        The Intercom access token.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        Regional Hosting - US, EU, or AU. default: US
        """
elif False:
    ProjectConnectorsIntercomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsIntercomArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 token: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] token: The Intercom access token.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] region: Regional Hosting - US, EU, or AU. default: US
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[builtins.str]:
        """
        The Intercom access token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Regional Hosting - US, EU, or AU. default: US
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ProjectConnectorsLokaliseArgsDict(TypedDict):
        api_token: pulumi.Input[builtins.str]
        """
        Lokalise API token.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[builtins.str]
        """
        Lokalise project ID.
        """
        card_id: NotRequired[pulumi.Input[builtins.str]]
        """
        (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        team_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Lokalise team ID. If not provided, the oldest available team will be used.
        """
        translation_provider: NotRequired[pulumi.Input[builtins.str]]
        """
        The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
elif False:
    ProjectConnectorsLokaliseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsLokaliseArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 project_id: pulumi.Input[builtins.str],
                 card_id: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 team_id: Optional[pulumi.Input[builtins.str]] = None,
                 translation_provider: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_token: Lokalise API token.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] project_id: Lokalise project ID.
        :param pulumi.Input[builtins.str] card_id: (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] team_id: Lokalise team ID. If not provided, the oldest available team will be used.
        :param pulumi.Input[builtins.str] translation_provider: The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if card_id is not None:
            pulumi.set(__self__, "card_id", card_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if translation_provider is not None:
            pulumi.set(__self__, "translation_provider", translation_provider)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[builtins.str]:
        """
        Lokalise API token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[builtins.str]:
        """
        Lokalise project ID.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="cardId")
    def card_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        """
        return pulumi.get(self, "card_id")

    @card_id.setter
    def card_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "card_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Lokalise team ID. If not provided, the oldest available team will be used.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="translationProvider")
    def translation_provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
        return pulumi.get(self, "translation_provider")

    @translation_provider.setter
    def translation_provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "translation_provider", value)


if not MYPY:
    class ProjectConnectorsMparticleArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        The mParticle Server to Server Key generated for the Descope service.
        """
        api_secret: pulumi.Input[builtins.str]
        """
        The mParticle Server to Server Secret generated for the Descope service.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        base_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        """
        default_environment: NotRequired[pulumi.Input[builtins.str]]
        """
        The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsMparticleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsMparticleArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 api_secret: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 base_url: Optional[pulumi.Input[builtins.str]] = None,
                 default_environment: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: The mParticle Server to Server Key generated for the Descope service.
        :param pulumi.Input[builtins.str] api_secret: The mParticle Server to Server Secret generated for the Descope service.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] base_url: The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        :param pulumi.Input[builtins.str] default_environment: The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "name", name)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if default_environment is not None:
            pulumi.set(__self__, "default_environment", default_environment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        The mParticle Server to Server Key generated for the Descope service.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[builtins.str]:
        """
        The mParticle Server to Server Secret generated for the Descope service.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="defaultEnvironment")
    def default_environment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
        """
        return pulumi.get(self, "default_environment")

    @default_environment.setter
    def default_environment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_environment", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsNewrelicArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        Ingest License Key of the account you want to report data to.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        audit_enabled: NotRequired[pulumi.Input[builtins.bool]]
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgsDict']]]]
        data_center: NotRequired[pulumi.Input[builtins.str]]
        """
        The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        logs_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        Specify a custom prefix for all log fields. The default prefix is `descope.`.
        """
        override_logs_prefix: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable this option to use a custom prefix for log fields.
        """
        troubleshoot_log_enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectConnectorsNewrelicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsNewrelicArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 audit_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]]] = None,
                 data_center: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 logs_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 override_logs_prefix: Optional[pulumi.Input[builtins.bool]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: Ingest License Key of the account you want to report data to.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] data_center: The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] logs_prefix: Specify a custom prefix for all log fields. The default prefix is `descope.`.
        :param pulumi.Input[builtins.bool] override_logs_prefix: Enable this option to use a custom prefix for log fields.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if data_center is not None:
            pulumi.set(__self__, "data_center", data_center)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logs_prefix is not None:
            pulumi.set(__self__, "logs_prefix", logs_prefix)
        if override_logs_prefix is not None:
            pulumi.set(__self__, "override_logs_prefix", override_logs_prefix)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        Ingest License Key of the account you want to report data to.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]]]:
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        """
        return pulumi.get(self, "data_center")

    @data_center.setter
    def data_center(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_center", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="logsPrefix")
    def logs_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specify a custom prefix for all log fields. The default prefix is `descope.`.
        """
        return pulumi.get(self, "logs_prefix")

    @logs_prefix.setter
    def logs_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logs_prefix", value)

    @property
    @pulumi.getter(name="overrideLogsPrefix")
    def override_logs_prefix(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable this option to use a custom prefix for log fields.
        """
        return pulumi.get(self, "override_logs_prefix")

    @override_logs_prefix.setter
    def override_logs_prefix(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_logs_prefix", value)

    @property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsNewrelicAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        operator: pulumi.Input[builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    ProjectConnectorsNewrelicAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsNewrelicAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 operator: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsRecaptchaArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[builtins.str]
        """
        The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        """
        site_key: pulumi.Input[builtins.str]
        """
        The site key is used to invoke reCAPTCHA service on your site or mobile application.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsRecaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRecaptchaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 secret_key: pulumi.Input[builtins.str],
                 site_key: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] secret_key: The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        :param pulumi.Input[builtins.str] site_key: The site key is used to invoke reCAPTCHA service on your site or mobile application.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_key", site_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[builtins.str]:
        """
        The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> pulumi.Input[builtins.str]:
        """
        The site key is used to invoke reCAPTCHA service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @site_key.setter
    def site_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "site_key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsRecaptchaEnterpriseArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        API key associated with the current project.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[builtins.str]
        """
        The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        """
        site_key: pulumi.Input[builtins.str]
        """
        The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        """
        assessment_score: NotRequired[pulumi.Input[builtins.float]]
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        enterprise: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.str]]
        override_assessment: NotRequired[pulumi.Input[builtins.bool]]
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
elif False:
    ProjectConnectorsRecaptchaEnterpriseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRecaptchaEnterpriseArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 project_id: pulumi.Input[builtins.str],
                 site_key: pulumi.Input[builtins.str],
                 assessment_score: Optional[pulumi.Input[builtins.float]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 enterprise: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 override_assessment: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: API key associated with the current project.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] project_id: The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        :param pulumi.Input[builtins.str] site_key: The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        :param pulumi.Input[builtins.float] assessment_score: When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.bool] override_assessment: Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "site_key", site_key)
        if assessment_score is not None:
            pulumi.set(__self__, "assessment_score", assessment_score)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enterprise is not None:
            pulumi.set(__self__, "enterprise", enterprise)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_assessment is not None:
            pulumi.set(__self__, "override_assessment", override_assessment)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        API key associated with the current project.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[builtins.str]:
        """
        The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> pulumi.Input[builtins.str]:
        """
        The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @site_key.setter
    def site_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "site_key", value)

    @property
    @pulumi.getter(name="assessmentScore")
    def assessment_score(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        return pulumi.get(self, "assessment_score")

    @assessment_score.setter
    def assessment_score(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "assessment_score", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enterprise(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enterprise")

    @enterprise.setter
    def enterprise(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enterprise", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="overrideAssessment")
    def override_assessment(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        return pulumi.get(self, "override_assessment")

    @override_assessment.setter
    def override_assessment(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_assessment", value)


if not MYPY:
    class ProjectConnectorsRekognitionArgsDict(TypedDict):
        access_key_id: pulumi.Input[builtins.str]
        """
        The AWS access key ID
        """
        collection_id: pulumi.Input[builtins.str]
        """
        The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        secret_access_key: pulumi.Input[builtins.str]
        """
        The AWS secret access key
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsRekognitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRekognitionArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[builtins.str],
                 collection_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 secret_access_key: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_key_id: The AWS access key ID
        :param pulumi.Input[builtins.str] collection_id: The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] secret_access_key: The AWS secret access key
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[builtins.str]:
        """
        The AWS access key ID
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[builtins.str]:
        """
        The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        """
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "collection_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[builtins.str]:
        """
        The AWS secret access key
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSalesforceArgsDict(TypedDict):
        base_url: pulumi.Input[builtins.str]
        """
        The Salesforce API base URL.
        """
        client_id: pulumi.Input[builtins.str]
        """
        The consumer key of the connected app.
        """
        client_secret: pulumi.Input[builtins.str]
        """
        The consumer secret of the connected app.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        version: pulumi.Input[builtins.str]
        """
        REST API Version.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSalesforceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSalesforceArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[builtins.str],
                 client_id: pulumi.Input[builtins.str],
                 client_secret: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 version: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_url: The Salesforce API base URL.
        :param pulumi.Input[builtins.str] client_id: The consumer key of the connected app.
        :param pulumi.Input[builtins.str] client_secret: The consumer secret of the connected app.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] version: REST API Version.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[builtins.str]:
        """
        The Salesforce API base URL.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        """
        The consumer key of the connected app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[builtins.str]:
        """
        The consumer secret of the connected app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        """
        REST API Version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSalesforceMarketingCloudArgsDict(TypedDict):
        client_id: pulumi.Input[builtins.str]
        """
        Client ID issued when you create the API integration in Installed Packages.
        """
        client_secret: pulumi.Input[builtins.str]
        """
        Client secret issued when you create the API integration in Installed Packages.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        subdomain: pulumi.Input[builtins.str]
        """
        The Salesforce Marketing Cloud endpoint subdomain.
        """
        account_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Account identifier, or MID, of the target business unit.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        scope: NotRequired[pulumi.Input[builtins.str]]
        """
        Space-separated list of data-access permissions for your connector.
        """
elif False:
    ProjectConnectorsSalesforceMarketingCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSalesforceMarketingCloudArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[builtins.str],
                 client_secret: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 subdomain: pulumi.Input[builtins.str],
                 account_id: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id: Client ID issued when you create the API integration in Installed Packages.
        :param pulumi.Input[builtins.str] client_secret: Client secret issued when you create the API integration in Installed Packages.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] subdomain: The Salesforce Marketing Cloud endpoint subdomain.
        :param pulumi.Input[builtins.str] account_id: Account identifier, or MID, of the target business unit.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] scope: Space-separated list of data-access permissions for your connector.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        """
        Client ID issued when you create the API integration in Installed Packages.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[builtins.str]:
        """
        Client secret issued when you create the API integration in Installed Packages.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[builtins.str]:
        """
        The Salesforce Marketing Cloud endpoint subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subdomain", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Account identifier, or MID, of the target business unit.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Space-separated list of data-access permissions for your connector.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ProjectConnectorsSeArgsDict(TypedDict):
        access_key_id: pulumi.Input[builtins.str]
        """
        AWS Access key ID.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[builtins.str]
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        secret: pulumi.Input[builtins.str]
        """
        AWS Secret Access Key.
        """
        sender: pulumi.Input['ProjectConnectorsSeSenderArgsDict']
        """
        The sender details that should be displayed in the email message.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSeArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 sender: pulumi.Input['ProjectConnectorsSeSenderArgs'],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_key_id: AWS Access key ID.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] region: AWS region to send requests to (e.g. `us-west-2`).
        :param pulumi.Input[builtins.str] secret: AWS Secret Access Key.
        :param pulumi.Input['ProjectConnectorsSeSenderArgs'] sender: The sender details that should be displayed in the email message.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] endpoint: An optional endpoint URL (hostname only or fully qualified URI).
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "sender", sender)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[builtins.str]:
        """
        AWS Access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def sender(self) -> pulumi.Input['ProjectConnectorsSeSenderArgs']:
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: pulumi.Input['ProjectConnectorsSeSenderArgs']):
        pulumi.set(self, "sender", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSeSenderArgsDict(TypedDict):
        email: pulumi.Input[builtins.str]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSeSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSeSenderArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectConnectorsSegmentArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        write_key: pulumi.Input[builtins.str]
        """
        The Segment Write Key generated for the Descope service.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        The base URL of the Segment API, when using a custom domain in Segment.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSegmentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 write_key: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] write_key: The Segment Write Key generated for the Descope service.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] host: The base URL of the Segment API, when using a custom domain in Segment.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "write_key", write_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="writeKey")
    def write_key(self) -> pulumi.Input[builtins.str]:
        """
        The Segment Write Key generated for the Descope service.
        """
        return pulumi.get(self, "write_key")

    @write_key.setter
    def write_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "write_key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The base URL of the Segment API, when using a custom domain in Segment.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSendgridArgsDict(TypedDict):
        authentication: pulumi.Input['ProjectConnectorsSendgridAuthenticationArgsDict']
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        sender: pulumi.Input['ProjectConnectorsSendgridSenderArgsDict']
        """
        The sender details that should be displayed in the email message.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSendgridArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSendgridArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs'],
                 name: pulumi.Input[builtins.str],
                 sender: pulumi.Input['ProjectConnectorsSendgridSenderArgs'],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsSendgridSenderArgs'] sender: The sender details that should be displayed in the email message.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sender", sender)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs']:
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def sender(self) -> pulumi.Input['ProjectConnectorsSendgridSenderArgs']:
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: pulumi.Input['ProjectConnectorsSendgridSenderArgs']):
        pulumi.set(self, "sender", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSendgridAuthenticationArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsSendgridAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSendgridAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class ProjectConnectorsSendgridSenderArgsDict(TypedDict):
        email: pulumi.Input[builtins.str]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSendgridSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSendgridSenderArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectConnectorsSlackArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        token: pulumi.Input[builtins.str]
        """
        The OAuth token for Slack's Bot User, used to authenticate API requests.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSlackArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 token: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] token: The OAuth token for Slack's Bot User, used to authenticate API requests.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[builtins.str]:
        """
        The OAuth token for Slack's Bot User, used to authenticate API requests.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSmartlingArgsDict(TypedDict):
        account_uid: pulumi.Input[builtins.str]
        """
        The account UID for the Smartling account.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        user_identifier: pulumi.Input[builtins.str]
        """
        The user identifier for the Smartling account.
        """
        user_secret: pulumi.Input[builtins.str]
        """
        The user secret for the Smartling account.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSmartlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmartlingArgs:
    def __init__(__self__, *,
                 account_uid: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 user_identifier: pulumi.Input[builtins.str],
                 user_secret: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] account_uid: The account UID for the Smartling account.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] user_identifier: The user identifier for the Smartling account.
        :param pulumi.Input[builtins.str] user_secret: The user secret for the Smartling account.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_uid", account_uid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user_identifier", user_identifier)
        pulumi.set(__self__, "user_secret", user_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="accountUid")
    def account_uid(self) -> pulumi.Input[builtins.str]:
        """
        The account UID for the Smartling account.
        """
        return pulumi.get(self, "account_uid")

    @account_uid.setter
    def account_uid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "account_uid", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="userIdentifier")
    def user_identifier(self) -> pulumi.Input[builtins.str]:
        """
        The user identifier for the Smartling account.
        """
        return pulumi.get(self, "user_identifier")

    @user_identifier.setter
    def user_identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_identifier", value)

    @property
    @pulumi.getter(name="userSecret")
    def user_secret(self) -> pulumi.Input[builtins.str]:
        """
        The user secret for the Smartling account.
        """
        return pulumi.get(self, "user_secret")

    @user_secret.setter
    def user_secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSmtpArgsDict(TypedDict):
        authentication: pulumi.Input['ProjectConnectorsSmtpAuthenticationArgsDict']
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        sender: pulumi.Input['ProjectConnectorsSmtpSenderArgsDict']
        """
        The sender details that should be displayed in the email message.
        """
        server: pulumi.Input['ProjectConnectorsSmtpServerArgsDict']
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsSmtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs'],
                 name: pulumi.Input[builtins.str],
                 sender: pulumi.Input['ProjectConnectorsSmtpSenderArgs'],
                 server: pulumi.Input['ProjectConnectorsSmtpServerArgs'],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsSmtpSenderArgs'] sender: The sender details that should be displayed in the email message.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sender", sender)
        pulumi.set(__self__, "server", server)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs']:
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def sender(self) -> pulumi.Input['ProjectConnectorsSmtpSenderArgs']:
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: pulumi.Input['ProjectConnectorsSmtpSenderArgs']):
        pulumi.set(self, "sender", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input['ProjectConnectorsSmtpServerArgs']:
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input['ProjectConnectorsSmtpServerArgs']):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsSmtpAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        username: pulumi.Input[builtins.str]
        method: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSmtpAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str],
                 method: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class ProjectConnectorsSmtpSenderArgsDict(TypedDict):
        email: pulumi.Input[builtins.str]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsSmtpSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpSenderArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectConnectorsSmtpServerArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        port: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ProjectConnectorsSmtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 port: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ProjectConnectorsSnArgsDict(TypedDict):
        access_key_id: pulumi.Input[builtins.str]
        """
        AWS Access key ID.
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[builtins.str]
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        secret: pulumi.Input[builtins.str]
        """
        AWS Secret Access Key.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        entity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        organization_number: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        """
        sender_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        """
        template_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
elif False:
    ProjectConnectorsSnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSnArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 entity_id: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 organization_number: Optional[pulumi.Input[builtins.str]] = None,
                 sender_id: Optional[pulumi.Input[builtins.str]] = None,
                 template_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_key_id: AWS Access key ID.
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] region: AWS region to send requests to (e.g. `us-west-2`).
        :param pulumi.Input[builtins.str] secret: AWS Secret Access Key.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.str] endpoint: An optional endpoint URL (hostname only or fully qualified URI).
        :param pulumi.Input[builtins.str] entity_id: The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        :param pulumi.Input[builtins.str] organization_number: An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        :param pulumi.Input[builtins.str] sender_id: The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        :param pulumi.Input[builtins.str] template_id: The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret", secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if organization_number is not None:
            pulumi.set(__self__, "organization_number", organization_number)
        if sender_id is not None:
            pulumi.set(__self__, "sender_id", sender_id)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[builtins.str]:
        """
        AWS Access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="organizationNumber")
    def organization_number(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        """
        return pulumi.get(self, "organization_number")

    @organization_number.setter
    def organization_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "organization_number", value)

    @property
    @pulumi.getter(name="senderId")
    def sender_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        """
        return pulumi.get(self, "sender_id")

    @sender_id.setter
    def sender_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sender_id", value)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class ProjectConnectorsSumologicArgsDict(TypedDict):
        http_source_url: pulumi.Input[builtins.str]
        """
        The URL associated with an HTTP Hosted collector
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        audit_enabled: NotRequired[pulumi.Input[builtins.bool]]
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgsDict']]]]
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        troubleshoot_log_enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectConnectorsSumologicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSumologicArgs:
    def __init__(__self__, *,
                 http_source_url: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 audit_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] http_source_url: The URL associated with an HTTP Hosted collector
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "http_source_url", http_source_url)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @property
    @pulumi.getter(name="httpSourceUrl")
    def http_source_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL associated with an HTTP Hosted collector
        """
        return pulumi.get(self, "http_source_url")

    @http_source_url.setter
    def http_source_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "http_source_url", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]]]:
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsSumologicAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        operator: pulumi.Input[builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    ProjectConnectorsSumologicAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSumologicAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 operator: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsTelesignArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        """
        The unique Telesign API key
        """
        customer_id: pulumi.Input[builtins.str]
        """
        The unique Telesign account Customer ID
        """
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTelesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTelesignArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 customer_id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: The unique Telesign API key
        :param pulumi.Input[builtins.str] customer_id: The unique Telesign account Customer ID
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "customer_id", customer_id)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        """
        The unique Telesign API key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> pulumi.Input[builtins.str]:
        """
        The unique Telesign account Customer ID
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "customer_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTraceableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[builtins.str]
        """
        The Traceable secret key.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        eu_region: NotRequired[pulumi.Input[builtins.bool]]
        """
        EU(Europe) Region deployment of Traceable platform.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTraceableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTraceableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 secret_key: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 eu_region: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] secret_key: The Traceable secret key.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[builtins.bool] eu_region: EU(Europe) Region deployment of Traceable platform.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if eu_region is not None:
            pulumi.set(__self__, "eu_region", eu_region)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[builtins.str]:
        """
        The Traceable secret key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="euRegion")
    def eu_region(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        EU(Europe) Region deployment of Traceable platform.
        """
        return pulumi.get(self, "eu_region")

    @eu_region.setter
    def eu_region(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "eu_region", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreArgsDict(TypedDict):
        account_sid: pulumi.Input[builtins.str]
        authentication: pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgsDict']
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        senders: pulumi.Input['ProjectConnectorsTwilioCoreSendersArgsDict']
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTwilioCoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreArgs:
    def __init__(__self__, *,
                 account_sid: pulumi.Input[builtins.str],
                 authentication: pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs'],
                 name: pulumi.Input[builtins.str],
                 senders: pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs'],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "senders", senders)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "account_sid")

    @account_sid.setter
    def account_sid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "account_sid", value)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs']:
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def senders(self) -> pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs']:
        return pulumi.get(self, "senders")

    @senders.setter
    def senders(self, value: pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs']):
        pulumi.set(self, "senders", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[builtins.str]]
        api_secret: NotRequired[pulumi.Input[builtins.str]]
        auth_token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTwilioCoreAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[builtins.str]] = None,
                 api_secret: Optional[pulumi.Input[builtins.str]] = None,
                 auth_token: Optional[pulumi.Input[builtins.str]] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_token", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreSendersArgsDict(TypedDict):
        sms: pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgsDict']
        voice: NotRequired[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgsDict']]
elif False:
    ProjectConnectorsTwilioCoreSendersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreSendersArgs:
    def __init__(__self__, *,
                 sms: pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs'],
                 voice: Optional[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs']] = None):
        pulumi.set(__self__, "sms", sms)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @property
    @pulumi.getter
    def sms(self) -> pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs']:
        return pulumi.get(self, "sms")

    @sms.setter
    def sms(self, value: pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs']):
        pulumi.set(self, "sms", value)

    @property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs']]:
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs']]):
        pulumi.set(self, "voice", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreSendersSmsArgsDict(TypedDict):
        messaging_service_sid: NotRequired[pulumi.Input[builtins.str]]
        phone_number: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTwilioCoreSendersSmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreSendersSmsArgs:
    def __init__(__self__, *,
                 messaging_service_sid: Optional[pulumi.Input[builtins.str]] = None,
                 phone_number: Optional[pulumi.Input[builtins.str]] = None):
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "messaging_service_sid")

    @messaging_service_sid.setter
    def messaging_service_sid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "messaging_service_sid", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreSendersVoiceArgsDict(TypedDict):
        phone_number: pulumi.Input[builtins.str]
elif False:
    ProjectConnectorsTwilioCoreSendersVoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreSendersVoiceArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ProjectConnectorsTwilioVerifyArgsDict(TypedDict):
        account_sid: pulumi.Input[builtins.str]
        authentication: pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgsDict']
        name: pulumi.Input[builtins.str]
        """
        A custom name for your connector.
        """
        service_sid: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        sender: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTwilioVerifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioVerifyArgs:
    def __init__(__self__, *,
                 account_sid: pulumi.Input[builtins.str],
                 authentication: pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs'],
                 name: pulumi.Input[builtins.str],
                 service_sid: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 sender: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: A custom name for your connector.
        :param pulumi.Input[builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_sid", service_sid)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)

    @property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "account_sid")

    @account_sid.setter
    def account_sid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "account_sid", value)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs']:
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceSid")
    def service_sid(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "service_sid")

    @service_sid.setter
    def service_sid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_sid", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def sender(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sender", value)


if not MYPY:
    class ProjectConnectorsTwilioVerifyAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[builtins.str]]
        api_secret: NotRequired[pulumi.Input[builtins.str]]
        auth_token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectConnectorsTwilioVerifyAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioVerifyAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[builtins.str]] = None,
                 api_secret: Optional[pulumi.Input[builtins.str]] = None,
                 auth_token: Optional[pulumi.Input[builtins.str]] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_token", value)


if not MYPY:
    class ProjectFlowsArgsDict(TypedDict):
        data: pulumi.Input[builtins.str]
elif False:
    ProjectFlowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectFlowsArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data", value)


if not MYPY:
    class ProjectInviteSettingsArgsDict(TypedDict):
        add_magiclink_token: NotRequired[pulumi.Input[builtins.bool]]
        invite_url: NotRequired[pulumi.Input[builtins.str]]
        require_invitation: NotRequired[pulumi.Input[builtins.bool]]
        send_email: NotRequired[pulumi.Input[builtins.bool]]
        send_text: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ProjectInviteSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectInviteSettingsArgs:
    def __init__(__self__, *,
                 add_magiclink_token: Optional[pulumi.Input[builtins.bool]] = None,
                 invite_url: Optional[pulumi.Input[builtins.str]] = None,
                 require_invitation: Optional[pulumi.Input[builtins.bool]] = None,
                 send_email: Optional[pulumi.Input[builtins.bool]] = None,
                 send_text: Optional[pulumi.Input[builtins.bool]] = None):
        if add_magiclink_token is not None:
            pulumi.set(__self__, "add_magiclink_token", add_magiclink_token)
        if invite_url is not None:
            pulumi.set(__self__, "invite_url", invite_url)
        if require_invitation is not None:
            pulumi.set(__self__, "require_invitation", require_invitation)
        if send_email is not None:
            pulumi.set(__self__, "send_email", send_email)
        if send_text is not None:
            pulumi.set(__self__, "send_text", send_text)

    @property
    @pulumi.getter(name="addMagiclinkToken")
    def add_magiclink_token(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "add_magiclink_token")

    @add_magiclink_token.setter
    def add_magiclink_token(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "add_magiclink_token", value)

    @property
    @pulumi.getter(name="inviteUrl")
    def invite_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "invite_url")

    @invite_url.setter
    def invite_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invite_url", value)

    @property
    @pulumi.getter(name="requireInvitation")
    def require_invitation(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "require_invitation")

    @require_invitation.setter
    def require_invitation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_invitation", value)

    @property
    @pulumi.getter(name="sendEmail")
    def send_email(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "send_email")

    @send_email.setter
    def send_email(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "send_email", value)

    @property
    @pulumi.getter(name="sendText")
    def send_text(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "send_text")

    @send_text.setter
    def send_text(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "send_text", value)


if not MYPY:
    class ProjectJwtTemplatesArgsDict(TypedDict):
        access_key_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgsDict']]]]
        """
        A list of `Access Key` type JWT Templates.
        """
        user_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgsDict']]]]
        """
        A list of `User` type JWT Templates.
        """
elif False:
    ProjectJwtTemplatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectJwtTemplatesArgs:
    def __init__(__self__, *,
                 access_key_templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]]] = None,
                 user_templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]] access_key_templates: A list of `Access Key` type JWT Templates.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]] user_templates: A list of `User` type JWT Templates.
        """
        if access_key_templates is not None:
            pulumi.set(__self__, "access_key_templates", access_key_templates)
        if user_templates is not None:
            pulumi.set(__self__, "user_templates", user_templates)

    @property
    @pulumi.getter(name="accessKeyTemplates")
    def access_key_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]]]:
        """
        A list of `Access Key` type JWT Templates.
        """
        return pulumi.get(self, "access_key_templates")

    @access_key_templates.setter
    def access_key_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]]]):
        pulumi.set(self, "access_key_templates", value)

    @property
    @pulumi.getter(name="userTemplates")
    def user_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]]]:
        """
        A list of `User` type JWT Templates.
        """
        return pulumi.get(self, "user_templates")

    @user_templates.setter
    def user_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]]]):
        pulumi.set(self, "user_templates", value)


if not MYPY:
    class ProjectJwtTemplatesAccessKeyTemplateArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the JWT Template.
        """
        template: pulumi.Input[builtins.str]
        auth_schema: NotRequired[pulumi.Input[builtins.str]]
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        conformance_issuer: NotRequired[pulumi.Input[builtins.bool]]
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the JWT Template.
        """
        empty_claim_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        enforce_issuer: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectJwtTemplatesAccessKeyTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectJwtTemplatesAccessKeyTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 template: pulumi.Input[builtins.str],
                 auth_schema: Optional[pulumi.Input[builtins.str]] = None,
                 conformance_issuer: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 empty_claim_policy: Optional[pulumi.Input[builtins.str]] = None,
                 enforce_issuer: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the JWT Template.
        :param pulumi.Input[builtins.str] auth_schema: The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        :param pulumi.Input[builtins.str] description: Description of the JWT Template.
        :param pulumi.Input[builtins.str] empty_claim_policy: Policy for empty claims - `none`, `nil` or `delete`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)
        if auth_schema is not None:
            pulumi.set(__self__, "auth_schema", auth_schema)
        if conformance_issuer is not None:
            pulumi.set(__self__, "conformance_issuer", conformance_issuer)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if empty_claim_policy is not None:
            pulumi.set(__self__, "empty_claim_policy", empty_claim_policy)
        if enforce_issuer is not None:
            pulumi.set(__self__, "enforce_issuer", enforce_issuer)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the JWT Template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="authSchema")
    def auth_schema(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        return pulumi.get(self, "auth_schema")

    @auth_schema.setter
    def auth_schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_schema", value)

    @property
    @pulumi.getter(name="conformanceIssuer")
    def conformance_issuer(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "conformance_issuer")

    @conformance_issuer.setter
    def conformance_issuer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "conformance_issuer", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the JWT Template.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="emptyClaimPolicy")
    def empty_claim_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        return pulumi.get(self, "empty_claim_policy")

    @empty_claim_policy.setter
    def empty_claim_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "empty_claim_policy", value)

    @property
    @pulumi.getter(name="enforceIssuer")
    def enforce_issuer(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enforce_issuer")

    @enforce_issuer.setter
    def enforce_issuer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforce_issuer", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectJwtTemplatesUserTemplateArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the JWT Template.
        """
        template: pulumi.Input[builtins.str]
        auth_schema: NotRequired[pulumi.Input[builtins.str]]
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        conformance_issuer: NotRequired[pulumi.Input[builtins.bool]]
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the JWT Template.
        """
        empty_claim_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        enforce_issuer: NotRequired[pulumi.Input[builtins.bool]]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ProjectJwtTemplatesUserTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectJwtTemplatesUserTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 template: pulumi.Input[builtins.str],
                 auth_schema: Optional[pulumi.Input[builtins.str]] = None,
                 conformance_issuer: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 empty_claim_policy: Optional[pulumi.Input[builtins.str]] = None,
                 enforce_issuer: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the JWT Template.
        :param pulumi.Input[builtins.str] auth_schema: The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        :param pulumi.Input[builtins.str] description: Description of the JWT Template.
        :param pulumi.Input[builtins.str] empty_claim_policy: Policy for empty claims - `none`, `nil` or `delete`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)
        if auth_schema is not None:
            pulumi.set(__self__, "auth_schema", auth_schema)
        if conformance_issuer is not None:
            pulumi.set(__self__, "conformance_issuer", conformance_issuer)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if empty_claim_policy is not None:
            pulumi.set(__self__, "empty_claim_policy", empty_claim_policy)
        if enforce_issuer is not None:
            pulumi.set(__self__, "enforce_issuer", enforce_issuer)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the JWT Template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="authSchema")
    def auth_schema(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        return pulumi.get(self, "auth_schema")

    @auth_schema.setter
    def auth_schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_schema", value)

    @property
    @pulumi.getter(name="conformanceIssuer")
    def conformance_issuer(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "conformance_issuer")

    @conformance_issuer.setter
    def conformance_issuer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "conformance_issuer", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the JWT Template.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="emptyClaimPolicy")
    def empty_claim_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        return pulumi.get(self, "empty_claim_policy")

    @empty_claim_policy.setter
    def empty_claim_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "empty_claim_policy", value)

    @property
    @pulumi.getter(name="enforceIssuer")
    def enforce_issuer(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enforce_issuer")

    @enforce_issuer.setter
    def enforce_issuer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforce_issuer", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectProjectSettingsArgsDict(TypedDict):
        access_key_jwt_template: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the access key JWT Template.
        """
        access_key_session_token_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        """
        app_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL which your application resides on.
        """
        approved_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        """
        cookie_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        Deprecated.
        """
        cookie_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Deprecated.
        """
        custom_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        enable_inactivity: NotRequired[pulumi.Input[builtins.bool]]
        """
        Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        """
        inactivity_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        """
        refresh_token_cookie_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        refresh_token_cookie_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        refresh_token_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        """
        refresh_token_response_method: NotRequired[pulumi.Input[builtins.str]]
        """
        Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        refresh_token_rotation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        """
        session_token_cookie_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        session_token_cookie_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        session_token_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        """
        session_token_response_method: NotRequired[pulumi.Input[builtins.str]]
        """
        Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        step_up_token_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        """
        test_users_loginid_regexp: NotRequired[pulumi.Input[builtins.str]]
        """
        Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        """
        test_users_static_otp: NotRequired[pulumi.Input[builtins.str]]
        """
        A 6 digit static OTP code for use with test users.
        """
        test_users_verifier_regexp: NotRequired[pulumi.Input[builtins.str]]
        """
        The pattern of the verifiers that will be used for testing.
        """
        token_response_method: NotRequired[pulumi.Input[builtins.str]]
        """
        Deprecated.
        """
        trusted_device_token_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The expiry time for the trusted device token. The minimum value is "3 minutes".
        """
        user_jwt_template: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the user JWT Template.
        """
elif False:
    ProjectProjectSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProjectSettingsArgs:
    def __init__(__self__, *,
                 access_key_jwt_template: Optional[pulumi.Input[builtins.str]] = None,
                 access_key_session_token_expiration: Optional[pulumi.Input[builtins.str]] = None,
                 app_url: Optional[pulumi.Input[builtins.str]] = None,
                 approved_domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 cookie_domain: Optional[pulumi.Input[builtins.str]] = None,
                 cookie_policy: Optional[pulumi.Input[builtins.str]] = None,
                 custom_domain: Optional[pulumi.Input[builtins.str]] = None,
                 enable_inactivity: Optional[pulumi.Input[builtins.bool]] = None,
                 inactivity_time: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token_cookie_domain: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token_cookie_policy: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token_expiration: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token_response_method: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token_rotation: Optional[pulumi.Input[builtins.bool]] = None,
                 session_token_cookie_domain: Optional[pulumi.Input[builtins.str]] = None,
                 session_token_cookie_policy: Optional[pulumi.Input[builtins.str]] = None,
                 session_token_expiration: Optional[pulumi.Input[builtins.str]] = None,
                 session_token_response_method: Optional[pulumi.Input[builtins.str]] = None,
                 step_up_token_expiration: Optional[pulumi.Input[builtins.str]] = None,
                 test_users_loginid_regexp: Optional[pulumi.Input[builtins.str]] = None,
                 test_users_static_otp: Optional[pulumi.Input[builtins.str]] = None,
                 test_users_verifier_regexp: Optional[pulumi.Input[builtins.str]] = None,
                 token_response_method: Optional[pulumi.Input[builtins.str]] = None,
                 trusted_device_token_expiration: Optional[pulumi.Input[builtins.str]] = None,
                 user_jwt_template: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_key_jwt_template: Name of the access key JWT Template.
        :param pulumi.Input[builtins.str] access_key_session_token_expiration: The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        :param pulumi.Input[builtins.str] app_url: The URL which your application resides on.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] approved_domains: The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        :param pulumi.Input[builtins.str] cookie_domain: Deprecated.
        :param pulumi.Input[builtins.str] cookie_policy: Deprecated.
        :param pulumi.Input[builtins.str] custom_domain: A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[builtins.bool] enable_inactivity: Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        :param pulumi.Input[builtins.str] inactivity_time: The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        :param pulumi.Input[builtins.str] refresh_token_cookie_domain: The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[builtins.str] refresh_token_cookie_policy: Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[builtins.str] refresh_token_expiration: The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        :param pulumi.Input[builtins.str] refresh_token_response_method: Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        :param pulumi.Input[builtins.bool] refresh_token_rotation: Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        :param pulumi.Input[builtins.str] session_token_cookie_domain: The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[builtins.str] session_token_cookie_policy: Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[builtins.str] session_token_expiration: The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        :param pulumi.Input[builtins.str] session_token_response_method: Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        :param pulumi.Input[builtins.str] step_up_token_expiration: The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        :param pulumi.Input[builtins.str] test_users_loginid_regexp: Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        :param pulumi.Input[builtins.str] test_users_static_otp: A 6 digit static OTP code for use with test users.
        :param pulumi.Input[builtins.str] test_users_verifier_regexp: The pattern of the verifiers that will be used for testing.
        :param pulumi.Input[builtins.str] token_response_method: Deprecated.
        :param pulumi.Input[builtins.str] trusted_device_token_expiration: The expiry time for the trusted device token. The minimum value is "3 minutes".
        :param pulumi.Input[builtins.str] user_jwt_template: Name of the user JWT Template.
        """
        if access_key_jwt_template is not None:
            pulumi.set(__self__, "access_key_jwt_template", access_key_jwt_template)
        if access_key_session_token_expiration is not None:
            pulumi.set(__self__, "access_key_session_token_expiration", access_key_session_token_expiration)
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)
        if cookie_domain is not None:
            warnings.warn("""The cookie_domain attribute has been renamed, set the refresh_token_cookie_domain attribute instead. This attribute will be removed in a future version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""cookie_domain is deprecated: The cookie_domain attribute has been renamed, set the refresh_token_cookie_domain attribute instead. This attribute will be removed in a future version of the provider.""")
        if cookie_domain is not None:
            pulumi.set(__self__, "cookie_domain", cookie_domain)
        if cookie_policy is not None:
            warnings.warn("""The cookie_policy attribute has been renamed, set the refresh_token_cookie_policy attribute instead. This attribute will be removed in a future version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""cookie_policy is deprecated: The cookie_policy attribute has been renamed, set the refresh_token_cookie_policy attribute instead. This attribute will be removed in a future version of the provider.""")
        if cookie_policy is not None:
            pulumi.set(__self__, "cookie_policy", cookie_policy)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if enable_inactivity is not None:
            pulumi.set(__self__, "enable_inactivity", enable_inactivity)
        if inactivity_time is not None:
            pulumi.set(__self__, "inactivity_time", inactivity_time)
        if refresh_token_cookie_domain is not None:
            pulumi.set(__self__, "refresh_token_cookie_domain", refresh_token_cookie_domain)
        if refresh_token_cookie_policy is not None:
            pulumi.set(__self__, "refresh_token_cookie_policy", refresh_token_cookie_policy)
        if refresh_token_expiration is not None:
            pulumi.set(__self__, "refresh_token_expiration", refresh_token_expiration)
        if refresh_token_response_method is not None:
            pulumi.set(__self__, "refresh_token_response_method", refresh_token_response_method)
        if refresh_token_rotation is not None:
            pulumi.set(__self__, "refresh_token_rotation", refresh_token_rotation)
        if session_token_cookie_domain is not None:
            pulumi.set(__self__, "session_token_cookie_domain", session_token_cookie_domain)
        if session_token_cookie_policy is not None:
            pulumi.set(__self__, "session_token_cookie_policy", session_token_cookie_policy)
        if session_token_expiration is not None:
            pulumi.set(__self__, "session_token_expiration", session_token_expiration)
        if session_token_response_method is not None:
            pulumi.set(__self__, "session_token_response_method", session_token_response_method)
        if step_up_token_expiration is not None:
            pulumi.set(__self__, "step_up_token_expiration", step_up_token_expiration)
        if test_users_loginid_regexp is not None:
            pulumi.set(__self__, "test_users_loginid_regexp", test_users_loginid_regexp)
        if test_users_static_otp is not None:
            pulumi.set(__self__, "test_users_static_otp", test_users_static_otp)
        if test_users_verifier_regexp is not None:
            pulumi.set(__self__, "test_users_verifier_regexp", test_users_verifier_regexp)
        if token_response_method is not None:
            warnings.warn("""The token_response_method attribute has been renamed, set the refresh_token_response_method attribute instead. This attribute will be removed in a future version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""token_response_method is deprecated: The token_response_method attribute has been renamed, set the refresh_token_response_method attribute instead. This attribute will be removed in a future version of the provider.""")
        if token_response_method is not None:
            pulumi.set(__self__, "token_response_method", token_response_method)
        if trusted_device_token_expiration is not None:
            pulumi.set(__self__, "trusted_device_token_expiration", trusted_device_token_expiration)
        if user_jwt_template is not None:
            pulumi.set(__self__, "user_jwt_template", user_jwt_template)

    @property
    @pulumi.getter(name="accessKeyJwtTemplate")
    def access_key_jwt_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the access key JWT Template.
        """
        return pulumi.get(self, "access_key_jwt_template")

    @access_key_jwt_template.setter
    def access_key_jwt_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key_jwt_template", value)

    @property
    @pulumi.getter(name="accessKeySessionTokenExpiration")
    def access_key_session_token_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        """
        return pulumi.get(self, "access_key_session_token_expiration")

    @access_key_session_token_expiration.setter
    def access_key_session_token_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key_session_token_expiration", value)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL which your application resides on.
        """
        return pulumi.get(self, "app_url")

    @app_url.setter
    def app_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_url", value)

    @property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        """
        return pulumi.get(self, "approved_domains")

    @approved_domains.setter
    def approved_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "approved_domains", value)

    @property
    @pulumi.getter(name="cookieDomain")
    @_utilities.deprecated("""The cookie_domain attribute has been renamed, set the refresh_token_cookie_domain attribute instead. This attribute will be removed in a future version of the provider.""")
    def cookie_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deprecated.
        """
        return pulumi.get(self, "cookie_domain")

    @cookie_domain.setter
    def cookie_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_domain", value)

    @property
    @pulumi.getter(name="cookiePolicy")
    @_utilities.deprecated("""The cookie_policy attribute has been renamed, set the refresh_token_cookie_policy attribute instead. This attribute will be removed in a future version of the provider.""")
    def cookie_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deprecated.
        """
        return pulumi.get(self, "cookie_policy")

    @cookie_policy.setter
    def cookie_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_policy", value)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "custom_domain")

    @custom_domain.setter
    def custom_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_domain", value)

    @property
    @pulumi.getter(name="enableInactivity")
    def enable_inactivity(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        """
        return pulumi.get(self, "enable_inactivity")

    @enable_inactivity.setter
    def enable_inactivity(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_inactivity", value)

    @property
    @pulumi.getter(name="inactivityTime")
    def inactivity_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        """
        return pulumi.get(self, "inactivity_time")

    @inactivity_time.setter
    def inactivity_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "inactivity_time", value)

    @property
    @pulumi.getter(name="refreshTokenCookieDomain")
    def refresh_token_cookie_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "refresh_token_cookie_domain")

    @refresh_token_cookie_domain.setter
    def refresh_token_cookie_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "refresh_token_cookie_domain", value)

    @property
    @pulumi.getter(name="refreshTokenCookiePolicy")
    def refresh_token_cookie_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "refresh_token_cookie_policy")

    @refresh_token_cookie_policy.setter
    def refresh_token_cookie_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "refresh_token_cookie_policy", value)

    @property
    @pulumi.getter(name="refreshTokenExpiration")
    def refresh_token_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        """
        return pulumi.get(self, "refresh_token_expiration")

    @refresh_token_expiration.setter
    def refresh_token_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "refresh_token_expiration", value)

    @property
    @pulumi.getter(name="refreshTokenResponseMethod")
    def refresh_token_response_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        return pulumi.get(self, "refresh_token_response_method")

    @refresh_token_response_method.setter
    def refresh_token_response_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "refresh_token_response_method", value)

    @property
    @pulumi.getter(name="refreshTokenRotation")
    def refresh_token_rotation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        """
        return pulumi.get(self, "refresh_token_rotation")

    @refresh_token_rotation.setter
    def refresh_token_rotation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "refresh_token_rotation", value)

    @property
    @pulumi.getter(name="sessionTokenCookieDomain")
    def session_token_cookie_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "session_token_cookie_domain")

    @session_token_cookie_domain.setter
    def session_token_cookie_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_token_cookie_domain", value)

    @property
    @pulumi.getter(name="sessionTokenCookiePolicy")
    def session_token_cookie_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "session_token_cookie_policy")

    @session_token_cookie_policy.setter
    def session_token_cookie_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_token_cookie_policy", value)

    @property
    @pulumi.getter(name="sessionTokenExpiration")
    def session_token_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        """
        return pulumi.get(self, "session_token_expiration")

    @session_token_expiration.setter
    def session_token_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_token_expiration", value)

    @property
    @pulumi.getter(name="sessionTokenResponseMethod")
    def session_token_response_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        return pulumi.get(self, "session_token_response_method")

    @session_token_response_method.setter
    def session_token_response_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_token_response_method", value)

    @property
    @pulumi.getter(name="stepUpTokenExpiration")
    def step_up_token_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        """
        return pulumi.get(self, "step_up_token_expiration")

    @step_up_token_expiration.setter
    def step_up_token_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "step_up_token_expiration", value)

    @property
    @pulumi.getter(name="testUsersLoginidRegexp")
    def test_users_loginid_regexp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        """
        return pulumi.get(self, "test_users_loginid_regexp")

    @test_users_loginid_regexp.setter
    def test_users_loginid_regexp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "test_users_loginid_regexp", value)

    @property
    @pulumi.getter(name="testUsersStaticOtp")
    def test_users_static_otp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A 6 digit static OTP code for use with test users.
        """
        return pulumi.get(self, "test_users_static_otp")

    @test_users_static_otp.setter
    def test_users_static_otp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "test_users_static_otp", value)

    @property
    @pulumi.getter(name="testUsersVerifierRegexp")
    def test_users_verifier_regexp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The pattern of the verifiers that will be used for testing.
        """
        return pulumi.get(self, "test_users_verifier_regexp")

    @test_users_verifier_regexp.setter
    def test_users_verifier_regexp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "test_users_verifier_regexp", value)

    @property
    @pulumi.getter(name="tokenResponseMethod")
    @_utilities.deprecated("""The token_response_method attribute has been renamed, set the refresh_token_response_method attribute instead. This attribute will be removed in a future version of the provider.""")
    def token_response_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deprecated.
        """
        return pulumi.get(self, "token_response_method")

    @token_response_method.setter
    def token_response_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_response_method", value)

    @property
    @pulumi.getter(name="trustedDeviceTokenExpiration")
    def trusted_device_token_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expiry time for the trusted device token. The minimum value is "3 minutes".
        """
        return pulumi.get(self, "trusted_device_token_expiration")

    @trusted_device_token_expiration.setter
    def trusted_device_token_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "trusted_device_token_expiration", value)

    @property
    @pulumi.getter(name="userJwtTemplate")
    def user_jwt_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the user JWT Template.
        """
        return pulumi.get(self, "user_jwt_template")

    @user_jwt_template.setter
    def user_jwt_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_jwt_template", value)


if not MYPY:
    class ProjectStylesArgsDict(TypedDict):
        data: pulumi.Input[builtins.str]
elif False:
    ProjectStylesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectStylesArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data", value)


