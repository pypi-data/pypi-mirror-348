from typing import Any, TYPE_CHECKING, Union, Optional

from pydantic import ValidationError

from soar_sdk.input_spec import InputSpecification
from soar_sdk.shims.phantom.action_result import ActionResult as PhantomActionResult
from soar_sdk.shims.phantom.base_connector import BaseConnector

from .abstract import SOARClient

if TYPE_CHECKING:
    from .actions_provider import ActionsProvider


_INGEST_STATE_KEY = "ingestion_state"
_AUTH_STATE_KEY = "auth_state"
_CACHE_STATE_KEY = "asset_cache"


class AppConnector(BaseConnector, SOARClient):
    """
    The connector mainly generated by the App Wizard. It is extended to properly work
    with handlers provided by the app.

    Serves as the layer for exposing public BaseConnector API interface, so that App
    is no longer calling phantom library directly.

    In the future it should be replaced by another class accessing SOAR API.
    """

    def __init__(self, actions_provider: "ActionsProvider") -> None:
        # Call the BaseConnectors init first
        super().__init__()

        self.actions_provider = actions_provider

        self.ingestion_state: dict = {}
        self.auth_state: dict = {}
        self.asset_cache: dict = {}

    @classmethod
    def get_soar_base_url(cls) -> str:
        return cls._get_phantom_base_url()

    def set_csrf_info(self, token: str, referer: str) -> None:
        """Public method for setting the CSRF token in connector."""
        self._set_csrf_info(token, referer)

    def handle(
        self, input_data: InputSpecification, handle: Optional[int] = None
    ) -> str:
        """Public method for executing an action from a JSON string."""
        self.print_progress_message = True
        return self._handle_action(input_data.json(), handle or 0)

    def handle_action(self, param: dict[str, Any]) -> None:
        # Get the action that we are supposed to execute for this App Run
        action_id = self.get_action_identifier()
        self.debug_print("action_id", action_id)

        if handler := self.actions_provider.get_action(action_id):
            try:
                params = handler.meta.parameters.parse_obj(param)
            except (ValueError, ValidationError):
                # FIXME: Consider adding more details to this error, but be aware
                #  of possible PIIs.
                self.save_progress(
                    "Validation Error - the params data for action could not be parsed"
                )
                return

            handler(params)

        else:
            raise RuntimeError(f"Action {action_id} not found.")

    def initialize(self) -> bool:
        # Load the state in initialize, use it to store data
        # that needs to be accessed across actions
        state = self.load_state() or {}
        self.ingestion_state = state.get(_INGEST_STATE_KEY, {})
        self.auth_state = state.get(_AUTH_STATE_KEY, {})
        self.asset_cache = state.get(_CACHE_STATE_KEY, {})

        return True

    def finalize(self) -> bool:
        state = {
            _INGEST_STATE_KEY: self.ingestion_state,
            _AUTH_STATE_KEY: self.auth_state,
            _CACHE_STATE_KEY: self.asset_cache,
        }
        self.save_state(state)
        return True

    def add_result(self, action_result: PhantomActionResult) -> PhantomActionResult:
        return self.add_action_result(action_result)

    def get_results(self) -> list[PhantomActionResult]:
        return self.get_action_results()

    def debug(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.debug_print(tag, dump_object)

    def error(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.error_print(tag, dump_object)

    def add_exception(self, exception: Exception) -> None:
        self._BaseConnector__conn_result.add_exception(exception)
