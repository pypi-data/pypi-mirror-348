"""Module defining the IRVB Camera class."""

from __future__ import annotations

from typing import Any

import numpy as np
from numpy import ndarray
from raysect.core import Node, Primitive
from raysect.core.math import AffineMatrix3D, Point3D, Vector3D
from raysect.optical import Ray
from raysect.optical.material import AbsorbingSurface, NullMaterial
from raysect.optical.observer import TargettedCCDArray
from raysect.primitive import Box

from cherab.tools.observers import BolometerFoil, BolometerSlit

try:
    import plotly.graph_objects as go
except ImportError:
    print("Plotly is required if using IRVB model plotting functionality.")

__all__ = ["IRVBCamera"]


XAXIS = Vector3D(1, 0, 0)
YAXIS = Vector3D(0, 1, 0)
ZAXIS = Vector3D(0, 0, 1)
ORIGIN = Point3D(0, 0, 0)


class IRVBCamera(Node):
    """InfraRed imaging Video Bolometer class.

    This instance stands for IRVB camera comprised of slit and foil instances.
    A slit and foil are generated by :obj:`~cherab.tools.observers.bolometry.BolometerSlit` and
    :obj:`~raysect.optical.observer.imaging.targetted_ccd.TargettedCCDArray` classes, respectively.

    Parameters
    ----------
    camera_geometry : :obj:`~raysect.core.scenegraph.primitive.Primitive`
        A Raysect primitive to supply as the box/aperture geometry.
    parent : :obj:`~raysect.core.scenegraph.node.Node`
        The parent node of this camera in the scenegraph, often an optical World object.
    transform : :obj:`~raysect.core.math.affinematrix.AffineMatrix3D`
        The relative coordinate transform of this bolometer camera relative to the parent.
    name : str, optional
        IRVB name.

    Examples
    --------
    >>> from raysect.optical import World
    >>> from cherab.lhd.observer import IRVBCamera
    >>>
    >>> world = World()
    >>> camera = IRVBCamera(name="MyBolometer", parent=world)
    """

    def __init__(
        self,
        camera_geometry: Primitive | None = None,
        parent: Node | None = None,
        transform: AffineMatrix3D | None = None,
        name: str = "",
    ) -> None:
        super().__init__(parent=parent, transform=transform, name=name)

        self._foil_detector: TargettedCCDArray | None = None
        self._slit: BolometerSlit | None = None

        if camera_geometry is not None:
            if not isinstance(camera_geometry, Primitive):
                raise TypeError("camera_geometry must be a primitive")
            camera_geometry.parent = self
        self._camera_geometry = camera_geometry

    def __repr__(self) -> str:
        return f"IRVBCamera(name={self.name})"

    @property
    def slit(self) -> BolometerSlit:
        """BolometerSlit instances."""
        return self._slit

    @slit.setter
    def slit(self, value: BolometerSlit):
        if not isinstance(value, BolometerSlit):
            raise TypeError("The slit attribute must be a BolometerSlit instance.")

        if value.parent != self:
            value.parent = self

        self._slit = value

    @property
    def foil_detector(self) -> TargettedCCDArray:
        """A TargettedCCDArray instance."""
        return self._foil_detector

    @foil_detector.setter
    def foil_detector(self, value: TargettedCCDArray):
        if not isinstance(value, TargettedCCDArray):
            raise TypeError("The foil_detector attribute must be a TargettedCCDArray instance.")

        if value.parent != self:
            value.parent = self

        self._foil_detector = value

    @property
    def pixels_as_foils(self) -> ndarray:
        """Regard each pixel as a bolometer foil.

        The element is a `BolometerFoil` instance.

        Returns
        -------
        `~numpy.ndarray`
            Array of `BolometerFoil` object instances.

        Examples
        --------
        >>> from cherab.lhd.observer.boloneter import load_irvb
        >>> irvb = load_irvb()
        >>> irvb.pixels_as_foils
        array([[<BolometerFoil - IRVB pixel (1,1)>,
                <BolometerFoil - IRVB pixel (1,2)>,
                ...
                <BolometerFoil - IRVB pixel (26,20)>]], dtype=object)
        """
        nx, ny = self.foil_detector.pixels
        width = self.foil_detector.width
        pixel_pitch = width / nx
        height = pixel_pitch * ny

        # Foil pixels are defined in the foil's local coordinate system
        foil_upper_right = Point3D(width * 0.5, height * 0.5, 0)
        pixels_array = np.empty((nx, ny), dtype="object")
        for x, y in np.ndindex(nx, ny):
            pixel_centre = (
                foil_upper_right - (x + 0.5) * XAXIS * pixel_pitch - (y + 0.5) * YAXIS * pixel_pitch
            )
            pixel = BolometerFoil(
                detector_id="IRVB pixel ({},{})".format(x + 1, y + 1),
                centre_point=pixel_centre,
                basis_x=XAXIS,
                basis_y=YAXIS,
                dx=pixel_pitch,
                dy=pixel_pitch,
                slit=self._slit,
                accumulate=False,
                parent=self.foil_detector,
            )
            pixels_array[x, y] = pixel
        return pixels_array

    @property
    def sightline_rays(self) -> ndarray:
        """Array containing sightline rays `~raysect.optical.Ray`.

        Each ray starts from the centre of corresponding pixel and passes through the centre of the
        slit.
        """
        return np.asarray(
            [
                [
                    Ray(
                        pixel.centre_point,
                        pixel.centre_point.vector_to(self._slit.centre_point),
                    )
                    for pixel in pixel_column
                ]
                for pixel_column in self.pixels_as_foils
            ],
            dtype="object",
        )

    def observe(self) -> None:
        """Take an observation with this camera.

        Call `observe()` on a foil detector
        :obj:`~raysect.optical.observer.imaging.TargettedCCDArray.observe` method.
        """

        self.foil_detector.observe()

    def plot_bolometer_geometry(
        self,
        fig: go.Figure | None = None,
        plot_pixel_rays: dict[str, Any] | None = None,
        show_foil_xy_axes: bool = True,
    ):
        """3D plotting of bolometer geometry using plotly module If you want to
        use this method, must install `Plotly <https://plotly.com/python/>`_
        module.

        Parameters
        ----------
        fig : `~plotly.graph_objs.Figure`, optional
            Figure object created by plotly, by default `plotly.graph_objs.Figure` if fig is None.
        plot_pixel_rays : dict, optional
            Properties of plotting rays, by default None.
            If the user want to use it, set any key and value, by default
            ``{"pixel": (0, 0), "num_rays": 50, "terminate": 30e-2}`` is applied.
            ``"pixel"`` is the specific pixel where rays are triggered, ``"num_rays"`` is the number
            of rays triggered, and ``"terminate"`` is the distance between foil and the board which
            terminates triggered rays in units of meter. If ``"terminate`` is 0, no terminating
            board is set.
        show_foil_xy_axes : bool, optional
            Whether or not to show the local foil x, y axis, by default True.

        Returns
        -------
        `~plotly.graph_objs.Figure`
            Figure objects include some traces.
        """

        try:
            import plotly.graph_objects as go
        except ImportError:
            print("must install plotly module.")
            return

        if fig is not None:
            if not isinstance(fig, go.Figure):
                raise TypeError("The fig argument must be of type plotly.graph_objs.Figure")
        else:
            fig = go.Figure()

        # target slit
        corners = [
            self.slit.centre_point
            - 0.5 * (+self.slit.dx * self.slit.basis_x + self.slit.dy * self.slit.basis_y),
            self.slit.centre_point
            - 0.5 * (-self.slit.dx * self.slit.basis_x + self.slit.dy * self.slit.basis_y),
            self.slit.centre_point
            - 0.5 * (-self.slit.dx * self.slit.basis_x - self.slit.dy * self.slit.basis_y),
            self.slit.centre_point
            - 0.5 * (+self.slit.dx * self.slit.basis_x - self.slit.dy * self.slit.basis_y),
        ]
        corners = np.array([[*point] for point in corners])
        fig.add_trace(
            go.Mesh3d(x=corners[:, 0], y=corners[:, 1], z=corners[:, 2], opacity=0.6, text="slit")
        )

        # foil screen
        foil_centre_point = ORIGIN.transform(self.foil_detector.to_root())
        basis_x = XAXIS.transform(self.foil_detector.to_root())
        basis_y = YAXIS.transform(self.foil_detector.to_root())
        width = self.foil_detector.width
        pixel_pitch = self.foil_detector.width / self.foil_detector.pixels[0]
        height = pixel_pitch * self.foil_detector.pixels[1]

        corners = [
            foil_centre_point - 0.5 * (+width * basis_x + height * basis_y),
            foil_centre_point - 0.5 * (-width * basis_x + height * basis_y),
            foil_centre_point - 0.5 * (-width * basis_x - height * basis_y),
            foil_centre_point - 0.5 * (+width * basis_x - height * basis_y),
        ]
        corners = np.array([[*point] for point in corners])
        fig.add_trace(
            go.Mesh3d(x=corners[:, 0], y=corners[:, 1], z=corners[:, 2], opacity=0.6, text="foil")
        )

        # camera box
        xaxis = XAXIS.transform(self.to_root())
        yaxis = YAXIS.transform(self.to_root())
        zaxis = ZAXIS.transform(self.to_root())
        inner_box = self._camera_geometry.primitive_a.primitive_b
        lower = inner_box.lower.transform(self.to_root())
        upper = inner_box.upper.transform(self.to_root())
        lower_to_upper = lower.vector_to(upper)
        box_width = abs(lower_to_upper.dot(xaxis))
        box_height = abs(lower_to_upper.dot(yaxis))
        box_depth = abs(lower_to_upper.dot(zaxis))
        vertices = [
            lower,
            lower + box_width * xaxis,
            lower + box_width * xaxis + box_height * yaxis,
            lower + box_height * yaxis,
            lower + box_depth * zaxis,
            lower + box_depth * zaxis + box_width * xaxis,
            upper,
            upper - box_width * xaxis,
        ]
        vertices = np.array([[*vertex] for vertex in vertices])

        fig.add_trace(
            go.Mesh3d(
                x=vertices[:, 0],
                y=vertices[:, 1],
                z=vertices[:, 2],
                i=[7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2],
                j=[3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3],
                k=[0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6],
                opacity=0.2,
                color="#7d7d7d",
                flatshading=True,
            )
        )

        # plot rays
        if plot_pixel_rays:
            # set default properties
            plot_pixel_rays.setdefault("pixel", (0, 0))  # select specific pixel number
            plot_pixel_rays.setdefault("num_rays", 50)  # number of rays triggered
            plot_pixel_rays.setdefault("terminate", 30e-2)  # terminating board in front of the foil

            # color a specified pixel plane
            pixel = plot_pixel_rays["pixel"]
            UpperRight = Point3D(
                width * 0.5 - pixel[0] * pixel_pitch, height * 0.5 - pixel[1] * pixel_pitch, 0
            )
            points = [
                Point3D(*UpperRight).transform(self.foil_detector.to_root()),
                Point3D(UpperRight.x - pixel_pitch, UpperRight.y, UpperRight.z).transform(
                    self.foil_detector.to_root()
                ),
                Point3D(
                    UpperRight.x - pixel_pitch, UpperRight.y - pixel_pitch, UpperRight.z
                ).transform(self.foil_detector.to_root()),
                Point3D(UpperRight.x, UpperRight.y - pixel_pitch, UpperRight.z).transform(
                    self.foil_detector.to_root()
                ),
            ]

            corners = np.array([[*point] for point in points])
            fig.add_trace(
                go.Mesh3d(
                    x=corners[:, 0],
                    y=corners[:, 1],
                    z=corners[:, 2],
                    opacity=0.6,
                    text="selected pixel",
                    color="#7fff00",
                )
            )

            # set ray terminated board
            if plot_pixel_rays["terminate"] > 0:
                terminate_board = Box(
                    lower=Point3D(-1e9, -1e9, plot_pixel_rays["terminate"]),
                    upper=Point3D(1e9, 1e9, plot_pixel_rays["terminate"] + 1.0),
                    parent=self.parent,
                    name="terminating_board",
                )
                terminate_board.material = AbsorbingSurface()
                terminate_board.transform = self.foil_detector.to_root()

            # ray tracing
            ray_temp = Ray()
            rays = self.foil_detector._generate_rays(
                pixel[0], pixel[1], ray_temp, plot_pixel_rays["num_rays"]
            )
            for ray in rays:
                origin = ray[0].origin.transform(self.foil_detector.to_root())
                origin_0 = origin.copy()
                direction = ray[0].direction.transform(self.foil_detector.to_root())

                while True:
                    # Find the next intersection point
                    intersection = self.parent.hit(Ray(origin, direction))

                    if intersection is None:
                        raise RuntimeError("No material intersection was found for this sightline.")

                    elif isinstance(intersection.primitive.material, NullMaterial):
                        # apply a small displacement to avoid infinite self collisions due to numerics
                        hit_point = intersection.hit_point.transform(
                            intersection.primitive_to_world
                        )
                        ray_displacement = pixel_pitch / 100
                        origin = hit_point + direction * ray_displacement
                        continue
                    else:
                        hit_point = intersection.hit_point.transform(
                            intersection.primitive_to_world
                        )
                        break

                # TODO: remove terminating board
                # self.parent.children.pop(-1)

                line = np.array([[*origin_0], [*hit_point]])

                fig.add_trace(
                    go.Scatter3d(
                        mode="lines",
                        x=line[:, 0],
                        y=line[:, 1],
                        z=line[:, 2],
                        line=dict(color="#FF0033", width=2),
                        text="sampled_ray",
                        showlegend=False,
                    )
                )

        # axis vector
        if show_foil_xy_axes:
            # slit_sensor_separation = abs(
            #     foil_centre_point.vector_to(self.slit.centre_point).dot(zaxis)
            # )
            xaxis_vector = go.Scatter3d(
                x=[foil_centre_point.x, foil_centre_point.x + width * basis_x.x],
                y=[foil_centre_point.y, foil_centre_point.y + width * basis_x.y],
                z=[foil_centre_point.z, foil_centre_point.z + width * basis_x.z],
                marker=dict(color="rgb(256, 0, 0)", size=2),
                line=dict(color="rgb(256, 0, 0)"),
                showlegend=False,
            )
            yaxis_vector = go.Scatter3d(
                x=[foil_centre_point.x, foil_centre_point.x + height * basis_y.x],
                y=[foil_centre_point.y, foil_centre_point.y + height * basis_y.y],
                z=[foil_centre_point.z, foil_centre_point.z + height * basis_y.z],
                marker=dict(color="rgb(0, 256, 0)", size=2),
                line=dict(color="rgb(0, 256, 0)"),
                showlegend=False,
            )
            fig.add_trace(xaxis_vector)
            fig.add_trace(yaxis_vector)

        # figure update
        fig.update_layout(
            width=500,
            height=500,
            scene_aspectmode="data",
            margin=dict(r=10, l=10, b=10, t=10),
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
        )
        return fig
