Ответы на теоретические вопросы по ПМ.01
1. Порождающие паттерны проектирования
Порождающие паттерны проектирования отвечают за удобное и безопасное создание новых объектов или групп объектов. Основные из них: - Фабричный метод - определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта. - Абстрактная фабрика - предоставляет интерфейс для создания семейств взаимосвязанных объектов. - Строитель (Builder) - разделяет конструирование сложного объекта и его представление. - Прототип - создает новые объекты путем копирования существующих. - Одиночка (Singleton) - гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.
2. Оценка сложности алгоритма
Оценка сложности алгоритма определяет, как растет время выполнения алгоритма с увеличением размера входных данных. Основные обозначения: - O(1) - константное время (не зависит от размера входных данных) - O(log n) - логарифмическая сложность - O(n) - линейная сложность - O(n log n) - линейно-логарифмическая сложность - O(n²) - квадратичная сложность - O(2ⁿ) - экспоненциальная сложность
Оценивается: - Временная сложность - время выполнения - Пространственная сложность - объем используемой памяти
3. Особенности организации взаимодействия низкоуровневого системного ПО с памятью: Режимы адресации
Режимы адресации - способы доступа к операндам в памяти: - Прямая адресация - операнд находится непосредственно по указанному адресу - Непрямая адресация - операнд находится по адресу, который хранится по указанному адресу - Относительная адресация - адрес операнда вычисляется относительно текущего значения счетчика команд - Индексная адресация - адрес операнда вычисляется как сумма базового адреса и содержимого индексного регистра - Регистровая адресация - операнд находится в регистре процессора - Непосредственная адресация - операнд содержится непосредственно в инструкции
4. Виды ошибок
•	Синтаксические ошибки - нарушения правил языка программирования
•	Семантические ошибки - логические ошибки, которые не нарушают синтаксис
•	Ошибки времени выполнения - возникают во время работы программы (деление на ноль, выход за границы массива)
•	Логические ошибки - программа работает, но результат не соответствует ожиданиям
•	Ошибки совместимости - возникают при взаимодействии с другими системами
•	Ошибки производительности - неэффективное использование ресурсов
•	Утечки памяти - неосвобождение выделенной памяти
5. Паттерны поведения
Паттерны поведения определяют способы взаимодействия между объектами. Основные из них: - Цепочка обязанностей - позволяет передавать запросы по цепочке обработчиков - Команда - инкапсулирует запрос как объект - Интерпретатор - определяет грамматику языка и интерпретатор для него - Итератор - предоставляет последовательный доступ к элементам коллекции - Посредник - определяет объект, инкапсулирующий взаимодействие множества объектов - Наблюдатель - определяет зависимость один-ко-многим между объектами - Состояние - позволяет объекту изменять свое поведение при изменении внутреннего состояния - Стратегия - определяет семейство алгоритмов и делает их взаимозаменяемыми - Шаблонный метод - определяет скелет алгоритма, оставляя некоторые шаги на усмотрение подклассов - Посетитель - позволяет добавлять новые операции к объектам без изменения их классов
6. Уровни тестирования
•	Модульное (Unit) тестирование - проверка отдельных компонентов программы
•	Интеграционное тестирование - проверка взаимодействия между компонентами
•	Системное тестирование - проверка всей системы на соответствие требованиям
•	Приемочное тестирование - проверка системы на соответствие бизнес-требованиям и готовность к выпуску
•	Альфа-тестирование - внутреннее тестирование перед выпуском
•	Бета-тестирование - внешнее тестирование перед выпуском
•	Регрессионное тестирование - проверка, что новые изменения не повредили существующую функциональность
7. Декораторы
Декораторы в программировании: 1. Как паттерн проектирования - позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные “обертки”. 2. В Python - специальный синтаксис (@decorator), позволяющий модифицировать функции или классы: - Изменять поведение функций - Добавлять функциональность (логирование, кэширование) - Проверять аргументы - Измерять производительность
Пример:
@timer
def slow_function():
    # функция будет измерять время своего выполнения
    pass
8. Структура проекта Android-приложения
•	AndroidManifest.xml - основной конфигурационный файл
•	res/ - ресурсы приложения:
–	drawable/ - изображения
–	layout/ - макеты интерфейса
–	values/ - строки, цвета, стили
–	mipmap/ - иконки приложения
•	java/ - исходный код на Java/Kotlin
•	build.gradle - файлы конфигурации сборки
•	assets/ - дополнительные файлы ресурсов
Основные компоненты: - Activity - экран приложения - Fragment - часть пользовательского интерфейса - Service - фоновые процессы - ContentProvider - управление доступом к данным - BroadcastReceiver - обработка системных событий
9. Архитектура системных программ
Архитектура системных программ включает: - Ядро операционной системы - управление ресурсами, планирование процессов - Драйверы устройств - взаимодействие с аппаратными компонентами - Файловая система - организация хранения данных - Подсистема ввода-вывода - обработка потоков данных - Подсистема управления памятью - распределение и защита памяти - Сетевой стек - протоколы и интерфейсы для сетевого взаимодействия
Основные принципы: - Модульность - Абстракция аппаратуры - Уровни привилегий - Минимизация зависимостей - Оптимизация производительности
10. Стратегии проектирования тестовых наборов данных
•	Эквивалентное разбиение - деление входных данных на классы, где программа должна работать одинаково
•	Анализ граничных значений - тестирование на границах допустимых значений
•	Попарное тестирование (Pairwise) - тестирование всех возможных пар значений параметров
•	Тестирование на основе путей - проверка всех возможных путей выполнения
•	Тестирование на основе состояний - проверка всех возможных состояний программы
•	Случайное тестирование - генерация случайных тестовых данных
•	Мутационное тестирование - внесение мелких изменений в код для проверки обнаружения ошибок
11. ООП: Наследование
Наследование - механизм, позволяющий создавать новые классы на основе существующих.
Особенности: - Дочерний класс наследует атрибуты и методы родительского класса - Возможность переопределения методов родительского класса - Расширение функциональности базового класса - Повторное использование кода
Типы наследования: - Одиночное - наследование от одного класса - Множественное - наследование от нескольких классов (поддерживается не во всех языках) - Многоуровневое - класс наследуется от класса, который наследуется от другого класса - Иерархическое - несколько классов наследуются от одного базового класса
12. Ошибки. Виды ошибок. Стратегии работы с ошибками
Виды ошибок: - Синтаксические - Логические - Времени выполнения
Стратегии обработки: - Обработка исключений - try/catch/finally - Коды возврата и проверка ошибок - функции возвращают коды ошибок - Логирование - запись информации об ошибках - Защитное программирование - проверка входных данных - Повторные попытки - при временных ошибках - Откат изменений - возврат к предыдущему состоянию - Пользовательские уведомления - информирование пользователя
13. Автоматизация разработки технической документации
Инструменты и подходы: - Генераторы документации из кода (Javadoc, Doxygen, Sphinx) - Системы управления документацией (Confluence, GitBook) - Маркдаун и другие языки разметки - Инструменты для создания диаграмм (PlantUML, Mermaid) - Автоматическая генерация API-документации (Swagger, Postman) - Системы непрерывной интеграции для автоматического обновления документации - Шаблоны документов для стандартизации
14. Обмен данными через именованные каналы
Именованные каналы (Named Pipes) - механизм межпроцессного взаимодействия, позволяющий процессам обмениваться данными: - Представляют собой файловые объекты в файловой системе - Обеспечивают двунаправленную связь между процессами - Могут использоваться для взаимодействия между процессами на разных компьютерах - Поддерживают передачу данных в виде потока байтов - Работают по принципу FIFO (First In, First Out)
Применение: - Клиент-серверное взаимодействие - Передача данных между компонентами приложения - Обмен сообщениями между службами
15. Жизненный цикл активностей мобильного приложения
Основные этапы жизненного цикла активности в Android: - onCreate() - создание активности и инициализация UI - onStart() - активность становится видимой для пользователя - onResume() - активность переходит на передний план и может взаимодействовать с пользователем - onPause() - другая активность становится активной, текущая теряет фокус - onStop() - активность становится невидимой для пользователя - onRestart() - вызывается после onStop() перед повторным показом активности - onDestroy() - активность уничтожается
Переходы между состояниями могут быть вызваны действиями пользователя или системными событиями.
16. Понятие и разница между терминами «ошибка», «дефект», «сбой»
•	Ошибка (Error) - действие человека, которое приводит к неправильному результату (ошибка разработчика при написании кода)
•	Дефект (Defect/Bug) - недостаток в программе, который может привести к неправильной работе (результат ошибки)
•	Сбой (Failure) - неспособность системы выполнить требуемую функцию в определенных условиях (внешнее проявление дефекта)
Цепочка: ошибка разработчика → дефект в коде → сбой при работе программы.
17. Контейнеры компоновки макетов: ConstraintLayout
ConstraintLayout - современный и гибкий контейнер компоновки для Android: - Позволяет создавать сложные макеты без вложенности элементов - Основан на ограничениях (constraints), определяющих положение элементов относительно друг друга и родителя - Улучшает производительность за счет плоской иерархии представлений - Поддерживает процентные ограничения и цепочки элементов - Имеет визуальный редактор в Android Studio
Основные типы ограничений: - Относительное позиционирование - Отступы - Выравнивание - Размеры (фиксированные, wrap_content, match_constraint) - Барьеры и направляющие
18. Примитивы синхронизации: Мьютексы
Мьютекс (Mutual Exclusion) - примитив синхронизации, обеспечивающий монопольный доступ к ресурсу: - Предотвращает одновременный доступ к общему ресурсу - Имеет два состояния: заблокирован (locked) и разблокирован (unlocked) - Поток, захвативший мьютекс, должен освободить его после использования ресурса - Если мьютекс заблокирован, другие потоки ожидают его освобождения - Помогает избежать состояния гонки (race condition)
Отличия от семафоров: - Мьютекс может быть освобожден только захватившим его потоком - Мьютекс имеет только два состояния (0/1), а семафор может иметь несколько разрешений
19. Алгоритмы на графах
Основные алгоритмы на графах: - Поиск в ширину (BFS) - обход графа по уровням (используется для поиска кратчайшего пути в невзвешенном графе) - Поиск в глубину (DFS) - обход графа с углублением в ветки (используется для топологической сортировки) - Алгоритм Дейкстры - поиск кратчайшего пути во взвешенном графе с неотрицательными весами - Алгоритм Беллмана-Форда - поиск кратчайшего пути во взвешенном графе (работает с отрицательными весами) - Алгоритм Флойда-Уоршелла - поиск кратчайших путей между всеми парами вершин - Алгоритм Крускала - построение минимального остовного дерева - Алгоритм Прима - построение минимального остовного дерева - Алгоритм Форда-Фалкерсона - нахождение максимального потока в сети
20. Парадигма “Разделяй и властвуй”
“Разделяй и властвуй” (Divide and Conquer) - алгоритмическая парадигма, состоящая из трех этапов: 1. Разделение - задача разбивается на несколько подзадач меньшего размера 2. Решение - подзадачи решаются рекурсивно 3. Комбинирование - решения подзадач объединяются для получения ответа на исходную задачу
Примеры алгоритмов: - Быстрая сортировка (QuickSort) - Сортировка слиянием (MergeSort) - Алгоритм Карацубы (быстрое умножение больших чисел) - Быстрое преобразование Фурье (FFT) - Двоичный поиск
Преимущества: - Эффективность для многих задач - Естественное распараллеливание - Простота понимания и реализации
21. Дескрипторы и псевдодескрипторы
Дескриптор - абстрактное целочисленное представление ресурса операционной системы: - Файловые дескрипторы - представляют открытые файлы - Дескрипторы сокетов - представляют сетевые соединения - Дескрипторы процессов - идентифицируют процессы - Дескрипторы окон - идентифицируют окна в графическом интерфейсе
Псевдодескрипторы - специальные значения, которые выглядят как дескрипторы, но не являются прямыми ссылками на ресурсы: - STDIN (0), STDOUT (1), STDERR (2) - стандартные потоки ввода/вывода - Псевдодескрипторы в Win32 API (например, GetCurrentProcess()) - Псевдодескрипторы в графических подсистемах
22. ООП: Инкапсуляция
Инкапсуляция - один из основных принципов ООП, заключающийся в скрытии внутренней реализации объекта и защите его данных: - Объединение данных и методов, работающих с этими данными, в одну единицу (класс) - Сокрытие внутреннего состояния объекта от внешнего мира - Доступ к данным осуществляется только через специальные методы (геттеры/сеттеры) - Реализуется с помощью модификаторов доступа (private, protected, public)
Преимущества: - Контроль доступа к данным - Защита от неправильного использования - Возможность изменения внутренней реализации без изменения внешнего интерфейса - Уменьшение связанности между компонентами системы
23. ООП: Классы и объекты
Класс - шаблон/чертеж для создания объектов, определяющий их свойства и поведение: - Содержит атрибуты (переменные) и методы (функции) - Определяет структуру данных и алгоритмы - Может наследоваться от других классов
Объект - экземпляр класса, конкретная реализация шаблона: - Имеет состояние (значения атрибутов) - Имеет поведение (реализация методов) - Имеет уникальную идентичность
Взаимосвязь: - Класс - абстрактное понятие, объект - конкретная реализация - От одного класса можно создать множество объектов - Объекты одного класса имеют одинаковую структуру, но разные данные
24. Методы отладки
Основные методы отладки программного обеспечения: - Пошаговое выполнение - выполнение программы по одной инструкции с отслеживанием состояния - Точки останова (breakpoints) - указание мест в коде, где выполнение должно остановиться - Логирование - запись информации о выполнении программы - Инспекция переменных - просмотр значений переменных в процессе выполнения - Отслеживание стека вызовов - анализ последовательности вызовов функций - Условные точки останова - остановка выполнения при выполнении определенного условия - Профилирование - анализ производительности и использования ресурсов - Дампы памяти - снимок состояния памяти программы - Удаленная отладка - отладка программы, выполняющейся на другой системе
25. Процесс. Взаимодействие с процессами
Процесс - экземпляр выполняющейся программы с выделенными ресурсами: - Имеет собственное адресное пространство - Содержит код, данные, стек, кучу - Имеет идентификатор процесса (PID) - Может создавать дочерние процессы
Методы взаимодействия с процессами: - Создание процессов - fork(), exec(), CreateProcess() - Завершение процессов - exit(), kill(), TerminateProcess() - Ожидание завершения - wait(), waitpid(), WaitForSingleObject() - Приоритеты процессов - nice(), SetPriorityClass() - Обмен данными между процессами (IPC): - Файлы и файловая система - Каналы (pipes) и именованные каналы - Сокеты - Разделяемая память - Сигналы - Очереди сообщений
26. Структура консольного приложения
Структура консольного приложения включает: - Точка входа - main() или аналогичная функция - Обработка аргументов командной строки - Реализация основной логики - Управление потоками ввода/вывода: - stdin - стандартный ввод - stdout - стандартный вывод - stderr - стандартный поток ошибок - Обработка ошибок и исключений - Возвращение кода завершения
Типичные компоненты: - Парсеры командной строки - Модули обработки данных - Подсистема логирования - Интерфейс пользователя (текстовый) - Подключение к внешним ресурсам (файлы, сеть, БД)
27. Контейнеры компоновки макетов: LinearLayout
LinearLayout - контейнер компоновки в Android, который располагает элементы в одном направлении: - Ориентация - вертикальная (android:orientation=“vertical”) или горизонтальная (android:orientation=“horizontal”) - Выравнивание - элементы выравниваются по началу, концу, центру или заполняют пространство - Вес (weight) - позволяет распределить доступное пространство между элементами пропорционально значениям весов - Отступы - внешние (margin) и внутренние (padding) - Gravity - определяет, как элемент должен располагаться внутри своего контейнера
Преимущества: - Простота использования - Предсказуемое расположение элементов - Подходит для простых интерфейсов (списки, формы)
28. Организация сетевого взаимодействия
Организация сетевого взаимодействия включает: - Модель OSI - 7-уровневая модель сетевого взаимодействия - Стек протоколов TCP/IP - набор протоколов для Интернет-коммуникаций - Сокеты - программный интерфейс для сетевого взаимодействия - API для работы с сетью - библиотеки и фреймворки для сетевого программирования - HTTP/HTTPS - протоколы передачи гипертекста - WebSockets - протокол для двунаправленной связи - REST API - архитектурный стиль для взаимодействия компонентов - Сериализация/десериализация данных - преобразование объектов в формат для передачи (JSON, XML) - Асинхронное взаимодействие - неблокирующие операции ввода-вывода
29. Событийно-управляемое программирование
Событийно-управляемое программирование - парадигма, где выполнение программы определяется событиями: - События - действия пользователя, системные уведомления, таймеры - Обработчики событий - функции, реагирующие на события - Цикл обработки событий - основной цикл, ожидающий и диспетчеризирующий события - Подписка на события - регистрация обработчиков - Делегирование событий - передача событий от одного объекта другому
Применение: - Графические пользовательские интерфейсы - Веб-приложения (JavaScript) - Мобильные приложения - Асинхронные серверы - Системы автоматизации
30. Система информационной безопасности системного ПО
Система информационной безопасности системного ПО включает: - Управление доступом - аутентификация, авторизация, разграничение прав - Защита памяти - предотвращение несанкционированного доступа к памяти процессов - Песочницы (Sandboxing) - изолированное выполнение программ - Шифрование данных - защита хранимых и передаваемых данных - Обнаружение вторжений - мониторинг подозрительной активности - Обновления безопасности - устранение уязвимостей - Аудит безопасности - логирование событий безопасности - Управление уязвимостями - выявление и устранение слабых мест - Защита от вредоносного ПО - антивирусные механизмы
31. Коллекции
Коллекции - структуры данных для хранения и управления наборами объектов:
Основные типы коллекций: - Списки (Lists) - упорядоченные коллекции с доступом по индексу - Множества (Sets) - коллекции уникальных элементов - Словари (Dictionaries/Maps) - пары ключ-значение - Очереди (Queues) - FIFO (First In, First Out) - Стеки (Stacks) - LIFO (Last In, First Out) - Деревья (Trees) - иерархические структуры - Графы (Graphs) - узлы и связи между ними
Характеристики: - Размер (фиксированный или динамический) - Производительность операций (вставка, удаление, поиск) - Упорядоченность элементов - Уникальность элементов - Потокобезопасность
32. Алгоритмы поиска
Основные алгоритмы поиска: - Линейный поиск - последовательный перебор элементов (O(n)) - Двоичный поиск - поиск в отсортированном массиве путем деления пополам (O(log n)) - Интерполяционный поиск - улучшение двоичного поиска для равномерно распределенных данных (O(log log n) в среднем) - Поиск по хэш-таблице - использование хэш-функции для доступа к элементам (O(1) в среднем) - Поиск в деревьях: - Поиск в бинарном дереве поиска (BST) - Поиск в AVL-дереве - Поиск в красно-черном дереве - Поиск в B-дереве - Поиск в графах: - Поиск в ширину (BFS) - Поиск в глубину (DFS)
33. Верификация программного обеспечения
Верификация ПО - процесс проверки соответствия программы спецификациям и требованиям: - Статический анализ - проверка кода без его выполнения - Динамический анализ - проверка во время выполнения - Формальная верификация - математическое доказательство корректности - Инспекция кода - экспертная оценка кода - Модульное тестирование - проверка отдельных компонентов - Интеграционное тестирование - проверка взаимодействия компонентов - Системное тестирование - проверка всей системы - Проверка на соответствие стандартам - соблюдение отраслевых норм
Цель: выявление и устранение дефектов до выпуска продукта.
34. Методы тестирования
Методы тестирования ПО: - По уровню доступа к коду: - Черный ящик - тестирование без знания внутренней структуры - Белый ящик - тестирование с учетом внутренней структуры - Серый ящик - комбинированный подход - По сценарию: - Позитивное тестирование - проверка правильной работы при корректных входных данных - Негативное тестирование - проверка реакции на некорректные входные данные - По цели: - Функциональное тестирование - проверка функциональности - Нефункциональное тестирование - производительность, безопасность, удобство использования - По автоматизации: - Ручное тестирование - выполняется человеком - Автоматизированное тестирование - выполняется программами
35. Методы оптимизации программного кода
Методы оптимизации программного кода: - Алгоритмическая оптимизация - улучшение временной и пространственной сложности - Оптимизация данных - эффективное использование структур данных - Оптимизация компилятора - автоматические улучшения при компиляции - Кэширование - сохранение результатов вычислений для повторного использования - Распараллеливание - разделение задач на параллельные потоки - Профилирование - выявление узких мест - Ленивые вычисления - откладывание вычислений до момента необходимости - Пулинг ресурсов - повторное использование дорогостоящих ресурсов - Минимизация операций ввода-вывода - уменьшение количества обращений к диску/сети - Предварительная загрузка - загрузка данных до момента необходимости
36. Порядок разработки тестов. Аксиомы тестирования
Порядок разработки тестов: 1. Анализ требований и спецификаций 2. Разработка стратегии тестирования 3. Создание тестовых случаев 4. Подготовка тестовых данных 5. Настройка тестовой среды 6. Выполнение тестов 7. Анализ результатов 8. Отчетность о дефектах 9. Перетестирование исправлений
Аксиомы тестирования: - Невозможность полного тестирования - нельзя протестировать все возможные входные данные и сценарии - Скопление дефектов - большинство дефектов сконцентрировано в небольшой части кода - Парадокс пестицида - повторяющиеся тесты теряют эффективность со временем - Тестирование показывает наличие дефектов, но не их отсутствие - Раннее тестирование экономит ресурсы - Зависимость тестирования от контекста - разные системы требуют разных подходов - Отсутствие ошибок не гарантирует полезность продукта
37. Классификация типов мобильных приложений по способу разработки: сравнительная характеристика
Типы мобильных приложений по способу разработки:
1.	Нативные приложения:
–	Разрабатываются специально для конкретной платформы (iOS, Android)
–	Языки: Swift/Objective-C (iOS), Java/Kotlin (Android)
–	Преимущества: высокая производительность, полный доступ к API устройства
–	Недостатки: высокая стоимость разработки, необходимость поддержки разных кодовых баз
2.	Гибридные приложения:
–	Веб-технологии (HTML, CSS, JavaScript) в нативной оболочке
–	Frameworks: Cordova, Ionic, PhoneGap
–	Преимущества: одна кодовая база, кроссплатформенность
–	Недостатки: ниже производительность, ограниченный доступ к API устройства
3.	Кроссплатформенные приложения:
–	Компилируются в нативный код для разных платформ
–	Frameworks: React Native, Flutter, Xamarin
–	Преимущества: единая кодовая база с нативной производительностью
–	Недостатки: ограничения при работе со сложными API, зависимость от фреймворка
4.	Прогрессивные веб-приложения (PWA):
–	Веб-сайты, функционирующие как приложения
–	Технологии: HTML5, CSS3, JavaScript, Service Workers
–	Преимущества: не требуют установки, работают офлайн
–	Недостатки: ограниченный доступ к аппаратным функциям
38. Примитивы синхронизации: События
События (Events) - примитивы синхронизации, позволяющие одному потоку сигнализировать другим о наступлении определенного состояния: - Ручной сброс - событие остается в сигнальном состоянии до явного сброса - Автоматический сброс - событие автоматически сбрасывается после освобождения одного ожидающего потока - Начальное состояние - событие может быть создано в сигнальном или несигнальном состоянии
Операции: - Сигнализирование (Set) - перевод события в сигнальное состояние - Сброс (Reset) - перевод события в несигнальное состояние - Ожидание (Wait) - блокировка потока до наступления события - Проверка состояния - опрос текущего состояния события
Применение: - Уведомление о завершении операции - Синхронизация начала параллельных операций - Реализация шаблона “производитель-потребитель”
39. Принципы разработки интерфейса пользователя
Принципы разработки пользовательского интерфейса: - Простота - интерфейс должен быть интуитивно понятным - Согласованность - единообразие элементов и поведения - Обратная связь - информирование пользователя о результатах действий - Прощение ошибок - возможность отмены действий, предотвращение критических ошибок - Эффективность - минимизация количества действий для выполнения задачи - Доступность - учет потребностей пользователей с ограниченными возможностями - Эстетика - приятный внешний вид - Контроль пользователя - пользователь должен чувствовать контроль над системой - Гибкость - адаптация под разные устройства и предпочтения
Методологии: - User-Centered Design (UCD) - Material Design - Human Interface Guidelines (HIG) - Responsive Design
40. Определение потока. Создание и завершение потока
Поток (Thread) - наименьшая единица выполнения, которой операционная система может управлять отдельно: - Часть процесса, имеющая свой стек и набор регистров - Разделяет адресное пространство с другими потоками в том же процессе - Имеет свой идентификатор и приоритет
Создание потока: - В C++: std::thread, pthread_create() - В Java: Thread, Runnable - В Python: threading.Thread() - В C#: System.Threading.Thread
Завершение потока: - Естественное завершение (выполнение кода) - Явное завершение (pthread_exit(), Thread.interrupt()) - Принудительное завершение (не рекомендуется) - Ожидание завершения (join(), wait())
Параметры создания: - Функция/метод для выполнения - Аргументы функции - Размер стека - Приоритет - Флаги (например, detached/joinable)
41. Контейнеры компоновки макетов: FrameLayout
FrameLayout - простейший контейнер компоновки в Android: - Предназначен для отображения одного элемента, занимающего всю доступную область - Позволяет размещать элементы друг поверх друга (как слои) - Каждый элемент располагается относительно верхнего левого угла контейнера - Поддерживает позиционирование с помощью gravity (центр, верх, низ и т.д.) - Часто используется для фрагментов, наложения элементов и анимаций
Применение: - Контейнер для одиночного представления - Реализация переключения между представлениями - Создание наложений (оверлеев) - Контейнер для фрагментов - Основа для специализированных представлений (например, CardView)
42. Место тестирования и отладки в жизненном цикле программного обеспечения
Тестирование и отладка в жизненном цикле ПО:
1.	Планирование - разработка стратегии тестирования
2.	Анализ требований - создание тестовых случаев на основе требований
3.	Проектирование - верификация проектных решений
4.	Реализация:
–	Модульное тестирование в процессе разработки
–	Отладка выявленных проблем
–	Статический анализ кода
5.	Тестирование:
–	Интеграционное тестирование
–	Системное тестирование
–	Регрессионное тестирование
–	Отладка выявленных дефектов
6.	Развертывание:
–	Приемочное тестирование
–	Бета-тестирование
7.	Сопровождение:
–	Отладка проблем, обнаруженных в эксплуатации
–	Тестирование обновлений и исправлений
Непрерывная интеграция (CI) и непрерывная доставка (CD) обеспечивают автоматизацию тестирования на всех этапах.
43. Технология структурного программирования
Технология структурного программирования - методология разработки, основанная на принципах: - Нисходящее проектирование - разбиение задачи на подзадачи - Модульность - разделение программы на независимые модули - Ограниченное использование операторов перехода (goto) - Стандартные управляющие структуры: - Последовательность (следование) - Ветвление (if-then-else) - Цикл (for, while)
Теорема Бома-Якопини: любой алгоритм можно реализовать, используя только три базовые управляющие структуры.
Преимущества: - Улучшение читаемости кода - Упрощение отладки и тестирования - Повышение надежности программ - Повторное использование кода
44. Состояния потока
Основные состояния потока: - Новый (New) - поток создан, но не запущен - Готовый к выполнению (Runnable) - поток готов к выполнению и ожидает процессорного времени - Выполняющийся (Running) - поток выполняется процессором - Заблокированный (Blocked) - поток ожидает ресурса (I/O, синхронизация) - Ожидающий (Waiting) - поток ожидает сигнала от другого потока - Спящий (Sleeping) - поток временно приостановлен - Завершенный (Terminated) - поток завершил выполнение
Переходы между состояниями: - Новый → Готовый: после вызова start() - Готовый → Выполняющийся: планировщик выбирает поток для выполнения - Выполняющийся → Заблокированный: ожидание ресурса - Заблокированный → Готовый: ресурс стал доступен - Выполняющийся → Ожидающий: вызов wait(), join() - Ожидающий → Готовый: получение сигнала notify(), notifyAll() - Выполняющийся → Спящий: вызов sleep() - Спящий → Готовый: истечение времени сна - Выполняющийся → Завершенный: завершение выполнения или исключение
45. Алгоритмы сортировки
Основные алгоритмы сортировки: - Пузырьковая сортировка (Bubble Sort) - O(n²), простая реализация, неэффективна для больших наборов - Сортировка вставками (Insertion Sort) - O(n²), эффективна для почти отсортированных данных - Сортировка выбором (Selection Sort) - O(n²), минимальное количество обменов - Быстрая сортировка (Quick Sort) - O(n log n) в среднем, разделяй и властвуй, рекурсивная - Сортировка слиянием (Merge Sort) - O(n log n), разделяй и властвуй, стабильная - Пирамидальная сортировка (Heap Sort) - O(n log n), использует бинарную кучу - Сортировка подсчетом (Counting Sort) - O(n+k), для целых чисел в ограниченном диапазоне - Поразрядная сортировка (Radix Sort) - O(nk), для чисел с фиксированным количеством разрядов - Сортировка Шелла (Shell Sort) - улучшенная сортировка вставками
Характеристики алгоритмов: - Временная сложность - Пространственная сложность - Стабильность (сохранение относительного порядка равных элементов) - Адаптивность (эффективность для частично отсортированных данных)
46. Системное программное обеспечение: подходы к определению и классификации
Системное программное обеспечение - набор программ, обеспечивающих управление аппаратными ресурсами компьютера и предоставляющих платформу для работы прикладного ПО.
Подходы к определению: - Функциональный - ПО, выполняющее системные функции - Структурный - ПО, являющееся частью операционной системы или расширяющее её - По уровню абстракции - ПО, работающее на низком уровне абстракции (близко к аппаратуре)
Классификация: 1. Операционные системы: - Ядро ОС - Подсистемы ввода-вывода - Файловые системы - Подсистемы управления процессами и памятью
2.	Сервисные программы (утилиты):
–	Диагностические программы
–	Программы обслуживания дисков
–	Архиваторы
–	Антивирусы
3.	Инструментальное ПО:
–	Компиляторы и интерпретаторы
–	Отладчики
–	Профилировщики
–	Системы контроля версий
4.	Драйверы устройств:
–	Драйверы ввода-вывода
–	Сетевые драйверы
–	Драйверы графических устройств
5.	Системы управления базами данных
47. Использование интентов при разработке мобильного приложения
Интент (Intent) в Android - объект, представляющий намерение выполнить действие или сообщение для активации компонента:
Типы интентов: - Явные (Explicit) - точно указывают компонент для активации - Неявные (Implicit) - указывают действие без явного указания компонента
Компоненты интента: - Action - действие, которое нужно выполнить - Data - URI данных и их MIME-тип - Category - категория компонента, который должен обрабатывать интент - Extras - дополнительные данные в виде пар ключ-значение - Flags - флаги, влияющие на обработку интента
Применение: - Запуск активностей - Запуск служб - Передача данных между компонентами - Отправка широковещательных сообщений - Работа с системными функциями (звонки, отправка SMS, открытие веб-страниц) - Обмен данными между приложениями
Фильтры интентов позволяют компонентам определить, какие интенты они могут обрабатывать.
48. Примитивы синхронизации: Семафоры
Семафор - примитив синхронизации, предназначенный для контроля доступа к ресурсу: - Представляет собой счетчик с атомарными операциями - Обеспечивает синхронизацию между потоками или процессами - Может использоваться для ограничения доступа к ресурсу определенным числом потоков
Типы семафоров: - Двоичный семафор (Binary) - принимает значения 0 или 1 (аналогичен мьютексу) - Счетный семафор (Counting) - принимает произвольные неотрицательные значения
Операции: - P (wait, acquire) - уменьшает значение семафора на 1; если значение становится отрицательным, поток блокируется - V (signal, release) - увеличивает значение семафора на 1; если есть заблокированные потоки, один из них разблокируется
Применение: - Взаимное исключение (двоичный семафор) - Ограничение количества одновременных пользователей ресурса - Синхронизация выполнения потоков - Реализация шаблонов “производитель-потребитель” и “читатели-писатели”
49. Способы записи алгоритмов
Основные способы записи алгоритмов: - Словесное описание - пошаговое описание на естественном языке - Блок-схемы - графическое представление с использованием стандартных символов - Псевдокод - промежуточный между естественным языком и языком программирования - Программный код - запись на конкретном языке программирования - Математические формулы - для математических алгоритмов - Диаграммы активности UML - стандартизированное графическое представление - Диаграммы переходов состояний - для алгоритмов, основанных на состояниях - Таблицы решений - табличное представление для сложных условий
Каждый способ имеет свои преимущества и области применения: - Блок-схемы наглядны для простых алгоритмов - Псевдокод легко преобразуется в код на любом языке - Математические формулы компактны для математических алгоритмов
50. Концепция виртуальной памяти
Виртуальная память - метод управления памятью, который предоставляет процессам иллюзию большого непрерывного адресного пространства независимо от доступной физической памяти: - Процессы работают с виртуальными адресами, которые преобразуются в физические - Подкачка страниц (Paging) - технология, при которой адресное пространство делится на страницы фиксированного размера - Сегментация - деление адресного пространства на логические сегменты переменного размера
Компоненты: - MMU (Memory Management Unit) - аппаратный модуль для трансляции адресов - Таблица страниц - структура данных для отображения виртуальных адресов в физические - TLB (Translation Lookaside Buffer) - кэш для ускорения трансляции адресов - Файл подкачки (Swap file) - область на диске для выгрузки неиспользуемых страниц
Преимущества: - Изоляция процессов друг от друга - Использование больше памяти, чем физически доступно - Упрощение программирования (непрерывное адресное пространство) - Защита памяти - Эффективное использование физической памяти
Недостатки: - Накладные расходы на преобразование адресов - Возможность снижения производительности при интенсивной подкачке (thrashing)
51. ООП: Методы
Метод в ООП - функция, определенная внутри класса и описывающая поведение объектов этого класса: - Имеет доступ к атрибутам и другим методам класса - Может принимать параметры и возвращать значения - Инкапсулирует логику работы с данными объекта
Типы методов: - Методы экземпляра - работают с конкретным экземпляром класса - Статические методы (классовые) - принадлежат классу, а не экземпляру - Методы доступа - геттеры и сеттеры для атрибутов - Конструкторы - специальные методы для инициализации объектов - Деструкторы - методы для освобождения ресурсов - Перегруженные методы - методы с одинаковым именем, но разными параметрами - Переопределенные методы - методы, изменяющие поведение родительских методов
Характеристики: - Сигнатура - имя метода и его параметры - Модификаторы доступа - public, private, protected - Возвращаемое значение - тип данных, возвращаемый методом - Реализация - тело метода с алгоритмом
52. Ввод-вывод высокого уровня на консоль
Ввод-вывод высокого уровня на консоль - программные средства для взаимодействия с пользователем через консоль:
Особенности: - Абстракция от низкоуровневых операций ввода-вывода - Буферизация данных для повышения производительности - Форматирование вывода - Преобразование типов данных - Обработка ошибок - Интернационализация
Стандартные потоки: - stdin (стандартный ввод) - получение данных от пользователя - stdout (стандартный вывод) - вывод обычных данных - stderr (стандартный поток ошибок) - вывод сообщений об ошибках
Примеры в разных языках: - C: printf(), scanf(), fprintf(), fscanf() - C++: std::cout, std::cin, std::cerr - Java: System.out.println(), System.in, Scanner - Python: print(), input(), форматированный вывод с f-строками - C#: Console.WriteLine(), Console.ReadLine()
Управление консолью: - Очистка экрана - Позиционирование курсора - Цветной текст - Специальные символы и ANSI-последовательности
