"""Return structure from Untappd API."""
# generated by datamodel-codegen:
#   filename:  had.json
#   timestamp: 2025-04-25T12:03:51+00:00

from __future__ import annotations

from functools import total_ordering
from typing import Any

from pydantic import BaseModel, ConfigDict, Field


class ResponseTime(BaseModel):
    model_config = ConfigDict(frozen=True)
    time: float
    measure: str


class InitTime(BaseModel):
    model_config = ConfigDict(frozen=True)
    time: int
    measure: str


class Meta(BaseModel):
    model_config = ConfigDict(frozen=True)
    code: int
    response_time: ResponseTime
    init_time: InitTime


class UnreadCount(BaseModel):
    model_config = ConfigDict(frozen=True)
    comments: int
    toasts: int
    friends: int
    messages: int
    venues: int
    veunes: int
    others: int
    news: int


class Notifications(BaseModel):
    model_config = ConfigDict(frozen=True)
    type: str
    unread_count: UnreadCount


class Dates(BaseModel):
    model_config = ConfigDict(frozen=True)
    first_checkin_date: str
    start_date: bool | str
    end_date: bool | str
    tz_offset: str = Field(..., alias="tzOffset")


@total_ordering
class Beer(BaseModel):
    model_config = ConfigDict(frozen=True)
    bid: int
    beer_name: str
    beer_label: str
    beer_abv: float
    beer_ibu: int
    beer_slug: str
    beer_style: str
    beer_description: str
    created_at: str
    rating_score: float
    rating_count: int

    def __eq__(self, other: object) -> bool:
        """Beer ID is unique, so we can use it."""
        return self.bid == other.bid if isinstance(other, Beer) else NotImplemented

    def __lt__(self, other: object) -> bool:
        """Beer ID is unique, so we can use it for ordering."""
        return self.bid < other.bid if isinstance(other, Beer) else NotImplemented

    def __hash__(self) -> int:
        """Beer ID is unique, so we can use it as a hash."""
        return hash(self.bid)


class Contact(BaseModel):
    model_config = ConfigDict(frozen=True)
    twitter: str
    facebook: str
    instagram: str
    url: str


class Location(BaseModel):
    model_config = ConfigDict(frozen=True)
    brewery_city: str
    brewery_state: str
    lat: float
    lng: float


class Brewery(BaseModel):
    model_config = ConfigDict(frozen=True)
    brewery_id: int
    brewery_name: str
    brewery_slug: str | None
    brewery_page_url: str
    brewery_type: Any
    brewery_label: str
    country_name: str
    contact: Contact
    location: Location
    brewery_active: int


class Item(BaseModel):
    model_config = ConfigDict(frozen=True)
    first_checkin_id: int
    first_created_at: str
    recent_checkin_id: int
    recent_created_at: str
    recent_created_at_timezone: int
    rating_score: float
    user_auth_rating_score: float
    first_had: str
    count: int
    beer: Beer
    brewery: Brewery


class Beers(BaseModel):
    model_config = ConfigDict(frozen=True)
    count: int
    items: list[Item]
    sort_english: str
    sort_name: str


class Pagination(BaseModel):
    model_config = ConfigDict(frozen=True)
    next_url: str
    offset: int | None = None
    max_id: bool | str


class Response(BaseModel):
    model_config = ConfigDict(frozen=True)
    total_count: int
    dates: Dates
    is_search: bool
    sort: bool | str
    type_id: bool
    country_id: bool
    brewery_id: bool
    rating_score: bool
    region_id: bool
    container_id: bool
    is_multi_type: bool
    beers: Beers
    sort_key: str
    sort_name: str
    pagination: Pagination


class UserBeers(BaseModel):
    model_config = ConfigDict(frozen=True)
    meta: Meta
    notifications: Notifications
    response: Response
