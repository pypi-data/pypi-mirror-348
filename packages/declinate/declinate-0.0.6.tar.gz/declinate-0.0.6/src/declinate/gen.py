# Copyright 2022 - 2025 Ternaris
# SPDX-License-Identifier: Apache-2.0
"""CLI Code Generator."""

from __future__ import annotations

import importlib
import inspect
import operator
import re
import sys
import typing
from collections.abc import Generator
from functools import reduce
from importlib.util import module_from_spec, spec_from_loader
from itertools import takewhile
from pathlib import Path
from types import NoneType
from typing import (
    TYPE_CHECKING,
    Annotated,
    NamedTuple,
    NoReturn,
    _SpecialForm as SpecialForm,  # pyright: ignore[reportPrivateUsage]
    cast,
    get_args,
    get_origin,
    get_type_hints,
)

if sys.version_info >= (3, 12):
    from typing import override
else:
    from typing_extensions import override

if TYPE_CHECKING:
    from collections.abc import Callable
    from types import ModuleType
    from typing import ParamSpec, TypeAlias, TypedDict

    P = ParamSpec('P')

    class ArgMetadata(TypedDict, total=False):
        """Argument annotation metadata."""

        action: str
        complete: Completer
        dest: str
        flags: list[str]
        group: str
        help: str | Argtype
        required: bool
        type: Argtype
        nodefault: str

    AnyCall: TypeAlias = Callable[[], list[str]]
    ArgDesc = tuple[type, ArgMetadata, bool, bool | bytes | int | float | str | type | None]
    Completer = Callable[[list[str], str, object], list[str]]

HEADER = [
    '"""Generated declinate CLI."""',
    '',
    '# DO NOT EDIT THIS FILE MANUALLY',
    '# pyright: basic',
    '# ruff: noqa: PGH004',
    '# ruff: noqa',
    '',
    'from __future__ import annotations',
    '',
]

HEADER_IMPORTS = [
    'import argparse',
    'import re',
    'import sys',
    'import os',
    'from pathlib import Path',
    'from typing import TYPE_CHECKING',
    '',
]

HEADER_TYPE_CHECKING = [
    'if TYPE_CHECKING:',
    '    from typing import Callable, NoReturn',
    '',
    '',
    'class HelpFormatter(argparse.HelpFormatter):',
    '    """Help formatter."""',
    '',
    '    def __init__(',
    '        self,',
    '        prog: str,',
    '        indent_increment: int = 2,',
    '        max_help_position: int = 24,',
    '        width: int | None = None,',
    '    ) -> None:',
    '        """Init."""',
    '        super().__init__(prog, indent_increment, max_help_position, width)',
    '        self._width = min(self._width, 78)',
    '',
    '    def _fill_text(self, text: str, width: int, indent: str) -> str:',
    '        """Reformat individual paragraphs."""',
    '        parent = super()._fill_text',
    '',
    '        def idn(text: str) -> str:',
    "            if re.match(r'(?m)(^.*?:$)|(^ )', text):",
    '                return text',
    '            return parent(text, width, indent)',
    '',
    "        return '\\n\\n'.join(map(idn, text.split('\\n\\n')))",
    '',
    '    def _metavar_formatter(',
    '        self,',
    '        action: argparse.Action,',
    '        default_metavar: str,',
    '    ) -> Callable[[int], tuple[str, ...]]:',
    '        if isinstance(action, argparse._SubParsersAction) and action.choices:',
    '            choice_strs = [',
    (
        '                k for k, v in action.choices.items()'
        " if not v.description.startswith('SUPPRESS.')"
    ),
    '            ]',
    '            result = f\'{{{",".join(choice_strs)}}}\'',
    '            return lambda x: (result,) * x',
    '        return super()._metavar_formatter(action, default_metavar)',
    '',
    '',
    'class ArgumentParser(argparse.ArgumentParser):',
    '    """Argument parser."""',
    '',
    '    def _check_value(self, action: argparse.Action, value: str) -> None:',
    '        """Filter suppressed actions."""',
    '        if isinstance(action, argparse._SubParsersAction):',
    '            if action.choices and value not in action.choices:',
    "                msg = f'invalid action: {value!r}'",
    '                raise argparse.ArgumentError(action, msg)',
    '        else:',
    '            super()._check_value(action, value)',
    '',
    '',
]

MAIN = [
    'def main() -> NoReturn:  # pragma: no cover',
    '    """CLI entrypoint."""',
    "    if 'COMP_LINE' in os.environ:",
    '        generate_completion()',
    '        sys.exit(0)',
    '',
    "    if '_COMPLETER' in os.environ:",
    '        generate_source_completion()',
    '        sys.exit(0)',
]

COMPLETE = [
    'COMPLETER_BASH = """\\',
    '_completer__%(name)s() {',
    "    local IFS=$'\\\\n'",
    '    for reply in $(env _COMPLETER=bash COMP_LINE="$COMP_LINE" COMP_POINT=$COMP_POINT $1); do',
    '        IFS=\',\' read type value descr <<< "$reply"',
    '        if [[ $type == "directory" ]]; then',
    '            compopt -o dirnames',
    '        elif [[ $type == "file" ]]; then',
    '            compopt -o default',
    '        elif [[ $type == "string" ]]; then',
    '            COMPREPLY+=($value)',
    '        fi',
    '    done',
    '    return 0',
    '}',
    'complete -o nosort -F _completer__%(name)s %(name)s;',
    '"""',
    '',
    'COMPLETER_ZSH = """\\',
    '#compdef %(name)s',
    '_completer__%(name)s() {',
    '    local -a values values_descrs',
    '    (( ! $+commands[%(name)s] )) && return 1',
    (
        '    for reply in '
        '"${(@f)$(env _COMPLETER=zsh COMP_LINE="$BUFFER" COMP_POINT=$CURSOR %(name)s)}"; do'
    ),
    '       IFS="," read type value descr <<< "$reply"',
    '       if [[ "$type" == "directory" ]]; then',
    '           _path_files -/',
    '       elif [[ "$type" == "file" ]]; then',
    '           _path_files -f',
    '       elif [[ "$type" == "string" ]]; then',
    '           if [[ -n "$descr" ]]; then',
    '               values_descrs+=("$value":"$descr")',
    '           else',
    '               values+=("$value")',
    '           fi',
    '       fi',
    '    done',
    '    if [ -n "$values_descrs" ]; then',
    '        _describe -V unsorted values_descrs -U',
    '    fi',
    '    if [ -n "$values" ]; then',
    '        compadd -U -V unsorted -a values',
    '    fi',
    '}',
    'compdef _completer__%(name)s %(name)s;',
    '"""',
    '',
    '',
    'def generate_source_completion() -> None:',
    '    """Generate snippet for sourcing from shell."""',
    "    completer = os.getenv('_COMPLETER')",
    '    assert completer',
    '    completers = {',
    "        'bash': COMPLETER_BASH,",
    "        'zsh': COMPLETER_ZSH,",
    '    }',
    "    print(completers[completer] % {'name': Path(sys.argv[0]).name})",
    '',
    '',
    'def consume_action(action: argparse.Action, arg: str) -> None:',
    '    """Consume arg in action."""',
    '    if action.choices and arg not in action.choices:',
    '        raise ValueError',
    '',
    '',
    'def consume_parser(',
    '    parser: ArgumentParser,',
    '    excluded: list[argparse.Action],',
    '    arg: str,',
    ') -> tuple[ArgumentParser, argparse.Action | None]:',
    '    """Consume parser."""',
    '    for action in parser._actions:',
    '        if isinstance(action, argparse._SubParsersAction):',
    '            for option, subaction in action.choices.items():',
    '                if option == arg:',
    '                    return subaction, None',
    '',
    "        if arg.startswith('-'):",
    '            if any(x == arg for x in action.option_strings):',
    '                break',
    '        else:',
    '            if not action.option_strings:',
    '                break',
    '    else:',
    '        raise ValueError',
    '',
    '    if not isinstance(action, argparse._CountAction) and not (',
    "        isinstance(action.nargs, str) and action.nargs in '*+'",
    '    ):',
    '        excluded.append(action)',
    '    for group in parser._mutually_exclusive_groups:',
    '        if action in group._group_actions:',
    '            for subaction in group._group_actions:',
    '                if subaction != action and subaction not in excluded:',
    '                    excluded.append(subaction)',
    '    return parser, action if (',
    '        action.option_strings or action.choices',
    '    ) and action.nargs != 0 else None',
    '',
    '',
    'def complete_actions(',
    '    actions: list[argparse.Action],',
    '    excluded: list[argparse.Action],',
    '    args: list[str],',
    '    arg: str,',
    ') -> None:',
    '    """Complete actions."""',
    '    completed: list[tuple[str, str]] = []',
    '    for action in sorted(actions, key=lambda x: not x.required):',
    '        if action in excluded:',
    '            continue',
    '',
    '        if isinstance(action, argparse._SubParsersAction):',
    '            completed += [',
    '                (k, v.description)',
    '                for k, v in action.choices.items()',
    "                if not v.description.startswith('SUPPRESS.')",
    '            ]',
    '',
    '        elif action.option_strings:',
    "            completed += [(x, action.help or '') for x in action.option_strings]",
    '',
    '        elif action.choices:',
    "            completed += [(x, '') for x in action.choices]",
    '',
    '        else:',
    "            completed += [(x, '') for x in custom_complete(action, args, arg)]",
    '',
    '        if not arg and action.required:',
    '            break',
    '',
    "    have_positinal = any(not x.startswith('-') for x, _ in completed)",
    '    for option, descr in sorted(completed):',
    "        if have_positinal and not arg and option.startswith('-'):",
    '            continue',
    '        if option.startswith(arg):',
    "            print(f'string,{option},{descr}')",
    '',
    '',
    'def complete_action(action: argparse.Action, args: list[str], arg: str) -> None:',
    '    """Complete action."""',
    '    completed: list[tuple[str, str]] = []',
    '',
    '    if action.type == Path:',
    "        print('file,,')",
    '',
    '    if action.choices:',
    '        if isinstance(action.choices, dict):',
    '            completed += action.choices.items()',
    '        else:',
    "            completed += [(x, '') for x in action.choices]",
    '',
    "    completed += [(x, '') for x in custom_complete(action, args, arg)]",
    '',
    '    for option, descr in sorted(completed):',
    "        if not arg and option.startswith('-'):",
    '            continue',
    '        if option.startswith(arg):',
    "            print(f'string,{option},{descr}')",
    '',
    '',
    'def generate_completion() -> None:',
    '    """Generate snippet for sourcing from shell."""',
    '    import shlex',
    '',
    "    lexer = shlex.shlex(os.getenv('COMP_LINE'), posix=True)",
    "    pos = int(os.getenv('COMP_POINT', '0'))",
    '    lexer.whitespace_split = True',
    "    lexer.commenters = ''",
    '    args = []',
    '    cword = None',
    '',
    '    next(lexer)',
    '    laststate = lexer.state  # type: ignore[attr-defined]',
    '    try:',
    '        for index, token in enumerate(lexer):',
    '            args.append(token)',
    '            laststate = lexer.state  # type: ignore[attr-defined]',
    '            if cword is None and lexer.instream.tell() > pos:  # type: ignore[attr-defined]',
    '                cword = index',
    '    except ValueError:',
    '        args.append(lexer.token)',
    "        laststate = 'error'",
    "    if laststate == ' ':",
    "        args.append('')",
    '    if cword is None:',
    '        cword = len(args) - 1',
    '',
    '    parser = PARSER',
    '    action = None',
    '    excluded: list[argparse.Action] = []',
    '',
    '    # interpret_args(parser, action, excluded, args, cword)',
    '    for arg in args[:cword]:',
    "        # print('string,try', arg)",
    '        if action:',
    '            try:',
    '                consume_action(action, arg)',
    '                action = None',
    '            except ValueError:',
    '                sys.exit(0)',
    '            continue',
    '',
    '        try:',
    '            parser, action = consume_parser(parser, excluded, arg)',
    '        except ValueError:',
    '            sys.exit(0)',
    '',
    '    arg = args[cword]',
    '',
    '    if action:',
    '        complete_action(action, args, arg)',
    '        sys.exit(0)',
    '',
    '    complete_actions(parser._actions, excluded, args, arg)',
    '    sys.exit(0)',
    '',
    '',
]

NEWLINE = '\n'


class DeclinateError(Exception):
    """Declinate Error."""


class Argtype:
    """Argument type with identity repr."""

    def __init__(self, name: str) -> None:
        """Save name."""
        self.name = name

    @override
    def __repr__(self) -> str:
        """Use raw name as repr."""
        return self.name


def get_module(package: str) -> ModuleType:
    """Get module for package.

    This functions reloads the module with TYPE_CHECKING enabled.

    Args:
        package: Python package name.

    Returns:
        Module.

    """
    module = importlib.import_module(package=package, name='.declinate')
    otc = typing.TYPE_CHECKING
    typing.TYPE_CHECKING = True  # type: ignore[misc]
    module = importlib.reload(module)
    assert module
    assert module.__file__
    res = importlib.reload(module)
    typing.TYPE_CHECKING = otc  # type: ignore[misc]
    return res


class DocstringInfo(NamedTuple):
    """Command information."""

    shortdesc: str
    description: str
    args: dict[str, str]
    groups: dict[str, str]
    excgroups: dict[str, str]


class CommandInfo(NamedTuple):
    """Command information."""

    name: str
    module: str
    shortdesc: str
    description: str
    args: dict[str, ArgDesc]
    groups: dict[str, str]
    excgroups: dict[str, str]
    returntype: type[int | Generator[None, None, int]] | SpecialForm
    is_async: bool


def parse_docstring(doc: str) -> DocstringInfo:
    """Parse docstring."""
    flags = re.ASCII | re.MULTILINE | re.DOTALL

    def extract_sections(text: str) -> dict[str, str]:
        sections: list[str] = re.findall(
            r'\n\n^\w+:.*?(?=\n\n^\w+:)',
            '\n\nMain:\n' + text + '\n\nLast:\n',
            flags=flags,
        )
        res: dict[str, str] = {}
        argsection = next((x for x in sections if x.startswith('\n\nArgs:\n')), None)
        if argsection:
            idx = sections.index(argsection)
            sections = [reduce(operator.add, sections[:idx]), *sections[idx:]]
        for section in sections:
            parts = section.split(':\n', 1)
            key = parts[0].strip().lower()
            value = parts[1]
            res[key] = value
        return res

    def extract_key_value(text: str) -> dict[str, str]:
        sections: list[str] = re.findall(
            r' {4}\w+: .*?(?= {4}\w+: )',
            text + '\n    Last: ',
            flags=flags,
        )
        res: dict[str, str] = {}
        for section in sections:
            parts = section.split(': ', 1)
            key = parts[0].strip().lower()
            value = parts[1]
            res[key] = ' '.join(x.strip() for x in value.split('\n')).strip()
        return res

    sections = extract_sections(doc)

    res: dict[str, str | dict[str, str]] = {}
    for key, value in sections.items():
        if key in {'args', 'groups', 'excgroups'}:
            res[key] = extract_key_value(value)
        else:
            res[key] = value

    main = res['main']
    assert isinstance(main, str)
    shortdesc = main.split('\n\n', 1)[0]
    if '\n' in main:
        lines = main.split(NEWLINE)
        description = '\n'.join(
            [
                '(',
                *[f'        {x + NEWLINE!r}' for x in lines[:-1]],
                f'        {lines[-1]!r}',
                '    )',
            ],
        )
    else:
        description = repr(main)

    args = res.get('args', {})
    assert isinstance(args, dict)
    groups = res.get('groups', {})
    assert isinstance(groups, dict)
    excgroups = res.get('excgroups', {})
    assert isinstance(excgroups, dict)

    return DocstringInfo(shortdesc, description, args, groups, excgroups)


def inspect_command(command: Callable[P, list[str]]) -> CommandInfo:
    """Introspect command.

    Args:
        command: Python function.

    Returns:
        Python function information.

    Raises:
        DeclinateError: If command does not adhere to expectations.

    """
    name = command.__name__
    module = command.__module__
    doc = inspect.getdoc(command)
    is_async = inspect.iscoroutinefunction(command)
    if not doc:
        msg = f'No docstring on {command!r}'
        raise DeclinateError(msg)
    docstrinfo = parse_docstring(doc)

    signature = inspect.signature(command)
    hints: dict[str, type] = get_type_hints(command, include_extras=True)

    args: dict[str, ArgDesc] = {}
    for argname, parameter in signature.parameters.items():
        annotation = hints[argname]
        if get_origin(annotation) and get_args(annotation)[-1] is NoneType:
            annotation = cast('type', get_args(annotation)[0])

        if get_origin(annotation) is Annotated:
            annotation, metadata_ = cast('tuple[type, list[tuple[str, str]]]', get_args(annotation))
            metadata: ArgMetadata = cast('ArgMetadata', cast('object', dict(metadata_)))
        else:
            metadata = {}

        helpstr = docstrinfo.args[argname]
        default = cast('bool | bytes | int | float | str | type | None', parameter.default)  # pyright: ignore[reportAny]
        has_default = default != inspect.Parameter.empty

        if 'help' not in metadata:
            if (
                annotation is not bool
                and has_default
                and metadata.get('action') != 'count'
                and metadata.pop('nodefault', None) is None
            ):
                helpstr += f' (default={default!r})'
            metadata['help'] = helpstr

        args[argname] = (annotation, metadata, has_default, default)

    return CommandInfo(
        name,
        module,
        docstrinfo.shortdesc,
        docstrinfo.description,
        args,
        docstrinfo.groups,
        docstrinfo.excgroups,
        hints['return'],
        is_async,
    )


def generate_parser_code(command: CommandInfo, *, is_sub: bool = False) -> list[str]:
    """Generate parser for command."""
    parent, name = '', command.name
    if '_' in name:
        parent, name = command.name.split('_', 1)

    subs = f'SUBS_{parent}.add_parser(' if parent else 'SUBS.add_parser('

    helpstrs = []
    if is_sub and not command.shortdesc.startswith('SUPPRESS.'):
        helpstrs = [f'    help={command.shortdesc!r},']

    return [
        f'SUB = {subs}' if is_sub else 'PARSER = ArgumentParser(',
        *([f'    {name!r},'] if is_sub else []),
        '    allow_abbrev=False,',
        '    argument_default=argparse.SUPPRESS,',
        '    formatter_class=HelpFormatter,',
        f'    description={command.description},',
        *helpstrs,
        ')',
    ]


def generate_argument_code(  # noqa: C901
    name: str,
    desc: ArgDesc,
    parent: str,
    completers: dict[str, Completer],
) -> tuple[list[str], str, str | None]:
    """Generate argument code, imports, and group information."""
    if name in {'argparser', 'kwargs'}:
        return [], '', None

    annotation, metadata, has_default, default = desc
    metadata = metadata.copy()

    names: list[str]
    if 'flags' in metadata:
        names = metadata.pop('flags')
        metadata['dest'] = name
    else:
        names = [name]

    if names[0][0] == '-' and not has_default:
        metadata['required'] = True

    if annotation is bool:
        if has_default and default is True:
            metadata['action'] = 'store_false'
        else:
            metadata['action'] = 'store_true'
    elif metadata.get('action') != 'count':
        typ = annotation.__name__
        if typ == 'Sequence':
            typ = cast('type', get_args(annotation)[0]).__name__
        metadata['type'] = Argtype(typ)

    param = [f'{x!r}' for x in names]
    param += [f'{k}={v!r}' for k, v in metadata.items()]

    if annotation.__module__ != 'builtins':
        imp = f'from {annotation.__module__} import {annotation.__name__}\n'
    else:
        imp = ''

    if group := metadata.pop('group', None):
        parent = f'{parent}_{group}'

    if cast('str', metadata.get('help', '')).startswith('SUPPRESS'):
        metadata['help'] = Argtype('argparse.SUPPRESS')

    if 'complete' in metadata:
        actionname = f'ACTION{len(completers)}'
        completers[actionname] = metadata.pop('complete')
        actionis = f'{actionname} = '
    else:
        actionis = ''

    return (
        [
            f'{actionis}{parent}.add_argument(',
            *[f'    {x!r},' for x in names],
            *[f'    {k}={v!r},' for k, v in metadata.items()],
            ')',
        ],
        imp,
        group,
    )


def generate_groups_arguments_code(
    command: CommandInfo,
    defargs: dict[str, str],
    completers: dict[str, Completer],
    *,
    is_sub: bool = False,
) -> tuple[list[str], list[str]]:
    """Generate argument code, imports, and group information."""
    code: list[str] = []
    imports: list[str] = []

    parent = 'SUB' if is_sub else 'PARSER'

    args = [
        generate_argument_code(k, v, parent, completers)
        for k, v in command.args.items()
        if k not in defargs
    ]
    allgroups = {x[2] for x in args if x[2]}
    for group in sorted(allgroups):
        assert group
        if (helpstr := command.groups.get(group, None)) is not None:
            if helpstr != 'SUPPRESS.':
                code += [
                    f'{parent}_{group} = {parent}.add_argument_group(',
                    f'    {helpstr!r},',
                    ')  # fmt: skip',
                ]
            else:
                code += [f'{parent}_{group} = {parent}.add_argument_group()']
        else:
            helpstr = command.excgroups[group]
            if helpstr != 'SUPPRESS.':
                code += [
                    f'{parent}_{group} = {parent}.add_argument_group(',
                    f'    {helpstr!r},',
                    ').add_mutually_exclusive_group()  # fmt: skip',
                ]
            else:
                code += [f'{parent}_{group} = {parent}.add_mutually_exclusive_group()']

    for argcode, argimport, _ in args:
        code += argcode
        imports += [argimport]

    return code, imports


def generate_execute_code(
    cmd: CommandInfo,
    indent: int,
    *,
    terminal: bool = False,
    context: bool = False,
) -> list[str]:
    """Generate code to launch command."""
    spaces = ' ' * indent
    res: list[str] = []
    if 'argparser' in cmd.args:
        run = f'{cmd.name}(argparser=PARSER, **runargs)'
    else:
        run = f'{cmd.name}(**runargs)'
    if cmd.is_async:
        res += [f'{spaces}import asyncio', '']
        run = f'asyncio.run({run})'
    res += [f'{spaces}from {cmd.module} import {cmd.name}\n']
    if 'kwargs' in cmd.args:
        res += [f'{spaces}runargs = args']
    else:
        res += [
            f'{spaces}runargs = {{',
            f'{spaces}    k: v for k, v in args.items()',
            f'{spaces}    if k in {{',
            *[f'{spaces}        {x!r},' for x in cmd.args],
            f'{spaces}    }}',
            f'{spaces}}}  # fmt: skip',
        ]
    if terminal:
        res += [f'{spaces}sys.exit({run})\n']
    elif context:
        res += [f'{spaces}with {run}:']
    else:
        res += [f'{spaces}res = {run}\n']
    return res


def generate_code(package: str, *, write: bool) -> str:  # noqa: C901
    """Generate CLI code.

    This has no vll.

    Args:
        package: Name of the Python package.
        write: Write code to cli module.

    Returns:
        Generated code.

    """
    module = get_module(package)
    assert module.__file__
    source = inspect.getsource(module)
    copyright_header = list(takewhile(lambda x: x.startswith('#'), source.split('\n')))
    otc = typing.TYPE_CHECKING
    typing.TYPE_CHECKING = True  # type: ignore[misc]
    allfuncs: list[AnyCall] = [cast('AnyCall', module.COMMAND)]  # pyright: ignore[reportAny]
    if addargs := cast('AnyCall | None', getattr(module, 'ADDARGFN', None)):
        allfuncs.append(addargs)
    if subcommands := cast('list[AnyCall]', getattr(module, 'SUBCOMMANDS', [])):
        allfuncs.extend(subcommands)
    for func in allfuncs:
        _ = importlib.reload(sys.modules[func.__module__])
    typing.TYPE_CHECKING = otc  # type: ignore[misc]

    imports = HEADER_IMPORTS.copy()
    completers: dict[str, Completer] = {}
    res: list[str] = []

    defargs = get_type_hints(cast('type', get_type_hints(addargs)['return'])) if addargs else {}

    root_command = allfuncs[0]
    root_commandinfo = inspect_command(root_command)
    for key in defargs:
        assert key in root_commandinfo.args, f'Addarg {key!r} needs to be argument to all commands'

    res += ['# fmt: off']
    res += generate_parser_code(root_commandinfo)
    lines, imps = generate_groups_arguments_code(root_commandinfo, defargs, completers)
    res += lines
    imports += imps

    root_executable = root_commandinfo.returntype in {int, Generator[None, None, int]}
    root_context = root_commandinfo.returntype == Generator[None, None, int]
    res.append('')

    subinfos = []
    if subcommands:
        res += [
            'SUBS = PARSER.add_subparsers(',
            "    title='sub commands',",
            "    dest='_command',",
            f'    required={not root_executable},',
            ')',
            '',
        ]
        subinfos = [inspect_command(x) for x in subcommands]
        hidden: list[str] = []
        for commandinfo in subinfos:
            for key in defargs:
                assert key in commandinfo.args, (
                    f'Addarg {key!r} needs to be argument to all commands'
                )

            if commandinfo.shortdesc.startswith('SUPPRESS.'):
                hidden.append(commandinfo.name)

            if commandinfo.returntype is NoReturn:
                helpstrs = (
                    []
                    if commandinfo.shortdesc.startswith('SUPPRESS.')
                    else [
                        f'    help={commandinfo.shortdesc!r},',
                    ]
                )

                res += [
                    'SUB = SUBS.add_parser(',
                    f'    {commandinfo.name!r},',
                    '    allow_abbrev=False,',
                    '    argument_default=argparse.SUPPRESS,',
                    '    formatter_class=HelpFormatter,',
                    f'    description={commandinfo.description},',
                    *helpstrs,
                    ')',
                    '',
                    f'SUBS_{commandinfo.name} = SUB.add_subparsers(',
                    "    title='subaction',",
                    "    dest='subaction',",
                    '    required=True,',
                    ')',
                ]
                lines, imps = [], []
            else:
                res += generate_parser_code(commandinfo, is_sub=True)
                lines, imps = generate_groups_arguments_code(
                    commandinfo,
                    defargs,
                    completers,
                    is_sub=True,
                )
            res += lines
            imports += imps
            res.append('')
    res += ['# fmt: on']

    completer_lines = [
        'def custom_complete(action: argparse.Action, args: list[str], arg: str) -> list[str]:',
        '    """Complete action."""',
        '    ret: list[str] = []',
    ]
    if addargs:
        completer_lines += [
            f'    from {addargs.__module__} import {addargs.__name__}\n',
            f'    addargs = {addargs.__name__}()',
            '',
        ]
    else:
        completer_lines += [
            '    addargs: dict[str, str] = {}',
            '',
        ]
    for actionname, completer in completers.items():
        complcmd = inspect_command(completer)
        completer_lines += [f'    if action == {actionname}:']
        if complcmd.is_async:
            completer_lines += ['        import asyncio', '']
        completer_lines += [f'        from {complcmd.module} import {complcmd.name}', '']
        run = f'{complcmd.name}(args, arg, **addargs)'
        if complcmd.is_async:
            run = f'asyncio.run({run})'
        completer_lines += [f'        ret = {run}']
    completer_lines += [
        '    return ret',
        '',
        '',
    ]

    imports = [
        x.strip() for x in imports if x and 'Sequence' not in x and 'pathlib._local' not in x
    ]
    imports = sorted(set(imports), key=lambda x: (x.startswith('from '), x))
    imports.append('')
    res = [
        *copyright_header,
        *HEADER,
        *imports,
        *HEADER_TYPE_CHECKING,
        *res,
        *completer_lines,
        *COMPLETE,
        *MAIN,
    ]

    res += ['    args = PARSER.parse_args().__dict__', '']
    if addargs:
        res += [
            f'    from {addargs.__module__} import {addargs.__name__}\n',
            f'    args.update({addargs.__name__}())',
            '',
        ]

    if root_executable:
        res += generate_execute_code(
            root_commandinfo,
            4,
            terminal=not subinfos,
            context=root_context,
        )

    indent = 8 if root_context else 4

    if subinfos:
        res += [f"{' ' * indent}_command = args.pop('_command')"]
        res += [f"{' ' * indent}_subaction = args['subaction'] if 'subaction' in args else None"]
        for commandinfo in subinfos:
            if commandinfo.returntype is NoReturn:
                continue
            if '_' in commandinfo.name:
                action, subaction = commandinfo.name.split('_', 1)
                res += [f'{" " * indent}if _command == {action!r} and _subaction == {subaction!r}:']
            else:
                res += [f'{" " * indent}if _command == {commandinfo.name!r}:']
            res += generate_execute_code(commandinfo, indent + 4, terminal=True)

        if root_executable and not root_context:
            res += [f'{" " * indent}sys.exit(res)']
        else:
            res += [f'{" " * indent}raise Exception  # pylint: disable=broad-exception-raised']
        res += ['']

    res += [
        '',
        "if __name__ == '__main__':",
        '    main()',
        '',
    ]

    code = '\n'.join(res)
    spec = spec_from_loader('_trycli', loader=None)
    assert spec
    nmodule = module_from_spec(spec)
    exec(code, nmodule.__dict__)  # noqa: S102

    if write:
        clipath = Path(module.__file__).parent / 'cli.py'
        _ = clipath.write_text(code)

        testcode = [
            *copyright_header,
            '"""Generated declinate CLI tests."""',
            '',
            '# DO NOT EDIT THIS FILE MANUALLY',
            '',
            'import inspect',
            '',
            'from declinate.check import check_package',
            'from declinate.cli import main',
            '',
            '',
            'def test_cli_is_up_to_date() -> None:',
            '    """Test if compiled cli is up to date."""',
            f'    res = check_package({package!r})',
            '    assert not res, res',
            '',
            '',
            'def test_cli() -> None:',
            '    """Cli."""',
            '    assert inspect.isfunction(main)',
            '',
        ]

        testbase = Path(module.__file__).parents[len(package.split('.')) + 1] / 'tests'
        testpath = testbase / package.replace('.', '/') / 'test_cli.py'
        if testpath.parent.exists():
            _ = testpath.write_text('\n'.join(testcode))

    return code
